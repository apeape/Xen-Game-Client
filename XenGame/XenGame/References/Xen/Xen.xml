<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Xen</name>
    </assembly>
    <members>
        <member name="T:Xen.UpdateManager">
            <summary>
            UpdateManager stores a list of <see cref="T:Xen.IUpdate"/> object instances and manages calling <see cref="M:Xen.IUpdate.Update(Xen.UpdateState)"/>
            </summary>
            <remarks><para>An update manager may be added to another update manager (as it implements IUpdate), this can make separating application logic easier.</para></remarks>
        </member>
        <member name="T:Xen.IUpdate">
            <summary>
            Interface for an object that wishes to be updated at a consistent interval (specified by <see cref="T:Xen.UpdateFrequency"/>)
            </summary>
        </member>
        <member name="M:Xen.IUpdate.Update(Xen.UpdateState)">
            <summary>
            Method for updating the object and performing logic. Called at a desired frequency
            </summary>
            <param name="state">Current state of the application</param>
            <returns>Returns a <see cref="T:Xen.UpdateFrequency"/>, indicating the frequency the object desires to be updated in the following update loop (Or <see cref="F:Xen.UpdateFrequency.Terminate"/> if the object wishes to be removed from the update list)</returns>
        </member>
        <member name="M:Xen.UpdateManager.#ctor">
            <summary>
            Construct the update manager
            </summary>
        </member>
        <member name="M:Xen.UpdateManager.Add(Xen.IUpdate)">
            <summary>
            Add an item to the update manager in direct order (See <see cref="M:Xen.UpdateManager.Add(Xen.IUpdate,System.Boolean)"/> remarks for more information)
            </summary>
            <param name="update"></param>
            <remarks>See <see cref="M:Xen.UpdateManager.Add(Xen.IUpdate,System.Boolean)"/> remarks for more information</remarks>
        </member>
        <member name="M:Xen.UpdateManager.Add(Xen.IUpdate,System.Boolean)">
            <summary>
            Add an item to the update manager either sequential order or directly. See remarks for details
            </summary>
            <param name="update"></param>
            <param name="seqentialDistribution">See remarks for details</param>
            <remarks>
            <para>
            When an item is added to an UpdateManager, it will be put in a temporary list. When main updating completes items in this list will have their <see cref="M:Xen.IUpdate.Update(Xen.UpdateState)"/> method called. This will determine their desired <see cref="T:Xen.UpdateFrequency"/> so they can be inserted into the main update list.
            </para>
            <para>Therefore if any items are created before or during the update manager's update loop, those items will also have <see cref="M:Xen.IUpdate.Update(Xen.UpdateState)"/> called in that frame (once all other updating has completed).</para>
            <para>The next time they have Update called, they will be in the main list of items.</para>
            <para>Because many items are often inserted into the update manager at once, and because items may not require they have Update called every update frame (usually for performance reasons), it is possible that the items updating at (for example) 5 times per second will mostly be at the same timestep, and not evenly distributed.</para>
            <para>By specifying <paramref name="seqentialDistribution"/> as true, the items will be inserted into the manager such that they have Update called on differet frames. If 12 items are added at 5hz, then the first item will Update on the first frame, the second on the second frame, and so on. Because there are 12 items, and 60 frames, there should be no frame where two or more items have Update called. This should help to ballance CPU load.</para>
            <para>However, this system only places items in order by sequency, and does not do more intelligent placement (eg, inserting in the shortest list). The second time the item has Update() called the <see cref="P:Xen.UpdateState.DeltaTimeSeconds"/> will be incorrect.</para>
            <para>SeqentialDistribution only affects adding the item, it does not change the logic for when an item changes it's updat frequency</para>
            </remarks>
        </member>
        <member name="M:Xen.UpdateManager.Remove(Xen.IUpdate)">
            <summary>
            Remove an item from the update manager. Returning <see cref="F:Xen.UpdateFrequency.Terminate"/> from an item's <see cref="M:Xen.IUpdate.Update(Xen.UpdateState)"/> implementation will also remove the item.
            </summary>
            <param name="update"></param>
            <returns>returns true if the item was removed</returns>
        </member>
        <member name="M:Xen.UpdateManager.RemoveAll">
            <summary>
            Remove all items from the update manager
            </summary>
        </member>
        <member name="M:Xen.UpdateManager.Dispose">
            <summary>
            Dispose the update manager
            </summary>
        </member>
        <member name="P:Xen.UpdateManager.Enabled">
            <summary>
            Gets/Sets if this update manager is enabled. When disabled, child items will not be updated.
            </summary>
            <remarks><para>As update managers can be nested within eachother, Disabling an entire update manager can be an effective way to disable large portions of a games logic structure.</para></remarks>
        </member>
        <member name="P:Xen.UpdateManager.PauseUpdatesWhenApplicationIsInactive">
            <summary>
            <para>If true, the update manager will pause all updating when <see cref="P:Xen.Application.IsActive"/> is false</para>
            <para>(Items updating at <see cref="F:Xen.UpdateFrequency.OncePerFrame"/> will still update as normal)</para>
            </summary>
        </member>
        <member name="P:Xen.UpdateManager.UpdateSpeed">
            <summary>
            <para>Update Speed scale factor, 1.0 represents full update speed, 0.5 represents halved update speed, etc.</para>
            </summary>
        </member>
        <member name="T:Xen.Threading.IAction">
            <summary>
            Interface to a task action that can be performed on a thread
            </summary>
        </member>
        <member name="M:Xen.Threading.IAction.PerformAction(System.Object)">
            <summary>
            Performs a task action (usually on a thread)
            </summary>
            <param name="data"></param>
        </member>
        <member name="T:Xen.Graphics.Modifier.ColourMaskModifier">
            <summary>
            A simple <see cref="T:Xen.IBeginEndDraw"/> drawable that modifies the <see cref="P:Xen.Graphics.RasterState.ColourWriteMask"/>, the previous mask is reset when rendering is complete.
            </summary>
        </member>
        <member name="T:Xen.IBeginEndDraw">
            <summary>
            Interface to an object that modifies draw state and must be setup/shutdown. Usually used by internal classes only
            </summary>
        </member>
        <member name="M:Xen.IBeginEndDraw.Begin(Xen.DrawState)">
            <summary>
            Drawing is about to begin
            </summary>
            <param name="state">Current state of the application</param>
        </member>
        <member name="M:Xen.IBeginEndDraw.End(Xen.DrawState)">
            <summary>
            Drawing has completed
            </summary>
            <param name="state">Current state of the application</param>
        </member>
        <member name="P:Xen.IBeginEndDraw.Enabled">
            <summary>
            Enable/Disable the begin/end process
            </summary>
        </member>
        <member name="M:Xen.Graphics.Modifier.ColourMaskModifier.#ctor(System.Boolean,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Construct the mask
            </summary>
            <param name="red"></param>
            <param name="green"></param>
            <param name="blue"></param>
            <param name="alpha"></param>
        </member>
        <member name="M:Xen.Graphics.Modifier.ColourMaskModifier.#ctor">
            <summary>
            Construct the mask (full mask, all channels drawn)
            </summary>
        </member>
        <member name="P:Xen.Graphics.Modifier.ColourMaskModifier.Alpha">
            <summary>
            Gets/Sets if the alpha colour channel is written to the render target
            </summary>
        </member>
        <member name="P:Xen.Graphics.Modifier.ColourMaskModifier.Blue">
            <summary>
            Gets/Sets if the blue colour channel is written to the render target
            </summary>
        </member>
        <member name="P:Xen.Graphics.Modifier.ColourMaskModifier.Green">
            <summary>
            Gets/Sets if the green colour channel is written to the render target
            </summary>
        </member>
        <member name="P:Xen.Graphics.Modifier.ColourMaskModifier.Red">
            <summary>
            Gets/Sets if the red colour channel is written to the render target
            </summary>
        </member>
        <member name="P:Xen.Graphics.Modifier.ColourMaskModifier.Enabled">
            <summary>
            Gets/Sets if this modified is enabled
            </summary>
        </member>
        <member name="T:Xen.Graphics.Modifier.ViewportModifier">
            <summary>
            A simple <see cref="T:Xen.IBeginEndDraw"/> drawable that modifies the <see cref="P:Microsoft.Xna.Framework.Graphics.GraphicsDevice.Viewport"/>, the previous viewport is reset when rendering is complete.
            </summary>
        </member>
        <member name="M:Xen.Graphics.Modifier.ViewportModifier.#ctor(System.Int32,System.Int32,System.Int32,System.Int32,Xen.Graphics.DrawTarget)">
            <summary>
            Construct the viewport, sized by an existing draw target
            </summary>
            <param name="left"></param>
            <param name="top"></param>
            <param name="right"></param>
            <param name="bottom"></param>
            <param name="targetSize"></param>
        </member>
        <member name="M:Xen.Graphics.Modifier.ViewportModifier.#ctor(System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Construct the viewport, all sizes are in [0,1] range
            </summary>
            <param name="left"></param>
            <param name="top"></param>
            <param name="right"></param>
            <param name="bottom"></param>
        </member>
        <member name="M:Xen.Graphics.Modifier.ViewportModifier.#ctor(Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2)">
            <summary>
            Construct the viewport, all sizes are in [0,1] range
            </summary>
            <param name="topLeft"></param>
            <param name="bottomRight"></param>
        </member>
        <member name="P:Xen.Graphics.Modifier.ViewportModifier.Enabled">
            <summary>
            Gets/Sets if this modified is enabled
            </summary>
        </member>
        <member name="P:Xen.Graphics.Modifier.ViewportModifier.MinDepth">
            <summary>
            Gets/Sets the viewport minimum depth
            </summary>
        </member>
        <member name="P:Xen.Graphics.Modifier.ViewportModifier.MaxDepth">
            <summary>
            Gets/Sets the viewport maximum depth
            </summary>
        </member>
        <member name="P:Xen.Graphics.Modifier.ViewportModifier.Left">
            <summary>
            Gets/Sets the left edge of the viewport
            </summary>
        </member>
        <member name="P:Xen.Graphics.Modifier.ViewportModifier.Right">
            <summary>
            Gets/Sets the right edge of the viewport
            </summary>
        </member>
        <member name="P:Xen.Graphics.Modifier.ViewportModifier.Top">
            <summary>
            Gets/Sets the top edge of the viewport
            </summary>
        </member>
        <member name="P:Xen.Graphics.Modifier.ViewportModifier.Bottom">
            <summary>
            Gets/Sets the bottom edge of the viewport
            </summary>
        </member>
        <member name="P:Xen.Graphics.Modifier.ViewportModifier.Width">
            <summary>
            Gets/Sets the width of the viewport
            </summary>
        </member>
        <member name="P:Xen.Graphics.Modifier.ViewportModifier.Height">
            <summary>
            Gets/Sets the height of the viewport
            </summary>
        </member>
        <member name="P:Xen.Graphics.Modifier.ViewportModifier.TopLeft">
            <summary>
            Gets/Sets the top left corner of the viewport
            </summary>
        </member>
        <member name="P:Xen.Graphics.Modifier.ViewportModifier.BottomRight">
            <summary>
            Gets/Sets the bottom right corner of the viewport
            </summary>
        </member>
        <member name="T:Xen.Graphics.Modifier.ScissorModifier">
            <summary>
            A simple <see cref="T:Xen.IBeginEndDraw"/> drawable that modifies the <see cref="P:Microsoft.Xna.Framework.Graphics.GraphicsDevice.ScissorRectangle"/>, the previous scissor rect is reset when rendering is complete.
            </summary>
        </member>
        <member name="M:Xen.Graphics.Modifier.ScissorModifier.#ctor(System.Int32,System.Int32,System.Int32,System.Int32,Xen.Graphics.DrawTarget)">
            <summary>
            Construct the scissor rectangle, based on the size of an existing draw target
            </summary>
            <param name="left"></param>
            <param name="top"></param>
            <param name="right"></param>
            <param name="bottom"></param>
            <param name="targetSize"></param>
        </member>
        <member name="M:Xen.Graphics.Modifier.ScissorModifier.#ctor(System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Construct the scissor rectangle. Sizes are in the range [0,1]
            </summary>
            <param name="left"></param>
            <param name="top"></param>
            <param name="right"></param>
            <param name="bottom"></param>
        </member>
        <member name="M:Xen.Graphics.Modifier.ScissorModifier.#ctor(Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2)">
            <summary>
            Construct the scissor rectangle. Sizes are in the range [0,1]
            </summary>
            <param name="bottomRight"></param>
            <param name="topLeft"></param>
        </member>
        <member name="P:Xen.Graphics.Modifier.ScissorModifier.Enabled">
            <summary>
            Gets/Sets if the modified is enabled
            </summary>
        </member>
        <member name="P:Xen.Graphics.Modifier.ScissorModifier.Left">
            <summary>
            Gets/Sets the left edge of the scissor rectangle
            </summary>
        </member>
        <member name="P:Xen.Graphics.Modifier.ScissorModifier.Right">
            <summary>
            Gets/Sets the right edge of the scissor rectangle
            </summary>
        </member>
        <member name="P:Xen.Graphics.Modifier.ScissorModifier.Top">
            <summary>
            Gets/Sets the top edge of the scissor rectangle
            </summary>
        </member>
        <member name="P:Xen.Graphics.Modifier.ScissorModifier.Bottom">
            <summary>
            Gets/Sets the bottom edge of the scissor rectangle
            </summary>
        </member>
        <member name="P:Xen.Graphics.Modifier.ScissorModifier.Width">
            <summary>
            Gets/Sets the width of the scissor rectangle
            </summary>
        </member>
        <member name="P:Xen.Graphics.Modifier.ScissorModifier.Height">
            <summary>
            Gets/Sets the height of the scissor rectangle
            </summary>
        </member>
        <member name="P:Xen.Graphics.Modifier.ScissorModifier.TopLeft">
            <summary>
            Gets/Sets the top left corner of the scissor rectangle
            </summary>
        </member>
        <member name="P:Xen.Graphics.Modifier.ScissorModifier.BottomRight">
            <summary>
            Gets/Sets the bottom right corner of the scissor rectangle
            </summary>
        </member>
        <member name="T:Xen.Graphics.Modifier.ClearBufferModifier">
            <summary>
            <para>A simple <see cref="T:Xen.IBeginEndDraw"/> and <see cref="T:Xen.IDraw"/> drawable that clears the colour,depth and stencil buffers.</para>
            <para>Note: All <see cref="T:Xen.Graphics.DrawTarget"/> classes include an instance of ClearBufferModifer, see <see cref="P:Xen.Graphics.DrawTarget.ClearBuffer"/></para>
            </summary>
        </member>
        <member name="T:Xen.IDraw">
            <summary>
            Interface to an object that can be drawn. All drawable objects also are <see cref="T:Xen.ICullable"/>
            </summary>
            <remarks>
            <para>Some objects, such as <see cref="T:Xen.Graphics.DrawTarget">draw targets</see> need to have <see cref="M:Xen.Graphics.DrawTarget.Draw(Xen.FrameState)">Draw</see> called explicitly, while some objects may have <see cref="M:Xen.IDraw.Draw(Xen.DrawState)"/> called from another object.</para>
            <para>A call to <see cref="M:Xen.IDraw.Draw(Xen.DrawState)"/> should not assume the object knows it's full render state. Simple geometry classes, for example, may only draw themselves. In such a case, the 'owner' IDraw object should make sure the correct render states, shaders, etc are setup first.</para>
            </remarks>
        </member>
        <member name="T:Xen.ICullable">
            <summary>
            Interface for an object that can be culled by an <see cref="T:Xen.ICuller"/>. An example use may be off-screen culling
            </summary>
        </member>
        <member name="M:Xen.ICullable.CullTest(Xen.ICuller)">
            <summary>
            Perform a cull test on the current object. Returns false if the CullTest fails (for example, the object is offscreen)
            </summary>
            <param name="culler"></param>
            <returns>Returns false if the CullTest fails (for example, the object is offscreen)</returns>
        </member>
        <member name="M:Xen.IDraw.Draw(Xen.DrawState)">
            <summary>
            Draw the object
            </summary>
            <param name="state">Current state of the application</param>
        </member>
        <member name="M:Xen.Graphics.Modifier.ClearBufferModifier.#ctor">
            <summary>
            Construct the clear buffer modifier, clearing all buffers
            </summary>
        </member>
        <member name="M:Xen.Graphics.Modifier.ClearBufferModifier.#ctor(Microsoft.Xna.Framework.Color)">
            <summary>
            Construct the clear buffer modifier, clearing all buffers
            </summary>
            <param name="colourValue"></param>
        </member>
        <member name="M:Xen.Graphics.Modifier.ClearBufferModifier.#ctor(Microsoft.Xna.Framework.Graphics.ClearOptions)">
            <summary>
            Construct the clear buffer modifier
            </summary>
            <param name="clearOptions"></param>
        </member>
        <member name="M:Xen.Graphics.Modifier.ClearBufferModifier.#ctor(Microsoft.Xna.Framework.Graphics.ClearOptions,Microsoft.Xna.Framework.Color)">
            <summary>
            Construct the clear buffer modifier
            </summary>
            <param name="clearOptions"></param>
            <param name="colourValue">Colour to clear the render target</param>
        </member>
        <member name="M:Xen.Graphics.Modifier.ClearBufferModifier.#ctor(Microsoft.Xna.Framework.Graphics.ClearOptions,Microsoft.Xna.Framework.Color,System.Single,System.Byte)">
            <summary>
            Construct the clear buffer modifier, clearing all buffers
            </summary>
            <param name="clearOptions"></param>
            <param name="colourValue">colour to clear the render target</param>
            <param name="depthValue">Depth to clear the render target (usuall 1.0f)</param>
            <param name="stencilValue">Stencil value to clear the stencil buffer to</param>
        </member>
        <member name="M:Xen.Graphics.Modifier.ClearBufferModifier.Draw(Xen.DrawState)">
            <summary>
            Clear the buffers
            </summary>
            <param name="state"></param>
        </member>
        <member name="P:Xen.Graphics.Modifier.ClearBufferModifier.ClearStencilEnabled">
            <summary>
            <para>/Sets if clearing the stencil buffer is enabled</para>
            <para>(NOTE: Stencil is always cleared on XBOX360 when changing draw target)</para>
            </summary>
        </member>
        <member name="P:Xen.Graphics.Modifier.ClearBufferModifier.ClearDepthEnabled">
            <summary>
            <para>Gets/Sets if clearing the depth buffer is enabled</para>
            <para>(NOTE: Depth is cleared on XBOX360 when changing draw target, unless the draw target <see cref="T:Microsoft.Xna.Framework.Graphics.RenderTargetUsage"/> is set to <see cref="F:Microsoft.Xna.Framework.Graphics.RenderTargetUsage.PreserveContents"/>)</para>
            </summary>
            <seealso cref="T:Xen.Graphics.DrawTargetTexture2D"/>
            <seealso cref="T:Xen.Graphics.DrawTargetTextureCube"/>
            <seealso cref="M:Xen.Application.SetupGraphicsDeviceManager(Microsoft.Xna.Framework.GraphicsDeviceManager,Microsoft.Xna.Framework.Graphics.RenderTargetUsage@)"/>
        </member>
        <member name="P:Xen.Graphics.Modifier.ClearBufferModifier.ClearColourEnabled">
            <summary>
            <para>Gets/Sets if clearing the colour buffer is enabled</para>
            <para>(NOTE: Colour is cleared on XBOX360 when changing draw target, unless the draw target <see cref="T:Microsoft.Xna.Framework.Graphics.RenderTargetUsage"/> is set to <see cref="F:Microsoft.Xna.Framework.Graphics.RenderTargetUsage.PreserveContents"/>)</para>
            </summary>
            <seealso cref="T:Xen.Graphics.DrawTargetTexture2D"/>
            <seealso cref="T:Xen.Graphics.DrawTargetTextureCube"/>
            <seealso cref="M:Xen.Application.SetupGraphicsDeviceManager(Microsoft.Xna.Framework.GraphicsDeviceManager,Microsoft.Xna.Framework.Graphics.RenderTargetUsage@)"/>
        </member>
        <member name="P:Xen.Graphics.Modifier.ClearBufferModifier.ClearDepth">
            <summary>
            Gets/Sets if value used to clear the depth buffer if <see cref="P:Xen.Graphics.Modifier.ClearBufferModifier.ClearDepthEnabled"/> is true (The depth buffer is usually best cleared to 1.0f)
            </summary>
        </member>
        <member name="P:Xen.Graphics.Modifier.ClearBufferModifier.ClearColour">
            <summary>
            Gets/Sets if colour used to clear the colour buffer if <see cref="P:Xen.Graphics.Modifier.ClearBufferModifier.ClearColourEnabled"/> is true
            </summary>
        </member>
        <member name="P:Xen.Graphics.Modifier.ClearBufferModifier.ClearStencilValue">
            <summary>
            Gets/Sets if value used to clear the stencil buffer if <see cref="P:Xen.Graphics.Modifier.ClearBufferModifier.ClearStencilEnabled"/> is true
            </summary>
        </member>
        <member name="P:Xen.Graphics.Modifier.ClearBufferModifier.Enabled">
            <summary>
            Gets/Sets if clearing the buffer is enabled
            </summary>
        </member>
        <member name="T:Xen.Graphics.Stack.DrawFlagValue`1">
            <summary>
            Stores the flag value at the top of a flag stack
            </summary>
        </member>
        <member name="F:Xen.Graphics.Stack.DrawFlagValue`1.Value">
            <summary>
            Value of the flag
            </summary>
        </member>
        <member name="T:Xen.Graphics.Stack.DrawFlagStack">
            <summary>
            <para>This stack adds support for stacks of 'draw flags' in the DrawState</para>
            <para>draw flags are custom elements that can be added to the draw state</para>
            <para>these store totally custom data (generic), usually enums or flags that change render behaviour.</para>
            </summary>
        </member>
        <member name="M:Xen.Graphics.Stack.DrawFlagStack.Push``1">
            <summary>
            <para>Push the custom Draw Flag (enum or struct) currently stoed by the DrawState</para>
            <para>Draw flags can be any value desired, usually an enum or small struct. They can be used to control draw logic</para>
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Xen.Graphics.Stack.DrawFlagStack.Push``1(``0)">
            <summary>
            <para>Push a custom Draw Flag (enum or struct) onto the DrawState</para>
            <para>Draw flags can be any value desired, usually an enum or small struct. They can be used to control draw logic</para>
            </summary>
        </member>
        <member name="M:Xen.Graphics.Stack.DrawFlagStack.Push``1(``0@)">
            <summary>
            <para>Push a custom Draw Flag (enum or struct) onto the DrawState</para>
            <para>Draw flags can be any value desired, usually an enum or small struct. 
            They can be used to control draw logic</para>
            </summary>
        </member>
        <member name="M:Xen.Graphics.Stack.DrawFlagStack.Pop``1">
            <summary>
            <para>Pop a custom Draw Flag (enum or struct), stored by the DrawState</para>
            <para>Draw flags can be any value desired, usually an enum or small struct. 
            They can be used to control draw logic</para>
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Xen.Graphics.Stack.DrawFlagStack.SetFlag``1(``0)">
            <summary>
            <para>Set a custom Draw Flag (enum or struct), stored by the DrawState</para>
            <para>Draw flags can be any value desired, usually an enum or small struct. 
            They can be used to control draw logic</para>
            <para>Note: if you are calling this method repeatadly, consider storing a reference to the flag with <see cref="M:Xen.Graphics.Stack.DrawFlagStack.GetFlagReference``1"/></para>
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Xen.Graphics.Stack.DrawFlagStack.SetFlag``1(``0@)">
            <summary>
            <para>Set a custom Draw Flag (enum or struct), stored by the DrawState</para>
            <para>Draw flags can be any value desired, usually an enum or small struct. 
            They can be used to control draw logic</para>
            <para>Note: if you are calling this method repeatadly, consider storing a reference to the flag with <see cref="M:Xen.Graphics.Stack.DrawFlagStack.GetFlagReference``1"/></para>
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Xen.Graphics.Stack.DrawFlagStack.GetFlag``1">
            <summary>
            <para>Get a custom Draw Flag (enum or struct), stored by the DrawState</para>
            <para>Draw flags can be any value desired, usually an enum or small struct. 
            They can be used to control draw logic</para>
            <para>Note: if you are calling this method repeatadly, consider storing a reference to the flag with <see cref="M:Xen.Graphics.Stack.DrawFlagStack.GetFlagReference``1"/></para>
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Xen.Graphics.Stack.DrawFlagStack.GetFlag``1(``0@)">
            <summary>
            <para>Get a custom Draw Flag (enum or struct), stored by the DrawState</para>
            <para>Draw flags can be any value desired, usually an enum or small struct. 
            They can be used to control draw logic</para>
            <para>Note: if you are calling this method repeatadly, consider storing a reference to the flag with <see cref="M:Xen.Graphics.Stack.DrawFlagStack.GetFlagReference``1"/></para>
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Xen.Graphics.Stack.DrawFlagStack.GetFlagReference``1">
            <summary>
            Gets a reference to the flag, this is the most efficient way to get and set the draw flag at the top of the stack at runtime, provided the reference to the DrawFlagValue object can be stored once.
            </summary>
        </member>
        <member name="T:Xen.Graphics.Stack.DrawFlagStack.UsingPop`1">
            <summary>
            Structure used for a using block with a Push method
            </summary>
        </member>
        <member name="M:Xen.Graphics.Stack.DrawFlagStack.UsingPop`1.Dispose">
            <summary>Invokes the Pop metohd</summary>
        </member>
        <member name="T:Xen.Graphics.IShaderGlobals">
            <summary>
            Interface to shader system global values
            </summary>
        </member>
        <member name="M:Xen.Graphics.IShaderGlobals.SetShaderGlobal(System.String,Microsoft.Xna.Framework.Matrix[])">
            <summary>
            Set the global matrix array value used by shaders
            </summary>
            <param name="name">name of the value (case sensitive)</param>
            <param name="value">value to assign the shader global</param>
        </member>
        <member name="M:Xen.Graphics.IShaderGlobals.SetShaderGlobal(System.String,Microsoft.Xna.Framework.Vector4[])">
            <summary>
            Set the global vector array value used by shaders
            </summary>
            <param name="name">name of the value (case sensitive)</param>
            <param name="value">value to assign the shader global</param>
        </member>
        <member name="M:Xen.Graphics.IShaderGlobals.SetShaderGlobal(System.String,Microsoft.Xna.Framework.Vector3[])">
            <summary>
            Set the global vector array value used by shaders
            </summary>
            <param name="name">name of the value (case sensitive)</param>
            <param name="value">value to assign the shader global</param>
        </member>
        <member name="M:Xen.Graphics.IShaderGlobals.SetShaderGlobal(System.String,Microsoft.Xna.Framework.Vector2[])">
            <summary>
            Set the global vector array value used by shaders
            </summary>
            <param name="name">name of the value (case sensitive)</param>
            <param name="value">value to assign the shader global</param>
        </member>
        <member name="M:Xen.Graphics.IShaderGlobals.SetShaderGlobal(System.String,System.Single[])">
            <summary>
            Set the global float array value used by shaders
            </summary>
            <param name="name">name of the value (case sensitive)</param>
            <param name="value">value to assign the shader global</param>
        </member>
        <member name="M:Xen.Graphics.IShaderGlobals.SetShaderGlobal(System.String,Microsoft.Xna.Framework.Matrix@)">
            <summary>
            Set the global matrix value used by shaders
            </summary>
            <param name="name">name of the value (case sensitive)</param>
            <param name="value">value to assign the shader global</param>
        </member>
        <member name="M:Xen.Graphics.IShaderGlobals.GetShaderGlobal(System.String,Microsoft.Xna.Framework.Matrix[]@)">
            <summary>
            Get the shader global array by name. Returns true if the value exists
            </summary>
            <param name="name">name of the value (case sensitive)</param>
            <param name="value">output value to be assigned the shader global value (if it exists)</param>
            <remarks>True if the value exists, and has been ouput</remarks>
        </member>
        <member name="M:Xen.Graphics.IShaderGlobals.GetShaderGlobal(System.String,Microsoft.Xna.Framework.Vector4[]@)">
            <summary>
            Get the shader global array by name. Returns true if the value exists
            </summary>
            <param name="name">name of the value (case sensitive)</param>
            <param name="value">output value to be assigned the shader global value (if it exists)</param>
            <remarks>True if the value exists, and has been ouput</remarks>
        </member>
        <member name="M:Xen.Graphics.IShaderGlobals.GetShaderGlobal(System.String,Microsoft.Xna.Framework.Vector3[]@)">
            <summary>
            Get the shader global array by name. Returns true if the value exists
            </summary>
            <param name="name">name of the value (case sensitive)</param>
            <param name="value">output value to be assigned the shader global value (if it exists)</param>
            <remarks>True if the value exists, and has been ouput</remarks>
        </member>
        <member name="M:Xen.Graphics.IShaderGlobals.GetShaderGlobal(System.String,Microsoft.Xna.Framework.Vector2[]@)">
            <summary>
            Get the shader global array by name. Returns true if the value exists
            </summary>
            <param name="name">name of the value (case sensitive)</param>
            <param name="value">output value to be assigned the shader global value (if it exists)</param>
            <remarks>True if the value exists, and has been ouput</remarks>
        </member>
        <member name="M:Xen.Graphics.IShaderGlobals.GetShaderGlobal(System.String,System.Single[]@)">
            <summary>
            Get the shader global array by name. Returns true if the value exists
            </summary>
            <param name="name">name of the value (case sensitive)</param>
            <param name="value">output value to be assigned the shader global value (if it exists)</param>
            <remarks>True if the value exists, and has been ouput</remarks>
        </member>
        <member name="M:Xen.Graphics.IShaderGlobals.GetShaderGlobal(System.String,Microsoft.Xna.Framework.Matrix@)">
            <summary>
            Get the shader global matrix by name. Returns true if the value exists
            </summary>
            <param name="name">name of the value (case sensitive)</param>
            <param name="value">output value to be assigned the shader global value (if it exists)</param>
            <remarks>True if the value exists, and has been ouput</remarks>
        </member>
        <member name="M:Xen.Graphics.IShaderGlobals.SetShaderGlobal(System.String,Microsoft.Xna.Framework.Vector4@)">
            <summary>
            Set the global vector4 value used by shaders
            </summary>
            <param name="name">name of the value (case sensitive)</param>
            <param name="value">value to assign the shader global</param>
        </member>
        <member name="M:Xen.Graphics.IShaderGlobals.GetShaderGlobal(System.String,Microsoft.Xna.Framework.Vector4@)">
            <summary>
            Get the shader global vector4 by name. Returns true if the value exists
            </summary>
            <param name="name">name of the value (case sensitive)</param>
            <param name="value">output value to be assigned the shader global value (if it exists)</param>
            <remarks>True if the value exists, and has been ouput</remarks>
        </member>
        <member name="M:Xen.Graphics.IShaderGlobals.SetShaderGlobal(System.String,Microsoft.Xna.Framework.Vector3@)">
            <summary>
            Set the global vector3 value used by shaders
            </summary>
            <param name="name">name of the value (case sensitive)</param>
            <param name="value">value to assign the shader global</param>
        </member>
        <member name="M:Xen.Graphics.IShaderGlobals.GetShaderGlobal(System.String,Microsoft.Xna.Framework.Vector3@)">
            <summary>
            Get the shader global vector3 by name. Returns true if the value exists
            </summary>
            <param name="name">name of the value (case sensitive)</param>
            <param name="value">output value to be assigned the shader global value (if it exists)</param>
            <remarks>True if the value exists, and has been ouput</remarks>
        </member>
        <member name="M:Xen.Graphics.IShaderGlobals.SetShaderGlobal(System.String,Microsoft.Xna.Framework.Vector2@)">
            <summary>
            Set the global vector2 value used by shaders
            </summary>
            <param name="name">name of the value (case sensitive)</param>
            <param name="value">value to assign the shader global</param>
        </member>
        <member name="M:Xen.Graphics.IShaderGlobals.GetShaderGlobal(System.String,Microsoft.Xna.Framework.Vector2@)">
            <summary>
            Get the shader global vector2 by name. Returns true if the value exists
            </summary>
            <param name="name">name of the value (case sensitive)</param>
            <param name="value">output value to be assigned the shader global value (if it exists)</param>
            <remarks>True if the value exists, and has been ouput</remarks>
        </member>
        <member name="M:Xen.Graphics.IShaderGlobals.SetShaderGlobal(System.String,Microsoft.Xna.Framework.Vector4)">
            <summary>
            Set the global Vector4 value used by shaders
            </summary>
            <param name="name">name of the value (case sensitive)</param>
            <param name="value">value to assign the shader global</param>
        </member>
        <member name="M:Xen.Graphics.IShaderGlobals.SetShaderGlobal(System.String,Microsoft.Xna.Framework.Vector3)">
            <summary>
            Set the global vector3 value used by shaders
            </summary>
            <param name="name">name of the value (case sensitive)</param>
            <param name="value">value to assign the shader global</param>
        </member>
        <member name="M:Xen.Graphics.IShaderGlobals.SetShaderGlobal(System.String,Microsoft.Xna.Framework.Vector2)">
            <summary>
            Set the global vector2 value used by shaders
            </summary>
            <param name="name">name of the value (case sensitive)</param>
            <param name="value">value to assign the shader global</param>
        </member>
        <member name="M:Xen.Graphics.IShaderGlobals.SetShaderGlobal(System.String,System.Single)">
            <summary>
            Set the global float value used by shaders
            </summary>
            <param name="name">name of the value (case sensitive)</param>
            <param name="value">value to assign the shader global</param>
        </member>
        <member name="M:Xen.Graphics.IShaderGlobals.SetShaderGlobal(System.String,System.Boolean)">
            <summary>
            Set the global boolean value used by shaders
            </summary>
            <param name="name">name of the value (case sensitive)</param>
            <param name="value">value to assign the shader global</param>
        </member>
        <member name="M:Xen.Graphics.IShaderGlobals.GetShaderGlobal(System.String,System.Single@)">
            <summary>
            Get the shader global float by name. Returns true if the value exists
            </summary>
            <param name="name">name of the value (case sensitive)</param>
            <param name="value">output value to be assigned the shader global value (if it exists)</param>
            <remarks>True if the value exists, and has been ouput</remarks>
        </member>
        <member name="M:Xen.Graphics.IShaderGlobals.SetShaderGlobal(System.String,Xen.Graphics.TextureSamplerState)">
            <summary>
            Set the global texture sampler state used by shaders
            </summary>
            <param name="name">name of the value (case sensitive)</param>
            <param name="value">value to assign the shader global</param>
        </member>
        <member name="M:Xen.Graphics.IShaderGlobals.SetShaderGlobal(System.String,Microsoft.Xna.Framework.Graphics.Texture)">
            <summary>
            Set the global texture used by shaders
            </summary>
            <param name="name">name of the value (case sensitive)</param>
            <param name="value">value to assign the shader global</param>
        </member>
        <member name="M:Xen.Graphics.IShaderGlobals.GetShaderGlobal(System.String,Microsoft.Xna.Framework.Graphics.Texture@)">
            <summary>
            Get the shader global texture by name. Returns true if the value exists
            </summary>
            <param name="name">name of the value (case sensitive)</param>
            <param name="value">output value to be assigned the shader global value (if it exists)</param>
            <remarks>True if the value exists, and has been ouput</remarks>
        </member>
        <member name="M:Xen.Graphics.IShaderGlobals.SetShaderGlobal(System.String,Microsoft.Xna.Framework.Graphics.Texture2D)">
            <summary>
            Set the global texture (2D) used by shaders
            </summary>
            <param name="name">name of the value (case sensitive)</param>
            <param name="value">value to assign the shader global</param>
        </member>
        <member name="M:Xen.Graphics.IShaderGlobals.GetShaderGlobal(System.String,Microsoft.Xna.Framework.Graphics.Texture2D@)">
            <summary>
            Get the shader global texture (2D) by name. Returns true if the value exists
            </summary>
            <param name="name">name of the value (case sensitive)</param>
            <param name="value">output value to be assigned the shader global value (if it exists)</param>
            <remarks>True if the value exists, and has been ouput</remarks>
        </member>
        <member name="M:Xen.Graphics.IShaderGlobals.SetShaderGlobal(System.String,Microsoft.Xna.Framework.Graphics.Texture3D)">
            <summary>
            Set the global texture (3D) used by shaders
            </summary>
            <param name="name">name of the value (case sensitive)</param>
            <param name="value">value to assign the shader global</param>
        </member>
        <member name="M:Xen.Graphics.IShaderGlobals.GetShaderGlobal(System.String,Microsoft.Xna.Framework.Graphics.Texture3D@)">
            <summary>
            Get the shader global texture (3D) by name. Returns true if the value exists
            </summary>
            <param name="name">name of the value (case sensitive)</param>
            <param name="value">output value to be assigned the shader global value (if it exists)</param>
            <remarks>True if the value exists, and has been ouput</remarks>
        </member>
        <member name="M:Xen.Graphics.IShaderGlobals.SetShaderGlobal(System.String,Microsoft.Xna.Framework.Graphics.TextureCube)">
            <summary>
            Set the global texture (cubemap) used by shaders
            </summary>
            <param name="name">name of the value (case sensitive)</param>
            <param name="value">value to assign the shader global</param>
        </member>
        <member name="M:Xen.Graphics.IShaderGlobals.GetShaderGlobal(System.String,Microsoft.Xna.Framework.Graphics.TextureCube@)">
            <summary>
            Get the shader global texture (cubemap) by name. Returns true if the value exists
            </summary>
            <param name="name">name of the value (case sensitive)</param>
            <param name="value">output value to be assigned the shader global value (if it exists)</param>
            <remarks>True if the value exists, and has been ouput</remarks>
        </member>
        <member name="T:Xen.Graphics.Stack.ShaderStack">
            <summary>
            Shader stack storage for the DrawState
            </summary>
        </member>
        <member name="M:Xen.Graphics.Stack.ShaderStack.op_Addition(Xen.Graphics.Stack.ShaderStack,Xen.Graphics.IShader)">
            <summary>
            Wrapper on Push
            </summary>
        </member>
        <member name="M:Xen.Graphics.Stack.ShaderStack.op_Addition(Xen.Graphics.Stack.ShaderStack,Microsoft.Xna.Framework.Graphics.Effect)">
            <summary>
            Wrapper on Push
            </summary>
        </member>
        <member name="M:Xen.Graphics.Stack.ShaderStack.Push``1">
            <summary>
            Pushes a generic instance of the given shader type on to the top of the current rendering shader stack
            <para>Note: this method can be used in a 'using() {}' block to automatically call <see cref="M:Xen.Graphics.Stack.ShaderStack.Pop"/></para>
            </summary>
        </member>
        <member name="M:Xen.Graphics.Stack.ShaderStack.Push(Xen.Graphics.IShader)">
            <summary>
            Pushes the shader on to the top of the current rendering shader stack
            <para>Note: this method can be used in a 'using() {}' block to automatically call <see cref="M:Xen.Graphics.Stack.ShaderStack.Pop"/></para>
            </summary>
        </member>
        <member name="M:Xen.Graphics.Stack.ShaderStack.Push(Microsoft.Xna.Framework.Graphics.Effect)">
            <summary>
            Pushes the Effect on to the top of the current rendering shader stack
            <para>Note: this method can be used in a 'using() {}' block to automatically call <see cref="M:Xen.Graphics.Stack.ShaderStack.Pop"/></para>
            </summary>
        </member>
        <member name="M:Xen.Graphics.Stack.ShaderStack.Push">
            <summary>
            Duplicates the shader on to the top of the current rendering shader stack
            <para>Note: this method can be used in a 'using() {}' block to automatically call <see cref="M:Xen.Graphics.Stack.ShaderStack.Pop"/></para>
            </summary>
        </member>
        <member name="M:Xen.Graphics.Stack.ShaderStack.Pop">
            <summary>
            Pops the top of the rendering shader stack, Restoring the shader saved with <see cref="M:Xen.Graphics.Stack.ShaderStack.Push(Xen.Graphics.IShader)"/>
            </summary>
        </member>
        <member name="M:Xen.Graphics.Stack.ShaderStack.Set(Xen.Graphics.IShader)">
            <summary>
            Sets the current shader, replacing the shader at the top of the stack
            </summary>
        </member>
        <member name="M:Xen.Graphics.Stack.ShaderStack.Set(Microsoft.Xna.Framework.Graphics.Effect)">
            <summary>
            Sets the current <see cref="T:Microsoft.Xna.Framework.Graphics.Effect"/>, replacing the shader at the top of the stack
            </summary>
        </member>
        <member name="P:Xen.Graphics.Stack.ShaderStack.CurrentShader">
            <summary>
            Gets the shader at the top of the shader stack
            <para>Returns null if an <see cref="T:Microsoft.Xna.Framework.Graphics.Effect"/> is currently at the top of the stack</para>
            </summary>
        </member>
        <member name="P:Xen.Graphics.Stack.ShaderStack.CurrentEffect">
            <summary>
            Gets the Effect at the top of the shader stack
            <para>Returns null if an <see cref="T:Xen.Graphics.IShader"/> is currently at the top of the stack</para>
            </summary>
        </member>
        <member name="T:Xen.Graphics.Stack.ShaderStack.UsingPop">
            <summary>
            Structure used for a using block with a Push method
            </summary>
        </member>
        <member name="M:Xen.Graphics.Stack.ShaderStack.UsingPop.Dispose">
            <summary>Invokes the Pop metohd</summary>
        </member>
        <member name="T:Xen.IContentOwner">
            <summary>
            Interface to an object that wishes to load content through an XNA <see cref="T:Microsoft.Xna.Framework.Content.ContentManager"/>, or handle implementation specific content load/unload logic, for use with the <see cref="T:Xen.ContentRegister"/> class (such as the <see cref="P:Xen.Application.Content"/> instance)
            </summary>
            <remarks>
            <para>This interface is intended as a lightweight replacement for the content loading methods found in <see cref="T:Microsoft.Xna.Framework.DrawableGameComponent"/></para>
            <para>All XNA content should be loaded within these methods, with the exception of Textures returned by <see cref="M:Xen.Graphics.DrawTargetTexture2D.GetTexture"/> and <see cref="M:Xen.Graphics.DrawTargetTextureCube.GetTexture"/>.
            <br/>These textures become invalid after a call to <see cref="M:Xen.IContentUnload.UnloadContent"/>, they are guarenteed to be valid again during the subsequent <see cref="M:Xen.IContentOwner.LoadContent(Xen.ContentState)"/> call.</para>
            <para>When registered with a <see cref="T:Xen.ContentRegister"/> object, a weak reference of the instance will be stored. This will prevent the object from being kept alive in an unexpected way</para>
            </remarks>
        </member>
        <member name="M:Xen.IContentOwner.LoadContent(Xen.ContentState)">
            <summary>
            Load all XNA <see cref="T:Microsoft.Xna.Framework.Content.ContentManager"/> content, or get textures from <see cref="T:Xen.Graphics.DrawTargetTexture2D"/> or <see cref="T:Xen.Graphics.DrawTargetTextureCube"/> objects.
            </summary>
        </member>
        <member name="T:Xen.IContentUnload">
            <summary>
            Interface to an object that wishes to load and unload content through an XNA <see cref="T:Microsoft.Xna.Framework.Content.ContentManager"/>, or handle implementation specific content load/unload logic, for use with the <see cref="T:Xen.ContentRegister"/> class (such as the <see cref="P:Xen.Application.Content"/> instance)
            </summary>
        </member>
        <member name="M:Xen.IContentUnload.UnloadContent">
            <summary>
            Unload all XNA <see cref="T:Microsoft.Xna.Framework.Content.ContentManager"/> content, or null textures from <see cref="T:Xen.Graphics.DrawTargetTexture2D"/> or <see cref="T:Xen.Graphics.DrawTargetTextureCube"/> objects.
            </summary>
        </member>
        <member name="T:Xen.IContentRegister">
            <summary>
            Interface to a <see cref="T:Xen.ContentRegister"/>
            </summary>
        </member>
        <member name="M:Xen.IContentRegister.Add(Xen.IContentOwner)">
            <summary>
            Register an <see cref="T:Xen.IContentOwner"/> instance with this content manager
            </summary>
            <param name="owner"></param>
        </member>
        <member name="M:Xen.IContentRegister.Remove(Xen.IContentOwner)">
            <summary>
            Unregister an <see cref="T:Xen.IContentOwner"/> instance with this content manager. NOTE: Instances are stored by weak reference and do not need to be manually removed (see remarks)
            </summary>
            <remarks><para>Instances are stored by weak reference, so this method should only be called when removing the object early is desired.</para>
            <para>Instances will not be kept alive when added, and do not need to be removed to make sure they are garbage collected</para></remarks>
            <param name="owner"></param>
        </member>
        <member name="T:Xen.ContentState">
            <summary>
            Use this class to load content in a LoadContent method, or to initalise rendering of load-time resources with <see cref="M:Xen.ContentState.PreFrameDraw(Xen.IFrameDraw)"/>
            </summary>
        </member>
        <member name="T:Xen.IState">
            <summary>
            Interface to state storage objects (<see cref="T:Xen.DrawState"/> and <see cref="T:Xen.UpdateState"/>)
            </summary>
        </member>
        <member name="P:Xen.IState.IsAsynchronousState">
            <summary>
            True if the current state is potentially running on multiple threads
            </summary>
        </member>
        <member name="P:Xen.IState.Application">
            <summary>
            Get the Application instance
            </summary>
        </member>
        <member name="P:Xen.IState.DeltaTimeFrequency">
            <summary>
            Time delta (change) for the last frame/update as a frequency. Eg, 60 for 60fps
            </summary>
        </member>
        <member name="P:Xen.IState.DeltaTimeSeconds">
            <summary>
            Time delta (change) for the last frame/update as a number of seconds. Eg, 0.0166 for 60fps
            </summary>
        </member>
        <member name="P:Xen.IState.DeltaTimeTicks">
            <summary>
            Accurate DeltaTime timespan
            </summary>
        </member>
        <member name="P:Xen.IState.TotalTimeTicks">
            <summary>
            Accurate performance time (application time may be different to real time if the application has performance problems)
            </summary>
        </member>
        <member name="P:Xen.IState.TotalTimeSeconds">
            <summary>
            Total time in seconds
            </summary>
        </member>
        <member name="M:Xen.ContentState.op_Implicit(Xen.ContentState)~Microsoft.Xna.Framework.Content.ContentManager">
            <summary>
            Implicit conversion to an XNA content manager
            </summary>
            <returns></returns>
        </member>
        <member name="M:Xen.ContentState.op_Implicit(Xen.ContentState)~Microsoft.Xna.Framework.Graphics.GraphicsDevice">
            <summary>
            Implicit conversion to the GraphicsDevice, typically this method should only be used for object creation
            </summary>
            <returns></returns>
        </member>
        <member name="M:Xen.ContentState.Load``1(System.String)">
            <summary>
            Loads an asset that has been processed by the Content Pipeline.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="assetName"></param>
            <returns></returns>
        </member>
        <member name="M:Xen.ContentState.PreFrameDraw(Xen.IFrameDraw)">
            <summary>
            <para>The the item passed in will be drawn at the start of the next frame, before the main application Draw method is called</para>
            <para>Use this method to dynamically create rendererd resources at load-time</para>
            </summary>
        </member>
        <member name="P:Xen.ContentState.ContentRegister">
            <summary>
            Get the Content Register associated with this state
            </summary>
            <returns></returns>
        </member>
        <member name="P:Xen.ContentState.Application">
            <summary>
            Gets the application associated with this content state object
            </summary>
        </member>
        <member name="T:Xen.ContentRegister">
            <summary>
            Wrapper on an XNA <see cref="T:Microsoft.Xna.Framework.Content.ContentManager"/>. Keeps track of <see cref="T:Xen.IContentOwner"/> instatnces by <see cref="T:System.WeakReference">weak reference</see>, calling Load/Unload content.
            </summary>
            <remarks>The <see cref="T:Xen.Application"/> class has its own instance of <see cref="P:Xen.Application.Content"/></remarks>
        </member>
        <member name="M:Xen.ContentRegister.op_Implicit(Xen.ContentRegister)~Microsoft.Xna.Framework.Content.ContentManager">
            <summary>
            Implicit conversion to an XNA content manager
            </summary>
            <param name="reg"></param>
            <returns></returns>
        </member>
        <member name="M:Xen.ContentRegister.#ctor(Xen.Application)">
            <summary>
            Construct a object content manager, creating an XNA content manager
            </summary>
            <param name="application">Application instance</param>
        </member>
        <member name="M:Xen.ContentRegister.#ctor(Xen.Application,System.String)">
            <summary>
            Construct a object content manager, creating an XNA content manager
            </summary>
            <param name="application">Application instance</param>
            <param name="rootDirectory">Root content directory</param>
        </member>
        <member name="M:Xen.ContentRegister.#ctor(Xen.Application,Microsoft.Xna.Framework.Content.ContentManager)">
            <summary>
            Construct a object content manager
            </summary>
            <param name="application">Application instance</param>
            <param name="manager">XNA ContentManager instatnce</param>
        </member>
        <member name="M:Xen.ContentRegister.Add(Xen.IContentOwner)">
            <summary>
            Register an <see cref="T:Xen.IContentOwner"/> instance with this content manager
            </summary>
            <param name="owner"></param>
        </member>
        <member name="M:Xen.ContentRegister.Remove(Xen.IContentOwner)">
            <summary>
            Unregister an <see cref="T:Xen.IContentOwner"/> instance with this content manager. NOTE: Instances are stored by weak reference and do not need to be manually removed (see remarks)
            </summary>
            <remarks><para>Instances are stored by weak reference, so this method should only be called when removing the object early is desired.</para>
            <para>Instances will not be kept alive when added, and do not need to be removed to make sure they are garbage collected</para></remarks>
            <param name="owner"></param>
        </member>
        <member name="M:Xen.ContentRegister.Dispose">
            <summary>
            Dispose the Content manager and unload all instances
            </summary>
        </member>
        <member name="P:Xen.ContentRegister.RootDirectory">
            <summary>
            Gets or sets the ContentManager root directory.
            </summary>
        </member>
        <member name="T:Xen.Camera.Projection">
            <summary>
            Class storing a <see cref="T:Xen.Camera.Camera3D"/> projection matrix. May be a Perspective or Orthographic project
            </summary>
            <remarks>This class may be extended to implement more complex forms of projection</remarks>
        </member>
        <member name="M:Xen.Camera.Projection.GetProjectionMatrix(Microsoft.Xna.Framework.Matrix@,Microsoft.Xna.Framework.Vector2@,System.Int32@)">
            <summary>
            Get the current projection matrix, if it has changed (compared to changeIndex)
            </summary>
            <param name="matrix">output projection matrix</param>
            <param name="changeIndex">change indexer</param>
            <param name="drawTargetSize">size of the draw target (input)</param>
            <returns>true if the matrix has changed and was returned</returns>
        </member>
        <member name="M:Xen.Camera.Projection.CopyFrom(Xen.Camera.Projection)">
            <summary>
            Fast copy projection settings from another projection object
            </summary>
            <param name="projection"></param>
        </member>
        <member name="M:Xen.Camera.Projection.#ctor">
            <summary>
            Construct the default projection
            </summary>
        </member>
        <member name="M:Xen.Camera.Projection.#ctor(System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Construct a projection
            </summary>
            <param name="fieldOfView">Field of view of the projection, in radians</param>
            <param name="nearPlane">Distance to the near clipping plane</param>
            <param name="farPlane">Distance to the far clipping plane</param>
            <param name="aspectRatio">Aspect ratio of the projection</param>
        </member>
        <member name="M:Xen.Camera.Projection.CalculateProjectionMatrix(Microsoft.Xna.Framework.Matrix@)">
            <summary>
            Overrideable method to calcluate the projection matrix
            </summary>
            <param name="projection"></param>
        </member>
        <member name="M:Xen.Camera.Projection.GetVerticalFovTangent">
            <summary>
            Gets the tangent of the vertical field of view of the projection
            </summary>
            <returns></returns>
        </member>
        <member name="M:Xen.Camera.Projection.GetHorizontalFovTangent">
            <summary>
            Gets the tangent of the horizontal field of view of the projection
            </summary>
            <returns></returns>
        </member>
        <member name="P:Xen.Camera.Projection.UseLeftHandedProjection">
            <summary>
            XNA projection matrices are right handed whereas DirectX is left handed, which can sometimes cause unexpected projection with rendered cubemaps. Set to true to use left handed projection.
            </summary>
        </member>
        <member name="P:Xen.Camera.Projection.PauseFrustumCullPlaneUpdates">
            <summary>
            <para>(Use for scene Debugging)</para>
            <para>When true, this Projections frustum cull planes will not be updated.</para>
            <para>This can be used to 'pause' frustum culling, while still allowing the camera to move. This allows visual debugging of off screen culling.</para>
            </summary>
        </member>
        <member name="P:Xen.Camera.Projection.Orthographic">
            <summary>
            Gets/Sets if this projection uses an orhographic projection. Change the <see cref="P:Xen.Camera.Projection.Region"/> to modify the othrographic area
            </summary>
        </member>
        <member name="P:Xen.Camera.Projection.Region">
            <summary>
            Region the projection covers. Represented as TopLeft,BottomRight. The default value is 0,0,1,1
            </summary>
        </member>
        <member name="P:Xen.Camera.Projection.ProjectionMatrix">
            <summary>
            Gets the projection matrix. <see cref="M:Xen.Camera.Projection.GetProjectionMatrix(Microsoft.Xna.Framework.Matrix@,Microsoft.Xna.Framework.Vector2@)"/> is the preferred method
            </summary>
        </member>
        <member name="P:Xen.Camera.Projection.FieldOfView">
            <summary>
            Gets/Sets the field of view of the projection (in radians)
            </summary>
        </member>
        <member name="P:Xen.Camera.Projection.Aspect">
            <summary>
            Gets/Sets the aspect ratio of the projection. (Specify 'null' to have the aspect ratio computed by the width and height of the draw target)
            </summary>
            <remarks>
            <para>An aspect ratio of 1 is a square projection</para>
            <para>Aspect ratios are most commonly set to the Width/Height of the current render target, this will be automatically calculated if <see cref="P:Xen.Camera.Projection.Aspect"/> is set to null.</para>
            <para>Aspect ratio has no effect on an orthographic projection</para>
            </remarks>
        </member>
        <member name="P:Xen.Camera.Projection.FarClip">
            <summary>
            Gets/Sets the far clipping plane distance of the projection (See <see cref="P:Xen.Camera.Projection.NearClip"/> remarks for more details)
            </summary>
            <remarks><para>The far clipping plane represents how far geometry will be visible before it goes outside of the z buffers range</para></remarks>
            <seealso cref="P:Xen.Camera.Projection.NearClip"/>
        </member>
        <member name="P:Xen.Camera.Projection.NearClip">
            <summary>
            Gets/Sets the near clipping plane distance of the projection
            </summary>
            <remarks>
            <para>The near clip plane distance determines how close geometry can get to the camera before it goes outside of the range of the z buffer, and gets clipped
            </para>
            <para>Note, the z-buffer stores depth as non-linear values. A value close to the near clip plane will be closer to 0, and will be stored with greater accuracy</para>
            <para>Further values will have larger z values, and have lower precision.</para>
            <para>Consider:</para>
            <para>An apprximate measure of the accurate range of the depth buffer is FarClip / NearClip. The smaller the value, the more accurate.</para>
            <para>Therefore, to double z-buffer accuracy, you can either halve the FarClip or double the NearClip. Consider the implications of both if the NearClip is 0.01 and the FarClip is 10,000.</para>
            <para>In short, keep the NearClip value as large as you can. (default value is 1)</para>
            </remarks>
        </member>
        <member name="T:Xen.Camera.Camera2D">
            <summary>
            Simple Camera with no projection. May be normalised with <see cref="P:Xen.Camera.Camera2D.UseNormalisedCoordinates"/> for a range of [0,1]
            </summary>
        </member>
        <member name="T:Xen.Camera.ICamera">
            <summary>
            Interface to a Camera
            </summary>
        </member>
        <member name="T:Xen.ICullPrimitive">
            <summary>
            Interface to an object that can cull test and intersect test primitive shapes
            </summary>
        </member>
        <member name="M:Xen.ICullPrimitive.TestWorldBox(Microsoft.Xna.Framework.Vector3@,Microsoft.Xna.Framework.Vector3@,Microsoft.Xna.Framework.Matrix@)">
            <summary>
            FrustumCull test a world space box.
            </summary>
            <param name="min">box minimum point (in local space)</param>
            <param name="max">box maximum point (in local space)</param>
            <param name="world">Absolute world-space world matrix of the box (current world matrix is ignored)</param>
            <returns>True if the test passes (eg, box is on screen, box intersects shape, etc)</returns>
        </member>
        <member name="M:Xen.ICullPrimitive.TestWorldBox(Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Matrix@)">
            <summary>
            FrustumCull test a world space box.
            </summary>
            <param name="min">box minimum point (in local space)</param>
            <param name="max">box maximum point (in local space)</param>
            <param name="world">Absolute world-space world matrix of the box (current world matrix is ignored)</param>
            <returns>True if the test passes (eg, box is on screen, box intersects shape, etc)</returns>
        </member>
        <member name="M:Xen.ICullPrimitive.TestWorldBox(Microsoft.Xna.Framework.Vector3@,Microsoft.Xna.Framework.Vector3@)">
            <summary>
            FrustumCull test an axis-aligned bounding box.
            </summary>
            <param name="min">box minimum point</param>
            <param name="max">box maximum point</param>
            <returns>True if the test passes (eg, box is on screen, box intersects shape, etc)</returns>
        </member>
        <member name="M:Xen.ICullPrimitive.TestWorldBox(Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3)">
            <summary>
            FrustumCull test an axis-aligned bounding box.
            </summary>
            <param name="min">box minimum point</param>
            <param name="max">box maximum point</param>
            <returns>True if the test passes (eg, box is on screen, box intersects shape, etc)</returns>
        </member>
        <member name="M:Xen.ICullPrimitive.TestWorldSphere(System.Single,Microsoft.Xna.Framework.Vector3@)">
            <summary>
            FrustumCull test a sphere.
            </summary>
            <param name="position">Absolute world-space position of the sphere (current world matrix is ignored)</param>
            <param name="radius">Radius of the sphere</param>
            <returns>True if the test passes (eg, sphere is on screen, sphere intersects shape, etc)</returns>
        </member>
        <member name="M:Xen.ICullPrimitive.TestWorldSphere(System.Single,Microsoft.Xna.Framework.Vector3)">
            <summary>
            FrustumCull test a sphere.
            </summary>
            <param name="position">Absolute world-space position of the sphere (current world matrix is ignored)</param>
            <param name="radius">Radius of the sphere</param>
            <returns>True if the test passes (eg, sphere is on screen, sphere intersects shape, etc)</returns>
        </member>
        <member name="M:Xen.ICullPrimitive.IntersectWorldBox(Microsoft.Xna.Framework.Vector3@,Microsoft.Xna.Framework.Vector3@,Microsoft.Xna.Framework.Matrix@)">
            <summary>
            <para>Intersect test a world space box.</para>
            <para>Note: Intersection tests may be less efficient than boolean TestWorldBox</para>
            </summary>
            <param name="min">box minimum point (in local space)</param>
            <param name="max">box maximum point (in local space)</param>
            <param name="world">Absolute world-space world matrix of the box (current world matrix is ignored)</param>
            <returns>Intersetction test result</returns>
        </member>
        <member name="M:Xen.ICullPrimitive.IntersectWorldBox(Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Matrix@)">
            <summary>
            <para>Intersect test a world space box.</para>
            <para>Note: Intersection tests may be less efficient than boolean TestWorldBox</para>
            </summary>
            <param name="min">box minimum point (in local space)</param>
            <param name="max">box maximum point (in local space)</param>
            <param name="world">Absolute world-space world matrix of the box (current world matrix is ignored)</param>
            <returns>Intersetction test result</returns>
        </member>
        <member name="M:Xen.ICullPrimitive.IntersectWorldBox(Microsoft.Xna.Framework.Vector3@,Microsoft.Xna.Framework.Vector3@)">
            <summary>
            <para>Intersect test an axis aligned bounding box.</para>
            <para>Note: Intersection tests may be less efficient than boolean TestWorldBox</para>
            </summary>
            <param name="min">box minimum point</param>
            <param name="max">box maximum point</param>
            <returns>Intersetction test result</returns>
        </member>
        <member name="M:Xen.ICullPrimitive.IntersectWorldBox(Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3)">
            <summary>
            <para>Intersect test an axis aligned bounding box.</para>
            <para>Note: Intersection tests may be less efficient than boolean TestWorldBox</para>
            </summary>
            <param name="min">box minimum point</param>
            <param name="max">box maximum point</param>
            <returns>Intersetction test result</returns>
        </member>
        <member name="M:Xen.ICullPrimitive.IntersectWorldSphere(System.Single,Microsoft.Xna.Framework.Vector3@)">
            <summary>
            Intersect test a sphere.
            </summary>
            <param name="position">Absolute world-space position of the sphere (current world matrix is ignored)</param>
            <param name="radius">Radius of the sphere</param>
            <returns>Intersetction test result</returns>
        </member>
        <member name="M:Xen.ICullPrimitive.IntersectWorldSphere(System.Single,Microsoft.Xna.Framework.Vector3)">
            <summary>
            Intersect test a sphere.
            </summary>
            <param name="position">Absolute world-space position of the sphere (current world matrix is ignored)</param>
            <param name="radius">Radius of the sphere</param>
            <returns>Intersetction test result</returns>
        </member>
        <member name="M:Xen.Camera.ICamera.GetViewMatrix(Microsoft.Xna.Framework.Matrix@)">
            <summary>
            Gets the view matrix for this camera
            </summary>
            <remarks>The view matrix is the <see cref="M:Microsoft.Xna.Framework.Matrix.Invert(Microsoft.Xna.Framework.Matrix)">inverse</see> of the <see cref="M:Xen.Camera.ICamera.GetCameraMatrix(Microsoft.Xna.Framework.Matrix@)">camera matrix</see></remarks>
            <param name="matrix"></param>
        </member>
        <member name="M:Xen.Camera.ICamera.GetCameraMatrix(Microsoft.Xna.Framework.Matrix@)">
            <summary>
            Gets the matrix for this camera's position/rotation
            </summary>
            <remarks>The <see cref="M:Xen.Camera.ICamera.GetViewMatrix(Microsoft.Xna.Framework.Matrix@)">view matrix</see> is the <see cref="M:Microsoft.Xna.Framework.Matrix.Invert(Microsoft.Xna.Framework.Matrix)">inverse</see> of the camera matrix</remarks>
            <param name="matrix"></param>
        </member>
        <member name="M:Xen.Camera.ICamera.GetProjectionMatrix(Microsoft.Xna.Framework.Matrix@,Microsoft.Xna.Framework.Vector2@,System.Int32@)">
            <summary>
            Gets the projection matrix for this camera, with a change index. Returns true if the matrix has changed
            </summary>
            <param name="matrix"></param>
            <param name="changeIndex"></param>
            <param name="drawTargetSize">Size of the current draw target (some projections may automatically calculate aspect ratio based on the size of the draw target)</param>
            <returns>true if the matrix has changed</returns>
        </member>
        <member name="M:Xen.Camera.ICamera.GetProjectionMatrix(Microsoft.Xna.Framework.Matrix@,Microsoft.Xna.Framework.Vector2@)">
            <summary>
            Gets the projection matrix for this camera
            </summary>
            <param name="drawTargetSize">Size of the current draw target (some projections may automatically calculate aspect ratio based on the size of the draw target)</param>
            <param name="matrix"></param>
        </member>
        <member name="M:Xen.Camera.ICamera.GetProjectionMatrix(Microsoft.Xna.Framework.Matrix@,Microsoft.Xna.Framework.Vector2)">
            <summary>
            Gets the projection matrix for this camera
            </summary>
            <param name="drawTargetSize">Size of the current draw target (some projections may automatically calculate aspect ratio based on the size of the draw target)</param>
            <param name="matrix"></param>
        </member>
        <member name="M:Xen.Camera.ICamera.GetViewMatrix(Microsoft.Xna.Framework.Matrix@,System.Int32@)">
            <summary>
            Gets the view matrix for this camera, with a change index. Returns true if the matrix has changed
            </summary>
            <remarks>The view matrix is the <see cref="M:Microsoft.Xna.Framework.Matrix.Invert(Microsoft.Xna.Framework.Matrix)">inverse</see> of the <see cref="M:Xen.Camera.ICamera.GetCameraMatrix(Microsoft.Xna.Framework.Matrix@)">camera matrix</see></remarks>
            <param name="matrix"></param>
            <param name="changeIndex"></param>
            <returns>true if the matrix has changed</returns>
        </member>
        <member name="M:Xen.Camera.ICamera.GetCameraMatrix(Microsoft.Xna.Framework.Matrix@,System.Int32@)">
            <summary>
            Gets the matrix for this camera's position/rotation, with a change index. Returns true if the matrix has changed
            </summary>
            <remarks>The <see cref="M:Xen.Camera.ICamera.GetViewMatrix(Microsoft.Xna.Framework.Matrix@)">view matrix</see> is the <see cref="M:Microsoft.Xna.Framework.Matrix.Invert(Microsoft.Xna.Framework.Matrix)">inverse</see> of the camera matrix</remarks>
            <param name="matrix"></param>
            <param name="changeIndex"></param>
            <returns>true if the matrix has changed</returns>
        </member>
        <member name="M:Xen.Camera.ICamera.GetCameraPosition(Microsoft.Xna.Framework.Vector3@)">
            <summary>
            Gets the current position of the camera
            </summary>
            <param name="viewPoint"></param>
        </member>
        <member name="M:Xen.Camera.ICamera.GetCameraViewDirection(Microsoft.Xna.Framework.Vector3@)">
            <summary>
            Gets the normalised view direction of the camera
            </summary>
            <param name="viewDirection"></param>
        </member>
        <member name="M:Xen.Camera.ICamera.GetCameraPosition(Microsoft.Xna.Framework.Vector4@,System.Int32@)">
            <summary>
            Gets the position of the camera as a vector4, returns if it has changed according to the changeIndex
            </summary>
        </member>
        <member name="M:Xen.Camera.ICamera.GetCameraViewDirection(Microsoft.Xna.Framework.Vector4@,System.Int32@)">
            <summary>
            Gets the normalised view direction of the camera as a vector4, returns if it has changed according to the changeIndex
            </summary>
        </member>
        <member name="M:Xen.Camera.ICamera.GetCameraNearFarClip(Microsoft.Xna.Framework.Vector2@)">
            <summary>
            Gets the near/far clip plane distances of the camera as a vector
            </summary>
            <param name="nearFarClip"></param>
        </member>
        <member name="M:Xen.Camera.ICamera.GetCameraNearFarClip(Microsoft.Xna.Framework.Vector4@,System.Int32@)">
            <summary>
            Gets the near/far clip plane distances of the camera as a vector4, returns if it has changed according to the changeIndex
            </summary>
        </member>
        <member name="M:Xen.Camera.ICamera.GetCameraHorizontalVerticalFov(Microsoft.Xna.Framework.Vector2@)">
            <summary>
            Gets the horizontal/vertical field of view of the camera as a vector
            </summary>
            <param name="hvFov"></param>
        </member>
        <member name="M:Xen.Camera.ICamera.GetCameraHorizontalVerticalFov(Microsoft.Xna.Framework.Vector4@,System.Int32@)">
            <summary>
            Gets the horizontal/vertical field of view of the camera as a vector4, returning if it has changed according to the changeIndex
            </summary>
        </member>
        <member name="M:Xen.Camera.ICamera.GetCameraHorizontalVerticalFovTangent(Microsoft.Xna.Framework.Vector2@)">
            <summary>
            Gets the tangent of the horizontal/vertical field of view of the camera as a vector
            </summary>
        </member>
        <member name="M:Xen.Camera.ICamera.GetCameraHorizontalVerticalFovTangent(Microsoft.Xna.Framework.Vector4@,System.Int32@)">
            <summary>
            Gets the tangent of the horizontal/vertical field of view of the camera as a vector4, returning if it has changed according to the changeIndex
            </summary>
            <param name="changeIndex"></param>
            <param name="hvFovTan"></param>
        </member>
        <member name="M:Xen.Camera.ICamera.GetCullingPlanes">
            <summary>
            Get the culling planes for this camera
            </summary>
            <returns></returns>
        </member>
        <member name="M:Xen.Camera.ICamera.GetCullingPlanes(System.Int32@)">
            <summary>
            Get the culling planes for this camera
            </summary>
        </member>
        <member name="M:Xen.Camera.ICamera.ProjectToTarget(Microsoft.Xna.Framework.Vector3@,Microsoft.Xna.Framework.Vector2@,Xen.Graphics.DrawTarget)">
            <summary>
            <para>Projects a position in 3D space into draw target pixel coordinates</para>
            <para>Returns false if the projected point is behind the camera</para>
            </summary>
            <param name="position">3D world space position to project into draw target coordinates</param>
            <param name="coordinate">Draw target coordinates of the projected position</param>
            <returns>True if the projected position is in front of the camera</returns>
            <param name="target">Draw Target space to project the point onto</param>
        </member>
        <member name="M:Xen.Camera.ICamera.ProjectFromTarget(Microsoft.Xna.Framework.Vector2@,System.Single,Microsoft.Xna.Framework.Vector3@,Xen.Graphics.DrawTarget)">
            <summary>
            <para>Projects a position in draw target pixel coordinates into a 3D position in world space, based on a projection depth</para>
            <para>NOTE: For 3D Cameras this method is expensive! Where possible use <see cref="M:Xen.Graphics.Stack.CameraStack.ProjectFromTarget(Microsoft.Xna.Framework.Vector2@,System.Single,Microsoft.Xna.Framework.Vector3@)"/> in <see cref="P:Xen.DrawState.Camera"/></para>
            </summary>
            <param name="coordinate">Coordinate in draw target pixels to project into world space</param>
            <param name="projectDepth">World space depth to project from the camera position</param>
            <param name="position">projected position</param>
            <param name="target">Draw Target space to unproject the point from</param>
        </member>
        <member name="M:Xen.Camera.ICamera.ProjectToCoordinate(Microsoft.Xna.Framework.Vector3@,Microsoft.Xna.Framework.Vector2@)">
            <summary>
            <para>Projects a position in 3D space into [-1,+1] projected coordinates</para>
            <para>[-1,+1] Coordinates are equivalent of the size of a DrawTarget, where (-1,-1) is bottom left, (1,1) is top right and (0,0) is centered</para>
            <para>Returns false if the projected point is behind the camera</para>
            </summary>
            <param name="position">3D world space position to project into [-1,+1] projected coordinates</param>
            <param name="coordinate">[-1,+1] coordinates of the projected position</param>
            <returns>True if the projected position is in front of the camera</returns>
        </member>
        <member name="M:Xen.Camera.ICamera.ProjectFromCoordinate(Microsoft.Xna.Framework.Vector2@,System.Single,Microsoft.Xna.Framework.Vector3@)">
            <summary>
            <para>Projects a position in [-1,+1] coordinates into a 3D position in world space, based on a projection depth</para>
            <para>[-1,+1] Coordinates are equivalent of the size of a DrawTarget, where (-1,-1) is bottom left, (1,1) is top right and (0,0) is centered</para>
            <para>NOTE: For 3D Cameras this method is expensive! Where possible use <see cref="M:Xen.Graphics.Stack.CameraStack.ProjectFromTarget(Microsoft.Xna.Framework.Vector2@,System.Single,Microsoft.Xna.Framework.Vector3@)"/> in <see cref="P:Xen.DrawState.Camera"/></para>
            </summary>
            <param name="coordinate">Coordinate in [-1,+1] to project into world space</param>
            <param name="projectDepth">World space depth to project from the camera position</param>
            <param name="position">unprojected position</param>
        </member>
        <member name="P:Xen.Camera.ICamera.ReverseBackfaceCulling">
            <summary>
            If true, the renderer will set the <see cref="P:Xen.Graphics.RasterState.CullMode"/> to the opposite value (unless set to None).
            </summary>
        </member>
        <member name="M:Xen.Camera.Camera2D.#ctor">
            <summary></summary>
        </member>
        <member name="M:Xen.Camera.Camera2D.#ctor(System.Boolean)">
            <summary>
            </summary>
            <param name="useNormalisedCoordinates">see <see cref="P:Xen.Camera.Camera2D.UseNormalisedCoordinates"/></param>
        </member>
        <member name="M:Xen.Camera.Camera2D.GetCullingPlanes">
            <summary>
            Get the culling planes for this camera
            </summary>
            <returns></returns>
        </member>
        <member name="M:Xen.Camera.Camera2D.GetCullingPlanes(System.Int32@)">
            <summary>
            Get the culling planes for this camera
            </summary>
        </member>
        <member name="M:Xen.Camera.Camera2D.GetView(Microsoft.Xna.Framework.Vector2@,Microsoft.Xna.Framework.Vector2@)">
            <summary>
            Overridable, get the size of the view window. Call <see cref="M:Xen.Camera.Camera2D.SetDirty"/> to have this method recalled
            </summary>
            <param name="bottomLeft"></param>
            <param name="topRight"></param>
        </member>
        <member name="M:Xen.Camera.Camera2D.SetDirty">
            <summary>
            Call this method to dirty the internal state of the camera/view matrices
            </summary>
        </member>
        <member name="M:Xen.Camera.Camera2D.GetCameraMatrix(Microsoft.Xna.Framework.Matrix@)">
            <summary>
            Gets the current camera matrix
            </summary>
            <param name="matrix"></param>
        </member>
        <member name="M:Xen.Camera.Camera2D.GetCameraPosition(Microsoft.Xna.Framework.Vector3@)">
            <summary>
            Get the position of the camera
            </summary>
            <param name="viewPoint"></param>
        </member>
        <member name="M:Xen.Camera.Camera2D.GetCameraViewDirection(Microsoft.Xna.Framework.Vector3@)">
            <summary>
            Get the normalised view direction of the camera
            </summary>
            <param name="viewDirection"></param>
        </member>
        <member name="M:Xen.Camera.Camera2D.ProjectToTarget(Microsoft.Xna.Framework.Vector3@,Microsoft.Xna.Framework.Vector2@,Xen.Graphics.DrawTarget)">
            <summary>
            <para>Projects a position in 3D space into draw target pixel coordinates</para>
            <para>Returns false if the projected point is behind the camera</para>
            </summary>
            <param name="position">3D world space position to project into draw target coordinates</param>
            <param name="coordinate">draw target coordinates of the projected position</param>
            <returns>True if the projected position is in front of the camera</returns>
            <param name="target">Draw Target space to project the point onto</param>
        </member>
        <member name="M:Xen.Camera.Camera2D.ProjectFromTarget(Microsoft.Xna.Framework.Vector2@,System.Single,Microsoft.Xna.Framework.Vector3@,Xen.Graphics.DrawTarget)">
            <summary>
            Projects a position in draw target pixel coordinates into a 3D position in world space, based on a projection depth
            </summary>
            <param name="coordinate">Coordinate in draw target pixels to project into world space</param>
            <param name="projectDepth">World space depth to project from the camera position</param>
            <param name="position">projected position</param>
            <param name="target">Draw Target space to unproject the point from</param>
        </member>
        <member name="M:Xen.Camera.Camera2D.ProjectToCoordinate(Microsoft.Xna.Framework.Vector3@,Microsoft.Xna.Framework.Vector2@)">
            <summary>
            <para>Projects a position in 3D space into [-1,+1] projected coordinates</para>
            <para>[-1,+1] Coordinates are equivalent of the size of a DrawTarget, where (-1,-1) is bottom left, (1,1) is top right and (0,0) is centered</para>
            <para>Returns false if the projected point is behind the camera</para>
            </summary>
            <param name="position">3D world space position to project into [-1,+1] projected coordinates</param>
            <param name="coordinate">[-1,+1] coordinates of the projected position</param>
            <returns>True if the projected position is in front of the camera</returns>
        </member>
        <member name="M:Xen.Camera.Camera2D.ProjectFromCoordinate(Microsoft.Xna.Framework.Vector2@,System.Single,Microsoft.Xna.Framework.Vector3@)">
            <summary>
            <para>Projects a position in [-1,+1] coordinates into a 3D position in world space, based on a projection depth</para>
            <para>[-1,+1] Coordinates are equivalent of the size of a DrawTarget, where (-1,-1) is bottom left, (1,1) is top right and (0,0) is centered</para>
            </summary>
            <param name="coordinate">Coordinate in [-1,+1] to project into world space</param>
            <param name="projectDepth">World space depth to project from the camera position</param>
            <param name="position">unprojected position</param>
        </member>
        <member name="P:Xen.Camera.Camera2D.ReverseBackfaceCulling">
            <summary>
            If true, the renderer will set the <see cref="P:Xen.Graphics.RasterState.CullMode"/> to the opposite value (unless set to None).
            </summary>
        </member>
        <member name="P:Xen.Camera.Camera2D.CameraMatrix">
            <summary>
            Get the matrix for this camera (<see cref="M:Xen.Camera.Camera2D.GetCameraMatrix(Microsoft.Xna.Framework.Matrix@)"/> is the preferred method to use)
            </summary>
        </member>
        <member name="P:Xen.Camera.Camera2D.UseNormalisedCoordinates">
            <summary>
            <para>When true, the bottom left corner is 0,0, the top right is 1,1.</para>
            <para>When false, the bottom left corner is 0,0 and the top right is the Width/Height of the render target</para>
            </summary>
        </member>
        <member name="T:Xen.Graphics.Stack.MatrixSource">
            <summary>
            Internal source tracking class for matrix storage
            </summary>
        </member>
        <member name="M:Xen.Graphics.Stack.MatrixSource.UpdateMultiply">
            <summary>
            Empty in the base class, only used by the Effect mapper
            </summary>
        </member>
        <member name="M:Xen.Graphics.Stack.MatrixSource.GetMatrix(Microsoft.Xna.Framework.Matrix@)">
            <summary>
            Get the Matrix
            </summary>
        </member>
        <member name="M:Xen.Graphics.Stack.MatrixSource.GetTransposeMatrix(Microsoft.Xna.Framework.Matrix@)">
            <summary>
            Get the transpose of the Matrix
            </summary>
        </member>
        <member name="M:Xen.Graphics.Stack.MatrixSource.GetInverseMatrix(Microsoft.Xna.Framework.Matrix@)">
            <summary>
            Get the inverse of the Matrix
            </summary>
        </member>
        <member name="T:Xen.Graphics.Stack.WorldMatrixStackProvider">
            <summary>
            Provider class for storing a stack for the rendering World Matrix
            </summary>
        </member>
        <member name="M:Xen.Graphics.Stack.WorldMatrixStackProvider.op_Addition(Xen.Graphics.Stack.WorldMatrixStackProvider,Microsoft.Xna.Framework.Matrix)">
            <summary>
            Wrapper on the Push method
            </summary>
        </member>
        <member name="M:Xen.Graphics.Stack.WorldMatrixStackProvider.op_Multiply(Xen.Graphics.Stack.WorldMatrixStackProvider,Microsoft.Xna.Framework.Matrix)">
            <summary>
            Wrapper on the PushMultiply method
            </summary>
        </member>
        <member name="M:Xen.Graphics.Stack.WorldMatrixStackProvider.op_Addition(Xen.Graphics.Stack.WorldMatrixStackProvider,Microsoft.Xna.Framework.Vector3)">
            <summary>
            Wrapper on the Push method
            </summary>
        </member>
        <member name="M:Xen.Graphics.Stack.WorldMatrixStackProvider.op_Multiply(Xen.Graphics.Stack.WorldMatrixStackProvider,Microsoft.Xna.Framework.Vector3)">
            <summary>
            Wrapper on the PushMultiply method
            </summary>
        </member>
        <member name="M:Xen.Graphics.Stack.WorldMatrixStackProvider.op_Implicit(Xen.Graphics.Stack.WorldMatrixStackProvider)~Microsoft.Xna.Framework.Matrix">
            <summary>
            Cast to a <see cref="T:Microsoft.Xna.Framework.Matrix"/> implicitly
            </summary>
        </member>
        <member name="M:Xen.Graphics.Stack.WorldMatrixStackProvider.SetMatrix(Microsoft.Xna.Framework.Matrix@)">
            <summary>
            Sets the top of the current rendering world matrix stack to the matrix
            </summary>
        </member>
        <member name="M:Xen.Graphics.Stack.WorldMatrixStackProvider.SetTranslate(Microsoft.Xna.Framework.Vector3@)">
            <summary>
            Sets the top of the current rendering world matrix stack to the position
            </summary>
        </member>
        <member name="M:Xen.Graphics.Stack.WorldMatrixStackProvider.GetMatrix(Microsoft.Xna.Framework.Matrix@)">
            <summary>
            Gets the top of the current rendering world matrix stack
            </summary>
        </member>
        <member name="M:Xen.Graphics.Stack.WorldMatrixStackProvider.GetMatrix(Microsoft.Xna.Framework.Matrix@,System.Boolean@)">
            <summary>
            Gets the current world matrix at the top of the world matrix stack
            </summary>
            <param name="matrix"></param>
            <param name="isIdentity">true if the matrix is guaranteed to be an identity matrix (this value may return a false negative)</param>
        </member>
        <member name="M:Xen.Graphics.Stack.WorldMatrixStackProvider.GetPosition(Microsoft.Xna.Framework.Vector3@)">
            <summary>
            Gets the translation position stored in the current world matrix
            </summary>
            <param name="position"></param>
        </member>
        <member name="M:Xen.Graphics.Stack.WorldMatrixStackProvider.Push(Microsoft.Xna.Framework.Matrix@)">
            <summary>
            Pushes the matrix on to the top of the current rendering world matrix stack
            <para>Note: this method can be used in a 'using() {}' block to automatically call <see cref="M:Xen.Graphics.Stack.WorldMatrixStackProvider.Pop"/></para>
            </summary>
        </member>
        <member name="M:Xen.Graphics.Stack.WorldMatrixStackProvider.PushIdentity">
            <summary>
            Pushes an identity matrix to the top of the stack
            <para>Note: this method can be used in a 'using() {}' block to automatically call <see cref="M:Xen.Graphics.Stack.WorldMatrixStackProvider.Pop"/></para>
            </summary>
        </member>
        <member name="M:Xen.Graphics.Stack.WorldMatrixStackProvider.Push">
            <summary>
            Copies the current world matrix to the top of the stack
            <para>Note: this method can be used in a 'using() {}' block to automatically call <see cref="M:Xen.Graphics.Stack.WorldMatrixStackProvider.Pop"/></para>
            </summary>
        </member>
        <member name="M:Xen.Graphics.Stack.WorldMatrixStackProvider.PushTranslate(Microsoft.Xna.Framework.Vector3@)">
            <summary>
            Optimised equivalent of calling <see cref="M:Xen.Graphics.Stack.WorldMatrixStackProvider.Push(Microsoft.Xna.Framework.Matrix@)"/>(<see cref="M:Microsoft.Xna.Framework.Matrix.CreateTranslation(Microsoft.Xna.Framework.Vector3)"/>)
            <para>Note: this method can be used in a 'using() {}' block to automatically call <see cref="M:Xen.Graphics.Stack.WorldMatrixStackProvider.Pop"/></para>
            </summary>
        </member>
        <member name="M:Xen.Graphics.Stack.WorldMatrixStackProvider.PushTranslate(Microsoft.Xna.Framework.Vector3)">
            <summary>
            Optimised equivalent of calling <see cref="M:Xen.Graphics.Stack.WorldMatrixStackProvider.Push(Microsoft.Xna.Framework.Matrix@)"/>(<see cref="M:Microsoft.Xna.Framework.Matrix.CreateTranslation(Microsoft.Xna.Framework.Vector3)"/>)
            <para>Note: this method can be used in a 'using() {}' block to automatically call <see cref="M:Xen.Graphics.Stack.WorldMatrixStackProvider.Pop"/></para>
            </summary>
        </member>
        <member name="M:Xen.Graphics.Stack.WorldMatrixStackProvider.PushTranslateMultiply(Microsoft.Xna.Framework.Vector3@)">
            <summary>
            Optimised equivalent of calling <see cref="M:Xen.Graphics.Stack.WorldMatrixStackProvider.PushMultiply(Microsoft.Xna.Framework.Matrix@)"/>(<see cref="M:Microsoft.Xna.Framework.Matrix.CreateTranslation(Microsoft.Xna.Framework.Vector3)"/>)
            <para>Note: this method can be used in a 'using() {}' block to automatically call <see cref="M:Xen.Graphics.Stack.WorldMatrixStackProvider.Pop"/></para>
            </summary>
        </member>
        <member name="M:Xen.Graphics.Stack.WorldMatrixStackProvider.PushTranslateMultiply(Microsoft.Xna.Framework.Vector3)">
            <summary>
            Optimised equivalent of calling <see cref="M:Xen.Graphics.Stack.WorldMatrixStackProvider.PushMultiply(Microsoft.Xna.Framework.Matrix@)"/>(<see cref="M:Microsoft.Xna.Framework.Matrix.CreateTranslation(Microsoft.Xna.Framework.Vector3)"/>)
            <para>Note: this method can be used in a 'using() {}' block to automatically call <see cref="M:Xen.Graphics.Stack.WorldMatrixStackProvider.Pop"/></para>
            </summary>
        </member>
        <member name="M:Xen.Graphics.Stack.WorldMatrixStackProvider.HasChanged(System.Int32@)">
            <summary>
            Returns true if the world matrix has changed compared to the passed in change index
            </summary>
        </member>
        <member name="M:Xen.Graphics.Stack.WorldMatrixStackProvider.Push(Xen.Transform@)">
            <summary>
            Pushes the transform on to the top of the current rendering world matrix stack
            <para>Note: this method can be used in a 'using() {}' block to automatically call <see cref="M:Xen.Graphics.Stack.WorldMatrixStackProvider.Pop"/></para>
            </summary>
        </member>
        <member name="M:Xen.Graphics.Stack.WorldMatrixStackProvider.PushMultiply(Xen.Transform@)">
            <summary>
            Pushes the transform on to the top of the current rendering world matrix stack, multiplying with the existing world matrix.
            <para>Note: this method can be used in a 'using() {}' block to automatically call <see cref="M:Xen.Graphics.Stack.WorldMatrixStackProvider.Pop"/></para>
            </summary>
        </member>
        <member name="M:Xen.Graphics.Stack.WorldMatrixStackProvider.Multiply(Xen.Transform@)">
            <summary>
            Multiplies the matrix at the top of the rendering world matrix stack with the input transform
            </summary>
        </member>
        <member name="M:Xen.Graphics.Stack.WorldMatrixStackProvider.PushMultiply(Microsoft.Xna.Framework.Matrix@)">
            <summary>
            Pushes the matrix on to the top of the current rendering world matrix stack, multiplying with the  existing world matrix.
            <para>Note: this method can be used in a 'using() {}' block to automatically call <see cref="M:Xen.Graphics.Stack.WorldMatrixStackProvider.Pop"/></para>
            </summary>
        </member>
        <member name="M:Xen.Graphics.Stack.WorldMatrixStackProvider.Multiply(Microsoft.Xna.Framework.Matrix@)">
            <summary>
            Multiplies the matrix at the top of the rendering world matrix stack with the input matrix
            </summary>
        </member>
        <member name="M:Xen.Graphics.Stack.WorldMatrixStackProvider.Pop">
            <summary>
            Pops the top of the rendering world matrix stack, Restoring the matrix saved with <see cref="M:Xen.Graphics.Stack.WorldMatrixStackProvider.Push(Microsoft.Xna.Framework.Matrix@)"/>
            </summary>
        </member>
        <member name="M:Xen.Graphics.Stack.WorldMatrixStackProvider.GetTransposeMatrix(Microsoft.Xna.Framework.Matrix@)">
            <summary>
            Gets the transpose of the matrix
            </summary>
        </member>
        <member name="M:Xen.Graphics.Stack.WorldMatrixStackProvider.GetInverseMatrix(Microsoft.Xna.Framework.Matrix@)">
            <summary>
            Gets the inverse of the matrix
            </summary>
        </member>
        <member name="P:Xen.Graphics.Stack.WorldMatrixStackProvider.Position">
            <summary>
            <para>Gets/Sets the position of the current rendering world matrix</para>
            <para>Note: Rotation is not modified when assinging this value</para>
            </summary>
        </member>
        <member name="T:Xen.Graphics.Stack.WorldMatrixStackProvider.UsingPop">
            <summary>
            Structure used for a using block with a Push method
            </summary>
        </member>
        <member name="M:Xen.Graphics.Stack.WorldMatrixStackProvider.UsingPop.Dispose">
            <summary>Invokes the Pop metohd</summary>
        </member>
        <member name="M:Xen.Graphics.Stack.MatrixMultiply.op_Implicit(Xen.Graphics.Stack.MatrixMultiply)~Microsoft.Xna.Framework.Matrix">
            <summary>
            Cast to a <see cref="T:Microsoft.Xna.Framework.Matrix"/> implicitly
            </summary>
        </member>
        <member name="T:Xen.Graphics.PreferredMultiSampleLevel">
            <summary>
            The desired multisample antialiasing level
            </summary>
        </member>
        <member name="F:Xen.Graphics.PreferredMultiSampleLevel.None">
            <summary></summary>
        </member>
        <member name="F:Xen.Graphics.PreferredMultiSampleLevel.TwoSamples">
            <summary></summary>
        </member>
        <member name="F:Xen.Graphics.PreferredMultiSampleLevel.FourSamples">
            <summary></summary>
        </member>
        <member name="T:Xen.Graphics.DrawTarget">
            <summary>
            Abstract base class for a Draw object that renders a list of drawable items to the screen or a render target
            </summary>
        </member>
        <member name="T:Xen.Graphics.Resource">
            <summary>
            Base class for all implemented objects that use graphics resources
            </summary>
        </member>
        <member name="M:Xen.Graphics.Resource.#ctor">
            <summary></summary>
        </member>
        <member name="M:Xen.Graphics.Resource.EnableReleaseResourceTracking">
            <summary>
            Call this to enable resource tracking (Note: Resource Tracking is always on in DEBUG builds)
            </summary>
            <remarks>This method must be called before or during constructing the application instance</remarks>
        </member>
        <member name="M:Xen.Graphics.Resource.EnableReleaseResourceTracking(System.Boolean)">
            <summary>
            Call this to enable resource tracking (Note: Resource Tracking is always on in DEBUG builds)
            </summary>
            <remarks>This method must be called before or during constructing the application instance</remarks>
            <param name="throwOnError"></param>
        </member>
        <member name="M:Xen.Graphics.Resource.CountDisposedResourcesStillAlive">
            <summary>
            Returns the number of resource objects that are still being referenced
            </summary>
            <returns></returns>
        </member>
        <member name="M:Xen.Graphics.Resource.CountDisposedResourcesStillAlive(Xen.Graphics.Resource.ResourceType)">
            <summary>
            Returns the number of resource objects that are still being referenced
            </summary>
            <returns></returns>
        </member>
        <member name="M:Xen.Graphics.Resource.CountResourcesNotUsedByDevice">
            <summary>
            Returns the number of resources that are yet to be used
            </summary>
            <returns></returns>
        </member>
        <member name="M:Xen.Graphics.Resource.CountResourcesNotUsedByDevice(Xen.Graphics.Resource.ResourceType)">
            <summary>
            Returns the number of resources that are yet to be used
            </summary>
            <returns></returns>
        </member>
        <member name="M:Xen.Graphics.Resource.GetAllAllocatedManagedBytes">
            <summary>
            Gets approximate allocation size in managed memory for all resources
            </summary>
            <returns></returns>
        </member>
        <member name="M:Xen.Graphics.Resource.GetAllAllocatedDeviceBytes">
            <summary>
            Gets approximate allocation size in graphics memory for all resources
            </summary>
            <returns></returns>
        </member>
        <member name="M:Xen.Graphics.Resource.GetAllAllocatedManagedBytes(Xen.Graphics.Resource.ResourceType)">
            <summary>
            Gets approximate allocation size in managed memory for all resources of a specific type
            </summary>
            <returns></returns>
            <param name="filter"></param>
        </member>
        <member name="M:Xen.Graphics.Resource.GetAllAllocatedDeviceBytes(Xen.Graphics.Resource.ResourceType)">
            <summary>
            Gets approximate allocation size in graphics memory for all resources of a specific type
            </summary>
            <returns></returns>
            <param name="filter"></param>
        </member>
        <member name="M:Xen.Graphics.Resource.GetResourceCountByType(System.Collections.Generic.IDictionary{System.Type,System.Int32})">
            <summary>
            Fills a dictionay with the count of each resource type
            </summary>
            <returns></returns>
        </member>
        <member name="M:Xen.Graphics.Resource.GetResourceCount">
            <summary>
            Gets the number of resources tracked
            </summary>
            <returns></returns>
        </member>
        <member name="M:Xen.Graphics.Resource.GetResourceCount(Xen.Graphics.Resource.ResourceType)">
            <summary>
            Gets the number of resources tracked
            </summary>
            <returns></returns>
        </member>
        <member name="M:Xen.Graphics.Resource.Warm(Xen.IState)">
            <summary>
            Preload (warm) the resource before its first use
            </summary>
            <param name="state"></param>
        </member>
        <member name="M:Xen.Graphics.Resource.Warm(Xen.Application)">
            <summary>
            Preload (warm) the resource before its first use
            </summary>
            <param name="application"></param>
        </member>
        <member name="T:Xen.Graphics.Resource.ResourceType">
            <summary></summary>
        </member>
        <member name="F:Xen.Graphics.Resource.ResourceType.All">
            <summary></summary>
        </member>
        <member name="F:Xen.Graphics.Resource.ResourceType.RenderTarget">
            <summary></summary>
        </member>
        <member name="F:Xen.Graphics.Resource.ResourceType.VertexBuffer">
            <summary></summary>
        </member>
        <member name="F:Xen.Graphics.Resource.ResourceType.IndexBuffer">
            <summary></summary>
        </member>
        <member name="T:Xen.IFrameDraw">
            <summary>
            Interface to an object that can be drawn at the frame level.
            </summary>
        </member>
        <member name="M:Xen.IFrameDraw.Draw(Xen.FrameState)">
            <summary>
            Draw the object
            </summary>
            <param name="state">Current state of the application</param>
        </member>
        <member name="M:Xen.Graphics.DrawTarget.Add(Xen.IDraw)">
            <summary>
            Adds a drawable item to the list of items to be drawn to the draw target
            </summary>
            <param name="drawable"></param>
        </member>
        <member name="M:Xen.Graphics.DrawTarget.Add(Microsoft.Xna.Framework.DrawableGameComponent,Xen.Application)">
            <summary>
            <para>Adds an Xna DrawableGameComponent to the list of items to be drawn to the draw target</para>
            <para>The component will also be initalised and added to the Applications Xna GameComponent update list</para>
            <para>Note: The DrawableGameComponent must not modify the current render target!</para>
            </summary>
        </member>
        <member name="M:Xen.Graphics.DrawTarget.Insert(System.Int32,Xen.IDraw)">
            <summary>
            Adds a drawable item into the list of items to be drawn to the draw target
            </summary>
            <param name="index"></param>
            <param name="drawable"></param>
        </member>
        <member name="M:Xen.Graphics.DrawTarget.Insert(System.Int32,Microsoft.Xna.Framework.DrawableGameComponent,Xen.Application)">
            <summary>
            <para>Adds an Xna DrawableGameComponent to the list of items to be drawn to the draw target</para>
            <para>The component will also be initalised and added to the Applications Xna GameComponent update list</para>
            <para>Note: The DrawableGameComponent must not modify the current render target!</para>
            </summary>
        </member>
        <member name="M:Xen.Graphics.DrawTarget.Remove(Xen.IDraw)">
            <summary>
            Removes a drawable item from the list of items to be drawn to the draw target
            </summary>
            <param name="drawable"></param>
            <returns>true if the item was removed</returns>
        </member>
        <member name="M:Xen.Graphics.DrawTarget.Remove(Microsoft.Xna.Framework.DrawableGameComponent)">
            <summary>
            <para>Removes an Xna DrawableGameComponent item from the list of items to be drawn to the draw target</para>
            <para>Note: The component will not be disposed or removed from the Applications Xna GameComponent update list</para>
            </summary>
            <returns>true if the item was removed</returns>
        </member>
        <member name="M:Xen.Graphics.DrawTarget.AddModifier(Xen.IBeginEndDraw)">
            <summary>
            Adds a begin/end drawing modified (such as a viewport modified) to the list of modifiers to be used while the draw target is being drawn
            </summary>
            <param name="modifier"></param>
        </member>
        <member name="M:Xen.Graphics.DrawTarget.InsertModifier(System.Int32,Xen.IBeginEndDraw)">
            <summary>
            Adds a begin/end drawing modified (such as a clear buffer modified) into the list of modifiers to be used while the draw target is being drawn
            </summary>
            <param name="modifier"></param>
            <param name="index"></param>
        </member>
        <member name="M:Xen.Graphics.DrawTarget.RemoveModifier(Xen.IBeginEndDraw)">
            <summary>
            Removes a begin/end drawing modified (such as a clear buffer modified) from the list of modifiers that is used while the draw target is being drawn
            </summary>
            <param name="modifier"></param>
        </member>
        <member name="M:Xen.Graphics.DrawTarget.GetEnabled">
            <summary></summary>
            <returns></returns>
        </member>
        <member name="M:Xen.Graphics.DrawTarget.FormatSize(Microsoft.Xna.Framework.Graphics.SurfaceFormat)">
            <summary>
            Gets the byte size of a render target format
            </summary>
            <param name="format"></param>
            <returns></returns>
        </member>
        <member name="M:Xen.Graphics.DrawTarget.FormatChannels(Microsoft.Xna.Framework.Graphics.SurfaceFormat)">
            <summary>
            Gets the number of channels used by a render target format
            </summary>
            <param name="format"></param>
            <returns></returns>
        </member>
        <member name="M:Xen.Graphics.DrawTarget.Draw(Xen.FrameState)">
            <summary>
            Perform all drawing to this draw target. All modifiers will be applied, and all drawable items in draw list will be drawn to the draw target
            </summary>
            <param name="state"></param>
        </member>
        <member name="M:Xen.Graphics.DrawTarget.Begin(Xen.DrawState)">
            <summary></summary>
            <param name="state"></param>
        </member>
        <member name="M:Xen.Graphics.DrawTarget.End(Xen.DrawState)">
            <summary></summary>
            <param name="state"></param>
        </member>
        <member name="M:Xen.Graphics.DrawTarget.GetWidthHeightAsVector(Microsoft.Xna.Framework.Vector4@,System.Int32@)">
            <summary></summary>
        </member>
        <member name="P:Xen.Graphics.DrawTarget.ClearBuffer">
            <summary>
            Gets/Changes the clear operations performed when the draw target is drawn
            </summary>
        </member>
        <member name="P:Xen.Graphics.DrawTarget.SurfaceFormat">
            <summary>
            Gets the surface format of the colour buffer for this draw target
            </summary>
        </member>
        <member name="P:Xen.Graphics.DrawTarget.SurfaceDepthFormat">
            <summary>
            <para>Gets the depth format of the depth buffer for this draw target</para>
            <para>If null, the target does not have a depth buffer</para>
            </summary>
        </member>
        <member name="P:Xen.Graphics.DrawTarget.MultiSampleType">
            <summary>
            Gets the multisample level of the draw target
            </summary>
        </member>
        <member name="P:Xen.Graphics.DrawTarget.Camera">
            <summary>
            Gets/Sets the camera used by this draw target
            </summary>
        </member>
        <member name="P:Xen.Graphics.DrawTarget.Enabled">
            <summary>
            Gets/Sets if this draw target is enabled (no drawing will occur when disabled)
            </summary>
        </member>
        <member name="P:Xen.Graphics.DrawTarget.HasDepthBuffer">
            <summary></summary>
        </member>
        <member name="P:Xen.Graphics.DrawTarget.HasStencilBuffer">
            <summary></summary>
        </member>
        <member name="P:Xen.Graphics.DrawTarget.Width">
            <summary>
            Gets the width of the draw target
            </summary>
        </member>
        <member name="P:Xen.Graphics.DrawTarget.Height">
            <summary>
            Gets the height of the draw target
            </summary>
        </member>
        <member name="P:Xen.Graphics.DrawTarget.Size">
            <summary>
            Gets the width/height of the draw target as a Vector2
            </summary>
        </member>
        <member name="T:Xen.Graphics.DrawTargetScreen">
            <summary>
            A draw target that draws directly to the screen
            </summary>
        </member>
        <member name="M:Xen.Graphics.DrawTargetScreen.#ctor(Xen.Camera.ICamera)">
            <summary>
            Construct the draw target
            </summary>
            <param name="camera"></param>
        </member>
        <member name="M:Xen.Graphics.DrawTargetScreen.Begin(Xen.DrawState)">
            <summary></summary>
            <param name="state"></param>
        </member>
        <member name="M:Xen.Graphics.DrawTargetScreen.End(Xen.DrawState)">
            <summary></summary>
            <param name="state"></param>
        </member>
        <member name="M:Xen.Graphics.DrawTargetScreen.GetWidthHeightAsVector(Microsoft.Xna.Framework.Vector4@,System.Int32@)">
            <summary></summary>
        </member>
        <member name="P:Xen.Graphics.DrawTargetScreen.SurfaceFormat">
            <summary>
            Gets the surface format of the colour buffer for the screen
            </summary>
        </member>
        <member name="P:Xen.Graphics.DrawTargetScreen.SurfaceDepthFormat">
            <summary>
            Gets the depth format of the depth buffer for the screen
            </summary>
        </member>
        <member name="P:Xen.Graphics.DrawTargetScreen.MultiSampleType">
            <summary>
            Gets the multisample level for this draw target
            </summary>
        </member>
        <member name="P:Xen.Graphics.DrawTargetScreen.Width">
            <summary>
            Gets the width of the screen
            </summary>
        </member>
        <member name="P:Xen.Graphics.DrawTargetScreen.Height">
            <summary>
            Gets the height of the screen
            </summary>
        </member>
        <member name="P:Xen.Graphics.DrawTargetScreen.Size">
            <summary>
            Gets the width/height of the draw target as a Vector2
            </summary>
        </member>
        <member name="P:Xen.Graphics.DrawTargetScreen.HasDepthBuffer">
            <summary></summary>
        </member>
        <member name="P:Xen.Graphics.DrawTargetScreen.HasStencilBuffer">
            <summary></summary>
        </member>
        <member name="T:Xen.Graphics.DrawTargetTexture2DGroup">
            <summary>
            Stores a list of <see cref="T:Xen.Graphics.DrawTargetTexture2D"/> as a group, for use with Multiple Render Target (MRT) support. See <see cref="P:Xen.Graphics.DrawTargetTexture2DGroup.MaxSimultaneousRenderTargets"/> for the maximum group size (usually 4)
            </summary>
            <remarks>
            <para>When using multiple render targets, each target must be the same byte size.</para>
            <para>Most hardware does not support blending with MRT</para>
            <para>The pixel shader being used must ouput a colour value for each render target being used</para>
            <para>For example, drawing to three render targets at once:</para>
            <code>
            void pixelShader(out float4 colour0 : COLOR0, out float4 colour1 : COLOR1, out float4 colour2 : COLOR2)
            {
            	colour0 = float4(...);
            	colour1 = float4(...);
            	colour2 = float4(...);
            	...
            }
            </code>
            </remarks>
        </member>
        <member name="M:Xen.Graphics.DrawTargetTexture2DGroup.#ctor(Xen.Camera.ICamera,Xen.Graphics.DrawTargetTexture2D[])">
            <summary>
            Construct the render target group
            </summary>
            <param name="camera"></param>
            <param name="targets"></param>
        </member>
        <member name="M:Xen.Graphics.DrawTargetTexture2DGroup.Clone(System.Boolean,System.Boolean)">
            <summary>
            Creates a clone of this draw target that shares the same rendering resources (no new resources are allocated)
            </summary>
            <param name="copyModifiers">copy modifier list into the clone</param>
            <param name="copyDrawList">copy draw list into the clone</param>
            <returns></returns>
        </member>
        <member name="M:Xen.Graphics.DrawTargetTexture2DGroup.GetTarget(System.Int32)">
            <summary>
            Get a draw target by index
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:Xen.Graphics.DrawTargetTexture2DGroup.Begin(Xen.DrawState)">
            <summary></summary>
            <param name="state"></param>
        </member>
        <member name="M:Xen.Graphics.DrawTargetTexture2DGroup.End(Xen.DrawState)">
            <summary></summary>
            <param name="state"></param>
        </member>
        <member name="M:Xen.Graphics.DrawTargetTexture2DGroup.GetWidthHeightAsVector(Microsoft.Xna.Framework.Vector4@,System.Int32@)">
            <summary></summary>
            <param name="size"></param>
            <param name="changeIndex"></param>
            <returns></returns>
        </member>
        <member name="P:Xen.Graphics.DrawTargetTexture2DGroup.Count">
            <summary>
            Gets the number of render targets stored in the group
            </summary>
        </member>
        <member name="P:Xen.Graphics.DrawTargetTexture2DGroup.SurfaceFormat">
            <summary>
            Gets the surface format of the first draw target in the group
            </summary>
        </member>
        <member name="P:Xen.Graphics.DrawTargetTexture2DGroup.SurfaceDepthFormat">
            <summary>
            <para>Gets the depth format of the depth buffer for this draw texture</para>
            </summary>
        </member>
        <member name="P:Xen.Graphics.DrawTargetTexture2DGroup.MultiSampleType">
            <summary>
            Gets the multisample level for the first draw target in the group
            </summary>
        </member>
        <member name="P:Xen.Graphics.DrawTargetTexture2DGroup.MaxSimultaneousRenderTargets">
            <summary>
            Gets the maximum group size supported by the hardware (usually 4 - the maximum value)
            </summary>
        </member>
        <member name="P:Xen.Graphics.DrawTargetTexture2DGroup.HasDepthBuffer">
            <summary></summary>
        </member>
        <member name="P:Xen.Graphics.DrawTargetTexture2DGroup.HasStencilBuffer">
            <summary></summary>
        </member>
        <member name="P:Xen.Graphics.DrawTargetTexture2DGroup.Width">
            <summary>
            Gets the width of the draw targets in the group
            </summary>
        </member>
        <member name="P:Xen.Graphics.DrawTargetTexture2DGroup.Height">
            <summary>
            Gets the height of the draw targets in the group
            </summary>
        </member>
        <member name="P:Xen.Graphics.DrawTargetTexture2DGroup.Size">
            <summary>
            Gets the width/height of the draw target as a Vector2
            </summary>
        </member>
        <member name="T:Xen.Graphics.DrawTargetTexture2D">
            <summary>
            A draw target that draws to a <see cref="T:Microsoft.Xna.Framework.Graphics.Texture2D"/> render target. 
            </summary>
            <remarks>
            <para>Most draw targets will create the render target resoures. Note these resoures are not created until either the first time the target is drawn, or <see cref="M:Xen.Graphics.Resource.Warm(Xen.IState)"/> is called.</para>
            <para>To share the resources used by a draw target texture, use <see cref="M:Xen.Graphics.DrawTargetTexture2D.Clone(System.Boolean,System.Boolean,System.Boolean)"/></para>
            <para>A draw target can be created from XNA render targets using <see cref="M:Xen.Graphics.DrawTargetTexture2D.CreateFromRenderTarget2D(Xen.Camera.ICamera,Microsoft.Xna.Framework.Graphics.RenderTarget2D)"/> (not recommended)</para>
            </remarks>
        </member>
        <member name="M:Xen.Graphics.DrawTargetTexture2D.GetRenderTarget2D">
            <summary>
            Gets the XNA render target created or shared by this draw texture. Note: Resources are not created until the first time the target is drawn or <see cref="M:Xen.Graphics.Resource.Warm(Xen.IState)"/> is called. Directly accessing this resource is not recommended
            </summary>
        </member>
        <member name="M:Xen.Graphics.DrawTargetTexture2D.Clone(System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Creates a clone of this draw target that shares the same rendering resources (no new resources are allocated)
            </summary>
            <param name="copyModifiers">copy modifier list into the clone</param>
            <param name="copyDrawList">copy draw list into the clone</param>
            <param name="retainDepth">cloned draw target should also retain the depth stencil buffer</param>
            <returns></returns>
        </member>
        <member name="M:Xen.Graphics.DrawTargetTexture2D.Equals(System.Object)">
            <summary>
            Returns true when comparing equivalent draw targets, including cloned targets
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:Xen.Graphics.DrawTargetTexture2D.GetHashCode">
            <summary></summary>
            <returns></returns>
        </member>
        <member name="M:Xen.Graphics.DrawTargetTexture2D.GetTexture">
            <summary>
            Gets the texture for this draw target. Returns NULL if the resource hasn't been created. NOTE: this texture will become invalid after a device reset (see <see cref="T:Xen.IContentOwner"/> for details)
            </summary>
            <remarks>Call <see cref="M:Xen.Graphics.DrawTargetTexture2D.GetTexture(Xen.IState)"/> to get the texture, creating the resource beforehand if required.</remarks>
            <returns>Texture for this draw target</returns>
        </member>
        <member name="M:Xen.Graphics.DrawTargetTexture2D.GetTexture(Xen.IState)">
            <summary>
            Gets the texture for this draw target, Warming the resource if required. NOTE: this texture will become invalid after a device reset (see <see cref="T:Xen.IContentOwner"/> for details)
            </summary>
            <returns>Texture for this draw target</returns>
        </member>
        <member name="M:Xen.Graphics.DrawTargetTexture2D.#ctor(Xen.Camera.ICamera,System.Int32,System.Int32,Microsoft.Xna.Framework.Graphics.SurfaceFormat,Microsoft.Xna.Framework.Graphics.DepthFormat)">
            <summary>
            Creates the draw texture. Note: Rendering resources will not be created until the first time the target is drawn or <see cref="M:Xen.Graphics.Resource.Warm(Xen.IState)"/> is called
            </summary>
            <param name="camera"></param>
            <param name="width"></param>
            <param name="height"></param>
            <param name="format"></param>
            <param name="depthFormat"></param>
        </member>
        <member name="M:Xen.Graphics.DrawTargetTexture2D.#ctor(Xen.Camera.ICamera,System.Int32,System.Int32,Microsoft.Xna.Framework.Graphics.SurfaceFormat,Microsoft.Xna.Framework.Graphics.DepthFormat,System.Boolean)">
            <summary>
            Creates the draw texture. Note: Rendering resources will not be created until the first time the target is drawn or <see cref="M:Xen.Graphics.Resource.Warm(Xen.IState)"/> is called
            </summary>
            <param name="camera"></param>
            <param name="width"></param>
            <param name="height"></param>
            <param name="format"></param>
            <param name="depthFormat"></param>
            <param name="mipmap"></param>
        </member>
        <member name="M:Xen.Graphics.DrawTargetTexture2D.#ctor(Xen.Camera.ICamera,System.Int32,System.Int32,Microsoft.Xna.Framework.Graphics.SurfaceFormat,Microsoft.Xna.Framework.Graphics.DepthFormat,System.Boolean,Xen.Graphics.PreferredMultiSampleLevel)">
            <summary>
            Creates the draw texture. Note: Rendering resources will not be created until the first time the target is drawn or <see cref="M:Xen.Graphics.Resource.Warm(Xen.IState)"/> is called
            </summary>
            <param name="camera"></param>
            <param name="width"></param>
            <param name="height"></param>
            <param name="format"></param>
            <param name="depthFormat"></param>
            <param name="mipmap"></param>
            <param name="multisample"></param>
        </member>
        <member name="M:Xen.Graphics.DrawTargetTexture2D.#ctor(Xen.Camera.ICamera,System.Int32,System.Int32,Microsoft.Xna.Framework.Graphics.SurfaceFormat,Microsoft.Xna.Framework.Graphics.DepthFormat,System.Boolean,Xen.Graphics.PreferredMultiSampleLevel,Microsoft.Xna.Framework.Graphics.RenderTargetUsage)">
            <summary>
            Creates the draw texture. Note: Rendering resources will not be created until the first time the target is drawn or <see cref="M:Xen.Graphics.Resource.Warm(Xen.IState)"/> is called
            </summary>
        </member>
        <member name="M:Xen.Graphics.DrawTargetTexture2D.CreateFromRenderTarget2D(Xen.Camera.ICamera,Microsoft.Xna.Framework.Graphics.RenderTarget2D)">
            <summary>
            Create a draw texture directly from an XNA render target (not recommended)
            </summary>
            <returns></returns>
        </member>
        <member name="M:Xen.Graphics.DrawTargetTexture2D.SupportsFormat(Microsoft.Xna.Framework.Graphics.SurfaceFormat@)">
            <summary>
            Returns true if the hardware supports the given colour buffer surface format
            </summary>
            <param name="format"></param>
            <returns></returns>
        </member>
        <member name="M:Xen.Graphics.DrawTargetTexture2D.SupportsFormatFiltering(Microsoft.Xna.Framework.Graphics.SurfaceFormat)">
            <summary>
            Returns true if a format is guarenteed to support texture filtering.
            <para>Note: XNA 4 no longer provides correct access, so this returns a lowest common demonimator</para>
            </summary>
            <param name="format"></param>
            <returns></returns>
        </member>
        <member name="M:Xen.Graphics.DrawTargetTexture2D.Dispose">
            <summary>
            Dispose the draw target and all resources used. If this render target is a clone, the shared resources are NOT disposed
            </summary>
        </member>
        <member name="M:Xen.Graphics.DrawTargetTexture2D.Begin(Xen.DrawState)">
            <summary></summary>
            <param name="state"></param>
        </member>
        <member name="M:Xen.Graphics.DrawTargetTexture2D.End(Xen.DrawState)">
            <summary></summary>
            <param name="state"></param>
        </member>
        <member name="M:Xen.Graphics.DrawTargetTexture2D.GetWidthHeightAsVector(Microsoft.Xna.Framework.Vector4@,System.Int32@)">
            <summary></summary>
        </member>
        <member name="P:Xen.Graphics.DrawTargetTexture2D.SurfaceFormat">
            <summary>
            Gets the surface format of the colour buffer for this draw texture
            </summary>
        </member>
        <member name="P:Xen.Graphics.DrawTargetTexture2D.SurfaceDepthFormat">
            <summary>
            <para>Gets the depth format of the depth buffer for this draw texture</para>
            <para>When this value is null, the target does not have a depth buffer</para>
            </summary>
        </member>
        <member name="P:Xen.Graphics.DrawTargetTexture2D.MultiSampleType">
            <summary>
            Gets the multisample level for this draw target
            </summary>
        </member>
        <member name="P:Xen.Graphics.DrawTargetTexture2D.Width">
            <summary>
            Gets the width of the draw target
            </summary>
        </member>
        <member name="P:Xen.Graphics.DrawTargetTexture2D.Height">
            <summary>
            Gets the height of the draw target
            </summary>
        </member>
        <member name="P:Xen.Graphics.DrawTargetTexture2D.Size">
            <summary>
            Gets the width/height of the draw target as a Vector2
            </summary>
        </member>
        <member name="P:Xen.Graphics.DrawTargetTexture2D.HasDepthBuffer">
            <summary></summary>
        </member>
        <member name="P:Xen.Graphics.DrawTargetTexture2D.HasStencilBuffer">
            <summary></summary>
        </member>
        <member name="T:Xen.Graphics.DrawTargetTextureCube">
            <summary>
            A draw target that draws to a <see cref="T:Microsoft.Xna.Framework.Graphics.TextureCube"/> render target. 
            </summary>
            <remarks>
            <para>Most draw targets will create the render target resoures. Note these resoures are not created until either the first time the target is drawn, or <see cref="M:Xen.Graphics.Resource.Warm(Xen.IState)"/> is called.</para>
            <para>To share the resources used by a draw target texture, use <see cref="M:Xen.Graphics.DrawTargetTextureCube.Clone(System.Boolean,System.Boolean)"/></para>
            <para>A draw target can be created from XNA render targets using <see cref="M:Xen.Graphics.DrawTargetTextureCube.CreateFromRenderTargetCube(Xen.Camera.ICamera,Microsoft.Xna.Framework.Graphics.RenderTargetCube)"/> (not recommended)</para>
            </remarks>
        </member>
        <member name="M:Xen.Graphics.DrawTargetTextureCube.GetFaceRenderEnabled(Microsoft.Xna.Framework.Graphics.CubeMapFace)">
            <summary>
            Gets if rendering to a cube face is enabled
            </summary>
            <param name="face"></param>
            <returns></returns>
        </member>
        <member name="M:Xen.Graphics.DrawTargetTextureCube.SetFaceRenderEnabled(Microsoft.Xna.Framework.Graphics.CubeMapFace,System.Boolean)">
            <summary>
            Set enabled/disabled rendering to a cubemap face
            </summary>
            <param name="face"></param>
            <param name="enabled"></param>
        </member>
        <member name="M:Xen.Graphics.DrawTargetTextureCube.Clone(System.Boolean,System.Boolean)">
            <summary>
            Creates a clone of this draw target that shares the same rendering resources (no new resources are allocated)
            </summary>
            <param name="copyModifiers">copy modifier list into the clone</param>
            <param name="copyDrawList">copy draw list into the clone</param>
            <returns></returns>
        </member>
        <member name="M:Xen.Graphics.DrawTargetTextureCube.Equals(System.Object)">
            <summary>
            Returns true when comparing equivalent draw targets, including cloned targets
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:Xen.Graphics.DrawTargetTextureCube.GetHashCode">
            <summary></summary>
            <returns></returns>
        </member>
        <member name="M:Xen.Graphics.DrawTargetTextureCube.GetEnabled">
            <summary></summary>
            <returns></returns>
        </member>
        <member name="M:Xen.Graphics.DrawTargetTextureCube.GetCubeMapFaceMatrix(Microsoft.Xna.Framework.Graphics.CubeMapFace,Microsoft.Xna.Framework.Matrix@)">
            <summary>
            Gets the matrix that represents the rotation of a cubemap face
            </summary>
            <param name="face"></param>
            <param name="matrix"></param>
        </member>
        <member name="M:Xen.Graphics.DrawTargetTextureCube.SupportsFormat(Microsoft.Xna.Framework.Graphics.SurfaceFormat@)">
            <summary>
            Returns true if the hardware supports the given colour buffer surface format
            </summary>
            <param name="format"></param>
            <returns></returns>
        </member>
        <member name="M:Xen.Graphics.DrawTargetTextureCube.GetRenderTargetCube">
            <summary>
            Gets the XNA render target created or shared by this draw cubemap. Note: Resources are not created until the first time the target is drawn or <see cref="M:Xen.Graphics.Resource.Warm(Xen.IState)"/> is called. Directly accessing this resource is not recommended
            </summary>
        </member>
        <member name="M:Xen.Graphics.DrawTargetTextureCube.GetTexture">
            <summary>
            Gets the texture for this draw target. Returns NULL if the resource hasn't been created. NOTE: this texture will become invalid after a device reset (see <see cref="T:Xen.IContentOwner"/> for details)
            </summary>
            <remarks>Call <see cref="M:Xen.Graphics.DrawTargetTextureCube.GetTexture(Xen.DrawState)"/> to get the texture, creating the resource beforehand if required.</remarks>
            <returns>Texture for this draw target</returns>
        </member>
        <member name="M:Xen.Graphics.DrawTargetTextureCube.GetTexture(Xen.DrawState)">
            <summary>
            Gets the texture for this draw target, Warming the resource if required. NOTE: this texture will become invalid after a device reset (see <see cref="T:Xen.IContentOwner"/> for details)
            </summary>
            <returns>Texture for this draw target</returns>
        </member>
        <member name="M:Xen.Graphics.DrawTargetTextureCube.#ctor(Xen.Camera.ICamera,System.Int32,Microsoft.Xna.Framework.Graphics.SurfaceFormat,Microsoft.Xna.Framework.Graphics.DepthFormat)">
            <summary>
            Creates the draw target cubemap. Note: Rendering resources will not be created until the first time the target is drawn or <see cref="M:Xen.Graphics.Resource.Warm(Xen.IState)"/> is called
            </summary>
            <param name="camera"></param>
            <param name="resolution"></param>
            <param name="format"></param>
            <param name="depthFormat"></param>
        </member>
        <member name="M:Xen.Graphics.DrawTargetTextureCube.#ctor(Xen.Camera.ICamera,System.Int32,Microsoft.Xna.Framework.Graphics.SurfaceFormat,Microsoft.Xna.Framework.Graphics.DepthFormat,System.Boolean)">
            <summary>
            Creates the draw target cubemap. Note: Rendering resources will not be created until the first time the target is drawn or <see cref="M:Xen.Graphics.Resource.Warm(Xen.IState)"/> is called
            </summary>
            <param name="camera"></param>
            <param name="resolution"></param>
            <param name="format"></param>
            <param name="depthFormat"></param>
            <param name="mipmap"></param>
        </member>
        <member name="M:Xen.Graphics.DrawTargetTextureCube.#ctor(Xen.Camera.ICamera,System.Int32,Microsoft.Xna.Framework.Graphics.SurfaceFormat,Microsoft.Xna.Framework.Graphics.DepthFormat,System.Boolean,Xen.Graphics.PreferredMultiSampleLevel)">
            <summary>
            Creates the draw target cubemap. Note: Rendering resources will not be created until the first time the target is drawn or <see cref="M:Xen.Graphics.Resource.Warm(Xen.IState)"/> is called
            </summary>
            <param name="camera"></param>
            <param name="resolution"></param>
            <param name="format"></param>
            <param name="depthFormat"></param>
            <param name="mipmap"></param>
            <param name="multisample"></param>
        </member>
        <member name="M:Xen.Graphics.DrawTargetTextureCube.#ctor(Xen.Camera.ICamera,System.Int32,Microsoft.Xna.Framework.Graphics.SurfaceFormat,System.Boolean,Xen.Graphics.PreferredMultiSampleLevel,Microsoft.Xna.Framework.Graphics.RenderTargetUsage)">
            <summary>
            Creates the draw target cubemap. Note: Rendering resources will not be created until the first time the target is drawn or <see cref="M:Xen.Graphics.Resource.Warm(Xen.IState)"/> is called
            </summary>
            <param name="camera"></param>
            <param name="resolution"></param>
            <param name="format"></param>
            <param name="mipmap"></param>
            <param name="multisample"></param>
            <param name="usage"></param>
        </member>
        <member name="M:Xen.Graphics.DrawTargetTextureCube.#ctor(Xen.Camera.ICamera,System.Int32,Microsoft.Xna.Framework.Graphics.SurfaceFormat,Microsoft.Xna.Framework.Graphics.DepthFormat,System.Boolean,Xen.Graphics.PreferredMultiSampleLevel,Microsoft.Xna.Framework.Graphics.RenderTargetUsage)">
            <summary>
            Creates the draw target cubemap. Note: Rendering resources will not be created until the first time the target is drawn or <see cref="M:Xen.Graphics.Resource.Warm(Xen.IState)"/> is called
            </summary>
        </member>
        <member name="M:Xen.Graphics.DrawTargetTextureCube.ShareDepthBuffer(Xen.Graphics.DrawTargetTextureCube)">
            <summary>
            Share the depth buffer created by this draw texture with another draw texture
            </summary>
            <param name="shareDepthTo"></param>
        </member>
        <member name="M:Xen.Graphics.DrawTargetTextureCube.CreateFromRenderTargetCube(Xen.Camera.ICamera,Microsoft.Xna.Framework.Graphics.RenderTargetCube)">
            <summary>
            Create a draw target cubemap directly from an XNA render target (not recommended)
            </summary>
            <param name="camera"></param>
            <param name="renderTexture"></param>
            <returns></returns>
        </member>
        <member name="M:Xen.Graphics.DrawTargetTextureCube.Dispose">
            <summary>
            Dispose the draw target and all resources used. If this render target is a clone, the shared resources are NOT disposed
            </summary>
        </member>
        <member name="M:Xen.Graphics.DrawTargetTextureCube.Begin(Xen.DrawState)">
            <summary></summary>
            <param name="state"></param>
        </member>
        <member name="M:Xen.Graphics.DrawTargetTextureCube.BeginRepeat(Xen.DrawState,System.Int32,Xen.Camera.ICamera@)">
            <summary></summary>
            <param name="state"></param>
            <param name="repeat"></param>
            <param name="camera"></param>
            <returns></returns>
        </member>
        <member name="M:Xen.Graphics.DrawTargetTextureCube.EndRepeat(Xen.DrawState,System.Int32)">
            <summary></summary>
            <param name="state"></param>
            <param name="repeat"></param>
        </member>
        <member name="M:Xen.Graphics.DrawTargetTextureCube.End(Xen.DrawState)">
            <summary></summary>
            <param name="state"></param>
        </member>
        <member name="M:Xen.Graphics.DrawTargetTextureCube.GetWidthHeightAsVector(Microsoft.Xna.Framework.Vector4@,System.Int32@)">
            <summary></summary>
        </member>
        <member name="P:Xen.Graphics.DrawTargetTextureCube.SurfaceFormat">
            <summary>
            Gets the surface format of the colour buffer for this draw cubemap
            </summary>
        </member>
        <member name="P:Xen.Graphics.DrawTargetTextureCube.SurfaceDepthFormat">
            <summary>
            <para>Gets the depth format of the depth buffer for this draw texture</para>
            <para>When this value is null, the target does not have a depth buffer</para>
            </summary>
        </member>
        <member name="P:Xen.Graphics.DrawTargetTextureCube.MultiSampleType">
            <summary>
            Gets the multisample level for this draw target
            </summary>
        </member>
        <member name="P:Xen.Graphics.DrawTargetTextureCube.Width">
            <summary>
            Gets the width of the draw target cubemap
            </summary>
        </member>
        <member name="P:Xen.Graphics.DrawTargetTextureCube.Height">
            <summary>
            Gets the width of the draw target cubemap
            </summary>
        </member>
        <member name="P:Xen.Graphics.DrawTargetTextureCube.Size">
            <summary>
            Gets the width/height of the draw target as a Vector2
            </summary>
        </member>
        <member name="P:Xen.Graphics.DrawTargetTextureCube.HasDepthBuffer">
            <summary></summary>
        </member>
        <member name="P:Xen.Graphics.DrawTargetTextureCube.HasStencilBuffer">
            <summary></summary>
        </member>
        <member name="T:Xen.GameComponentHost">
            <summary>
            An XNA Game Component hosts a Xen Application.
            </summary>
        </member>
        <member name="M:Xen.GameComponentHost.#ctor(Microsoft.Xna.Framework.Game,Xen.Application,Microsoft.Xna.Framework.GraphicsDeviceManager)">
            <summary>Construct the Xen GameComponent host</summary>
        </member>
        <member name="M:Xen.GameComponentHost.Initialize">
            <summary>
            Initialises the Xen Application
            </summary>
        </member>
        <member name="M:Xen.GameComponentHost.Update(Microsoft.Xna.Framework.GameTime)">
            <summary>
            Updates the Xen Application (if the game does not use FixedTimeSteps)
            </summary>
        </member>
        <member name="M:Xen.GameComponentHost.Draw(Microsoft.Xna.Framework.GameTime)">
            <summary>Updates the Xen Application (if the game uses fixed time steps) and then calls the application to draw</summary>
        </member>
        <member name="T:Xen.IXNAAppWrapper">
            <summary>
            Interface for an application wrapper (XNA Game application, or WinForms application)
            </summary>
        </member>
        <member name="T:Xen.Camera.Camera3D">
            <summary>
            Represents a 3D camera
            </summary>
        </member>
        <member name="M:Xen.Camera.Camera3D.#ctor(Xen.Camera.Projection,Microsoft.Xna.Framework.Matrix)">
            <summary>
            Construct a camera with the given projection, located at the given matrix
            </summary>
            <param name="projection"></param>
            <param name="cameraMatrix"></param>
        </member>
        <member name="M:Xen.Camera.Camera3D.#ctor(Xen.Camera.Projection)">
            <summary>
            Construct a camera with the given projection, using an identity matrix for it's position
            </summary>
            <param name="projection"></param>
        </member>
        <member name="M:Xen.Camera.Camera3D.#ctor">
            <summary>
            Construct a camera with a default camera projection, using an identity matrix for it's position
            </summary>
        </member>
        <member name="M:Xen.Camera.Camera3D.LookAt(Microsoft.Xna.Framework.Vector3@,Microsoft.Xna.Framework.Vector3@,Microsoft.Xna.Framework.Vector3@)">
            <summary>
            Sets the <see cref="P:Xen.Camera.Camera3D.CameraMatrix"/> to a matrix that will make the camera look at a target
            </summary>
            <param name="cameraPosition"></param>
            <param name="lookAtTarget"></param>
            <param name="upVector">Vector representing the up direction for the camera. This vector is required to determine how the camera is orientated around the direction it is looking in</param>
            <remarks>
            <para>Using <see cref="M:Microsoft.Xna.Framework.Matrix.CreateLookAt(Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3)"/> is not recommended because it creats a View matrix, so it cannot be used for non-camera matrices. The <see cref="P:Xen.Camera.Camera3D.CameraMatrix"/> of a camera is the Inverse (<see cref="M:Microsoft.Xna.Framework.Matrix.Invert(Microsoft.Xna.Framework.Matrix)"/>) of the View Matrix (<see cref="M:Xen.Camera.ICamera.GetViewMatrix(Microsoft.Xna.Framework.Matrix@)"/>), so trying to set the camera matrix using Matrix.CreateLookAt will produce highly unexpected results.
            </para></remarks>
        </member>
        <member name="M:Xen.Camera.Camera3D.LookAt(Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3)">
            <summary>
            Sets the <see cref="P:Xen.Camera.Camera3D.CameraMatrix"/> to a matrix that will make the camera look at a target
            </summary>
            <param name="cameraPosition"></param>
            <param name="lookAtTarget"></param>
            <param name="upVector">Vector representing the up direction for the camera. This vector is required to determine how the camera is orientated around the direction it is looking in</param>
        </member>
        <member name="M:Xen.Camera.Camera3D.SetCameraMatrix(Microsoft.Xna.Framework.Matrix@)">
            <summary>
            Sets the camera matrix
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:Xen.Camera.Camera3D.GetCullingPlanes">
            <summary>
            Get the cull planes for this camera
            </summary>
            <returns></returns>
        </member>
        <member name="M:Xen.Camera.Camera3D.GetCullingPlanes(System.Int32@)">
            <summary>
            Get the cull planes for this camera
            </summary>
        </member>
        <member name="M:Xen.Camera.Camera3D.GetCameraMatrix(Microsoft.Xna.Framework.Matrix@)">
            <summary>
            Get the matrix for this camera
            </summary>
            <param name="matrix"></param>
        </member>
        <member name="M:Xen.Camera.Camera3D.GetCameraPosition(Microsoft.Xna.Framework.Vector3@)">
            <summary>
            Get the position of this camera
            </summary>
            <param name="viewPoint"></param>
        </member>
        <member name="M:Xen.Camera.Camera3D.GetCameraViewDirection(Microsoft.Xna.Framework.Vector3@)">
            <summary>
            Get the view direction of this camera
            </summary>
            <param name="viewDirection"></param>
        </member>
        <member name="M:Xen.Camera.Camera3D.ProjectToTarget(Microsoft.Xna.Framework.Vector3@,Microsoft.Xna.Framework.Vector2@,Xen.Graphics.DrawTarget)">
            <summary>
            <para>Projects a position in 3D space into draw target pixel coordinates</para>
            <para>Returns false if the projected point is behind the camera</para>
            </summary>
            <param name="position">3D world space position to project into draw target coordinates</param>
            <param name="coordinate">draw target coordinates of the projected position</param>
            <returns>True if the projected position is in front of the camera</returns>
            <param name="target">Draw Target space to project the point onto</param>
        </member>
        <member name="M:Xen.Camera.Camera3D.ProjectFromTarget(Microsoft.Xna.Framework.Vector2@,System.Single,Microsoft.Xna.Framework.Vector3@,Xen.Graphics.DrawTarget)">
            <summary>
            <para>Projects a position in draw target pixel coordinates into a 3D position in world space, based on a projection depth</para>
            <para>NOTE: For 3D Cameras this method is expensive! Where possible use ProjectFromTarget in <see cref="P:Xen.DrawState.Camera"/></para>
            </summary>
            <param name="coordinate">Coordinate in draw target pixels to project into world space</param>
            <param name="projectDepth">World space depth to project from the camera position</param>
            <param name="position">projected position</param>
            <param name="target">Draw Target space to unproject the point from</param>
        </member>
        <member name="M:Xen.Camera.Camera3D.ProjectToCoordinate(Microsoft.Xna.Framework.Vector3@,Microsoft.Xna.Framework.Vector2@)">
            <summary>
            <para>Projects a position in 3D space into [-1,+1] projected coordinates</para>
            <para>[-1,+1] Coordinates are equivalent of the size of a DrawTarget, where (-1,-1) is bottom left, (1,1) is top right and (0,0) is centered</para>
            <para>Returns false if the projected point is behind the camera</para>
            </summary>
            <param name="position">3D world space position to project into [-1,+1] projected coordinates</param>
            <param name="coordinate">[-1,+1] coordinates of the projected position</param>
            <returns>True if the projected position is in front of the camera</returns>
        </member>
        <member name="M:Xen.Camera.Camera3D.ProjectFromCoordinate(Microsoft.Xna.Framework.Vector2@,System.Single,Microsoft.Xna.Framework.Vector3@)">
            <summary>
            <para>Projects a position in [-1,+1] coordinates into a 3D position in world space, based on a projection depth</para>
            <para>[-1,+1] Coordinates are equivalent of the size of a DrawTarget, where (-1,-1) is bottom left, (1,1) is top right and (0,0) is centered</para>
            <para>NOTE: For 3D Cameras this method is expensive! Where possible use ProjectFromTarget in <see cref="P:Xen.DrawState.Camera"/></para>
            </summary>
            <param name="coordinate">Coordinate in [-1,+1] to project into world space</param>
            <param name="projectDepth">World space depth to project from the camera position</param>
            <param name="position">unprojected position</param>
        </member>
        <member name="P:Xen.Camera.Camera3D.ReverseBackfaceCulling">
            <summary>
            If true, the renderer will set the <see cref="P:Xen.Graphics.RasterState.CullMode"/> to the opposite value (unless set to None).
            </summary>
        </member>
        <member name="P:Xen.Camera.Camera3D.Projection">
            <summary>
            Get the cameras projection
            </summary>
        </member>
        <member name="P:Xen.Camera.Camera3D.CameraMatrix">
            <summary>
            Gets/Sets the camera matrix. The preferred methods to use are <see cref="M:Xen.Camera.Camera3D.GetCameraMatrix(Microsoft.Xna.Framework.Matrix@)"/> and <see cref="M:Xen.Camera.Camera3D.SetCameraMatrix(Microsoft.Xna.Framework.Matrix@)"/>
            </summary>
        </member>
        <member name="P:Xen.Camera.Camera3D.Position">
            <summary>
            Gets/Sets the position of this camera
            </summary>
        </member>
        <member name="T:Xen.Input.ControlInput">
            <summary>
            Enumeration for a player method of input (eg, gamepad or keyboard and mouse)
            </summary>
        </member>
        <member name="F:Xen.Input.ControlInput.GamePad1">
            <summary></summary>
        </member>
        <member name="F:Xen.Input.ControlInput.GamePad2">
            <summary></summary>
        </member>
        <member name="F:Xen.Input.ControlInput.GamePad3">
            <summary></summary>
        </member>
        <member name="F:Xen.Input.ControlInput.GamePad4">
            <summary></summary>
        </member>
        <member name="F:Xen.Input.ControlInput.KeyboardMouse">
            <summary>[Windows Only]</summary>
        </member>
        <member name="T:Xen.Input.MouseInput">
            <summary>
            [Windows Only] Mouse input method, such as buttons, axis and wheel
            </summary>
        </member>
        <member name="F:Xen.Input.MouseInput.LeftButton">
            <summary></summary>
        </member>
        <member name="F:Xen.Input.MouseInput.RightButton">
            <summary></summary>
        </member>
        <member name="F:Xen.Input.MouseInput.MiddleButton">
            <summary></summary>
        </member>
        <member name="F:Xen.Input.MouseInput.XButton1">
            <summary></summary>
        </member>
        <member name="F:Xen.Input.MouseInput.XButton2">
            <summary></summary>
        </member>
        <member name="F:Xen.Input.MouseInput.XAxis">
            <summary></summary>
        </member>
        <member name="F:Xen.Input.MouseInput.YAxis">
            <summary></summary>
        </member>
        <member name="F:Xen.Input.MouseInput.ScrollWheel">
            <summary></summary>
        </member>
        <member name="T:Xen.Input.PlayerInputCollection">
            <summary>
            Collection containing 4 <see cref="T:Xen.Input.PlayerInput"/> objects. Indexable by integer or <see cref="T:Microsoft.Xna.Framework.PlayerIndex"/> enum
            </summary>
        </member>
        <member name="M:Xen.Input.PlayerInputCollection.GetEnumerator">
            <summary>
            </summary>
            <returns></returns>
        </member>
        <member name="P:Xen.Input.PlayerInputCollection.Item(System.Int32)">
            <summary>
            Get a <see cref="T:Xen.Input.PlayerInput"/> object by index
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="P:Xen.Input.PlayerInputCollection.Item(Microsoft.Xna.Framework.PlayerIndex)">
            <summary>
            Get a <see cref="T:Xen.Input.PlayerInput"/> object by <see cref="T:Microsoft.Xna.Framework.PlayerIndex"/>
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="P:Xen.Input.PlayerInputCollection.Count">
            <summary>
            Number of <see cref="T:Xen.Input.PlayerInput"/> objects (always 4)
            </summary>
        </member>
        <member name="P:Xen.Input.PlayerInputCollection.IsReadOnly">
            <summary>
            Always true
            </summary>
        </member>
        <member name="T:Xen.Input.PlayerInput">
            <summary>
            Class storing a players user input (through either a gamepad or through a keyboard and mouse). This class is best accessed through <see cref="P:Xen.UpdateState.PlayerInput"/>
            </summary>
        </member>
        <member name="P:Xen.Input.PlayerInput.PlayerIndex">
            <summary>
            Gets the player index for this input
            </summary>
        </member>
        <member name="P:Xen.Input.PlayerInput.ChatPadState">
            <summary>
            [Xbox Only] Gets the current state of the chatpad
            </summary>
        </member>
        <member name="P:Xen.Input.PlayerInput.InputState">
            <summary>
            Gets the state of the players input (use this object to respond to player input)
            </summary>
        </member>
        <member name="P:Xen.Input.PlayerInput.InputMapper">
            <summary>
            (Advanced use) Gets/Sets the virtual class that performs custom control mapping logic. The default implementation does no remapping
            </summary>
        </member>
        <member name="P:Xen.Input.PlayerInput.KeyboardMouseControlMapping">
            <summary>
            Gets/Sets the class used for mapping keyboard/mouse controls to gamepad equivalent controls 
            </summary>
        </member>
        <member name="P:Xen.Input.PlayerInput.ControlInput">
            <summary>
            Gets/Sets the method of control used by this player (Eg, gamepad)
            </summary>
        </member>
        <member name="T:Xen.UpdateState">
            <summary>
            State object storing state accessable during an Update() call
            </summary>
        </member>
        <member name="F:Xen.UpdateState.TicksInOneSecond">
            <summary>
            The number of ticks that are in one second (10000000)
            </summary>
        </member>
        <member name="M:Xen.UpdateState.op_Implicit(Xen.UpdateState)~Microsoft.Xna.Framework.GameTime">
            <summary>
            Cast the UpdateState to an XNA gametime
            </summary>
            <param name="state"></param>
            <returns></returns>
        </member>
        <member name="M:Xen.UpdateState.PreFrameDraw(Xen.IFrameDraw)">
            <summary>
            <para>The the item passed in will be drawn at the start of the next frame, before the main application Draw method is called</para>
            </summary>
        </member>
        <member name="M:Xen.UpdateState.GetGamePadState(System.Int32,Microsoft.Xna.Framework.Input.GamePadState@)">
            <summary>
            Using <see cref="P:Xen.UpdateState.PlayerInput"/> is recommended over direct state access
            </summary>
        </member>
        <member name="P:Xen.UpdateState.IsAsynchronousState">
            <summary>
            True if the current state is potentially running on multiple threads
            </summary>
        </member>
        <member name="P:Xen.UpdateState.Application">
            <summary>
            Application instance
            </summary>
        </member>
        <member name="P:Xen.UpdateState.UpdateManager">
            <summary>
            Gets the update manager managing this object
            </summary>
        </member>
        <member name="P:Xen.UpdateState.DeltaTimeFrequency">
            <summary>
            Time delta (change) for the last frame/update as a frequency. Eg, 60 for 60fps
            </summary>
        </member>
        <member name="P:Xen.UpdateState.DeltaTimeSeconds">
            <summary>
            Time delta (change) for the last frame/update as a number of seconds. Eg, 0.0166 for 60fps
            </summary>
        </member>
        <member name="P:Xen.UpdateState.DeltaTimeTicks">
            <summary>
            Accurate delta time
            </summary>
        </member>
        <member name="P:Xen.UpdateState.TotalTimeTicks">
            <summary>
            Accurate total time
            </summary>
        </member>
        <member name="P:Xen.UpdateState.TotalTimeSeconds">
            <summary>
            Total time in seconds
            </summary>
        </member>
        <member name="P:Xen.UpdateState.PlayerInput">
            <summary>
            <para>Stores <see cref="P:Xen.UpdateState.PlayerInput"/> instances for each player.</para>
            <para>PlayerInput objects represent player GamePads. To access the Keyboard/Mouse in windows, use <see cref="P:Xen.UpdateState.KeyboardState"/> and <see cref="P:Xen.UpdateState.MouseState"/></para>
            </summary>
        </member>
        <member name="P:Xen.UpdateState.KeyboardState">
            <summary>
            [Windows Only]
            For gamepad function, using <see cref="P:Xen.UpdateState.PlayerInput"/> is recommended over direct state access for simulating a gamepad
            </summary>
        </member>
        <member name="P:Xen.UpdateState.MouseState">
            <summary>
            [Windows Only]
            For gamepad function, using <see cref="P:Xen.UpdateState.PlayerInput"/> is recommended over direct state access for simulating a gamepad
            </summary>
        </member>
        <member name="T:Xen.FrameState">
            <summary>
            Provides access to application state for rendering the current frame.
            </summary>
        </member>
        <member name="M:Xen.FrameState.op_Explicit(Xen.FrameState)~Microsoft.Xna.Framework.Graphics.GraphicsDevice">
            <summary>
            Cast the FrameState to a GraphicsDevice. Make sure to dirty the render state if it is changed
            </summary>
            <param name="state"></param>
            <returns></returns>
        </member>
        <member name="M:Xen.FrameState.op_Implicit(Xen.FrameState)~Microsoft.Xna.Framework.GameTime">
            <summary>
            Cast the FrameState to an XNA gametime
            </summary>
            <param name="state"></param>
            <returns></returns>
        </member>
        <member name="M:Xen.FrameState.GetShader``1">
            <summary>
            <para>Gets an application wide global instance of a Shader by type</para>
            <para>Use this method to share instances and reduce the number of live objects (most useful for simpler shaders)</para>
            </summary>
        </member>
        <member name="M:Xen.FrameState.PreFrameDraw(Xen.IFrameDraw)">
            <summary>
            <para>The the item passed in will have it's Draw method called at the start of the next frame, before the main application Draw method is next called</para>
            </summary>
        </member>
        <member name="M:Xen.FrameState.GetShaderAttributeNameUniqueID(System.String)">
            <summary>
            Gets the unique ID index for a non-global shader attribute. For use in a call to IShader.SetAttribute, IShader.SetTexture or IShader.SetSamplerState"/>
            </summary>
            <param name="name">case sensitive name of the shader attribute</param>
            <returns>globally unique index of the attribute name</returns>
        </member>
        <member name="M:Xen.FrameState.GetDynamicInstanceBuffer(System.Int32)">
            <summary>
            Returns a buffer that instances can be written to. Use to draw instances in a call to DrawInstances"/>
            </summary>
        </member>
        <member name="P:Xen.FrameState.ApproximateFrameRate">
            <summary>
            Gets the approximate frame rate for the last 20 frames
            </summary>
        </member>
        <member name="P:Xen.FrameState.SupportsHardwareInstancing">
            <summary>
            Returns true if the device supports hardware instancing
            </summary>
        </member>
        <member name="P:Xen.FrameState.FrameIndex">
            <summary>
            Gets an integer index, incremented every frame
            </summary>
        </member>
        <member name="P:Xen.FrameState.DrawFlags">
            <summary>
            Gets the draw flag stack
            </summary>
        </member>
        <member name="P:Xen.FrameState.Cullers">
            <summary>
            Gets the cullers stack
            </summary>
        </member>
        <member name="P:Xen.FrameState.ShaderGlobals">
            <summary>
            Gets the shader system global interface
            </summary>
        </member>
        <member name="P:Xen.FrameState.Application">
            <summary>
            Gets the Application instance
            </summary>
        </member>
        <member name="P:Xen.FrameState.DeltaTimeFrequency">
            <summary>
            Time delta (change) for the last frame as a frequency. Eg, 60 for 60fps
            </summary>
        </member>
        <member name="P:Xen.FrameState.DeltaTimeSeconds">
            <summary>
            Time delta (change) for the last frame as a number of seconds. Eg, 0.0166 for 60fps
            </summary>
        </member>
        <member name="P:Xen.FrameState.DeltaTimeTicks">
            <summary>
            Accurate delta time
            </summary>
        </member>
        <member name="P:Xen.FrameState.TotalTimeTicks">
            <summary>
            Accurate total time
            </summary>
        </member>
        <member name="P:Xen.FrameState.TotalTimeSeconds">
            <summary>
            Accurate total time in seconds
            </summary>
        </member>
        <member name="T:Xen.DrawState">
            <summary>
            Provides access to the Render State, Camera, Culler and many other methods and objects used during drawing. This class should provide almost everything an application requires when drawing (as opposed to directly accessing the GraphicsDevice)
            </summary>
        </member>
        <member name="T:Xen.ICuller">
            <summary>
            Extension of the <see cref="T:Xen.ICullPrimitive"/> interface that can cull primitive shapes, but is also aware of the current context, having access to the position of the object in advance (eg the drawstate world matrix)
            </summary>
        </member>
        <member name="M:Xen.ICuller.TestBox(Microsoft.Xna.Framework.Vector3@,Microsoft.Xna.Framework.Vector3@)">
            <summary>
            FrustumCull test a box. World matrix will be inferred (eg, current <see cref="T:Xen.DrawState"/> <see cref="M:Xen.Graphics.Stack.WorldMatrixStackProvider.GetMatrix(Microsoft.Xna.Framework.Matrix@)">world matrix</see>)
            </summary>
            <param name="min">box minimum point (in local space)</param>
            <param name="max">box maximum point (in local space)</param>
            <returns>True if the test passes (eg, box is on screen, box intersects shape, etc)</returns>
        </member>
        <member name="M:Xen.ICuller.TestBox(Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3)">
            <summary>
            FrustumCull test a box. World matrix will be inferred (eg, current <see cref="T:Xen.DrawState"/> <see cref="M:Xen.Graphics.Stack.WorldMatrixStackProvider.GetMatrix(Microsoft.Xna.Framework.Matrix@)">world matrix</see>)
            </summary>
            <param name="min">box minimum point (in local space)</param>
            <param name="max">box maximum point (in local space)</param>
            <returns>True if the test passes (eg, box is on screen, box intersects shape, etc)</returns>
        </member>
        <member name="M:Xen.ICuller.TestBox(Microsoft.Xna.Framework.Vector3@,Microsoft.Xna.Framework.Vector3@,Microsoft.Xna.Framework.Matrix@)">
            <summary>
            FrustumCull test a box with a local matrix. World matrix will be inferred (eg, current <see cref="T:Xen.DrawState"/> <see cref="M:Xen.Graphics.Stack.WorldMatrixStackProvider.GetMatrix(Microsoft.Xna.Framework.Matrix@)">world matrix</see>)
            </summary>
            <param name="min">box minimum point (in local space)</param>
            <param name="max">box maximum point (in local space)</param>
            <param name="boxMatrix">Local matrix of the box</param>
            <returns>True if the test passes (eg, box is on screen, box intersects shape, etc)</returns>
        </member>
        <member name="M:Xen.ICuller.TestBox(Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Matrix@)">
            <summary>
            FrustumCull test a box with a local matrix. World matrix will be inferred (eg, current <see cref="T:Xen.DrawState"/> <see cref="M:Xen.Graphics.Stack.WorldMatrixStackProvider.GetMatrix(Microsoft.Xna.Framework.Matrix@)">world matrix</see>)
            </summary>
            <param name="min">box minimum point (in local space)</param>
            <param name="max">box maximum point (in local space)</param>
            <param name="boxMatrix">Local matrix of the box</param>
            <returns>True if the test passes (eg, box is on screen, box intersects shape, etc)</returns>
        </member>
        <member name="M:Xen.ICuller.TestSphere(System.Single)">
            <summary>
            FrustumCull test a sphere. World position will be inferred (eg, current <see cref="T:Xen.DrawState"/> <see cref="M:Xen.Graphics.Stack.WorldMatrixStackProvider.GetMatrix(Microsoft.Xna.Framework.Matrix@)">world matrix</see>)
            </summary>
            <param name="radius">Radius of the sphere</param>
            <returns>True if the test passes (eg, sphere is on screen, sphere intersects shape, etc)</returns>
        </member>
        <member name="M:Xen.ICuller.TestSphere(System.Single,Microsoft.Xna.Framework.Vector3@)">
            <summary>
            FrustumCull test a sphere. World position will be inferred (eg, current <see cref="T:Xen.DrawState"/> <see cref="M:Xen.Graphics.Stack.WorldMatrixStackProvider.GetMatrix(Microsoft.Xna.Framework.Matrix@)">world matrix</see>)
            </summary>
            <param name="radius">Radius of the sphere</param>
            <param name="position">Position of the sphere in relation to the world matrix</param>
            <returns>True if the test passes (eg, sphere is on screen, sphere intersects shape, etc)</returns>
        </member>
        <member name="M:Xen.ICuller.TestSphere(System.Single,Microsoft.Xna.Framework.Vector3)">
            <summary>
            FrustumCull test a sphere. World position will be inferred (eg, current <see cref="T:Xen.DrawState"/> <see cref="M:Xen.Graphics.Stack.WorldMatrixStackProvider.GetMatrix(Microsoft.Xna.Framework.Matrix@)">world matrix</see>)
            </summary>
            <param name="radius">Radius of the sphere</param>
            <param name="position">Position of the sphere in relation to the world matrix</param>
            <returns>True if the test passes (eg, sphere is on screen, sphere intersects shape, etc)</returns>
        </member>
        <member name="M:Xen.ICuller.IntersectBox(Microsoft.Xna.Framework.Vector3@,Microsoft.Xna.Framework.Vector3@)">
            <summary>
            <para>Intersect a box. World matrix will be inferred (eg, current <see cref="T:Xen.DrawState"/> <see cref="M:Xen.Graphics.Stack.WorldMatrixStackProvider.GetMatrix(Microsoft.Xna.Framework.Matrix@)">world matrix</see>)</para>
            <para>Note: Intersection tests may be less efficient than boolean TestBox</para>
            </summary>
            <param name="min">box minimum point (in local space)</param>
            <param name="max">box maximum point (in local space)</param>
            <returns>Intersetction test result</returns>
        </member>
        <member name="M:Xen.ICuller.IntersectBox(Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3)">
            <summary>
            <para>Intersect a box. World matrix will be inferred (eg, current <see cref="T:Xen.DrawState"/> <see cref="M:Xen.Graphics.Stack.WorldMatrixStackProvider.GetMatrix(Microsoft.Xna.Framework.Matrix@)">world matrix</see>)</para>
            <para>Note: Intersection tests may be less efficient than boolean TestBox</para>
            </summary>
            <param name="min">box minimum point (in local space)</param>
            <param name="max">box maximum point (in local space)</param>
            <returns>Intersetction test result</returns>
        </member>
        <member name="M:Xen.ICuller.IntersectBox(Microsoft.Xna.Framework.Vector3@,Microsoft.Xna.Framework.Vector3@,Microsoft.Xna.Framework.Matrix@)">
            <summary>
            <para>Intersect a box with a local matrix. World matrix will be inferred (eg, current <see cref="T:Xen.DrawState"/> <see cref="M:Xen.Graphics.Stack.WorldMatrixStackProvider.GetMatrix(Microsoft.Xna.Framework.Matrix@)">world matrix</see>)</para>
            <para>Note: Intersection tests may be less efficient than boolean TestBox</para>
            </summary>
            <param name="min">box minimum point (in local space)</param>
            <param name="max">box maximum point (in local space)</param>
            <param name="boxMatrix">Local matrix of the box</param>
            <returns>Intersetction test result</returns>
        </member>
        <member name="M:Xen.ICuller.IntersectBox(Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Matrix@)">
            <summary>
            <para>Intersect a box with a local matrix. World matrix will be inferred (eg, current <see cref="T:Xen.DrawState"/> <see cref="M:Xen.Graphics.Stack.WorldMatrixStackProvider.GetMatrix(Microsoft.Xna.Framework.Matrix@)">world matrix</see>)</para>
            <para>Note: Intersection tests may be less efficient than boolean TestBox</para>
            </summary>
            <param name="min">box minimum point (in local space)</param>
            <param name="max">box maximum point (in local space)</param>
            <param name="boxMatrix">Local matrix of the box</param>
            <returns>Intersetction test result</returns>
        </member>
        <member name="M:Xen.ICuller.IntersectSphere(System.Single)">
            <summary>
            <para>Intersect a sphere. World position will be inferred (eg, current <see cref="T:Xen.DrawState"/> <see cref="M:Xen.Graphics.Stack.WorldMatrixStackProvider.GetMatrix(Microsoft.Xna.Framework.Matrix@)">world matrix</see>)</para>
            <para>Note: Intersection tests may be less efficient than boolean TestSphere</para>
            </summary>
            <param name="radius">Radius of the sphere</param>
            <returns>Intersetction test result</returns>
        </member>
        <member name="M:Xen.ICuller.IntersectSphere(System.Single,Microsoft.Xna.Framework.Vector3@)">
            <summary>
            <para>Intersect a sphere. World position will be inferred (eg, current <see cref="T:Xen.DrawState"/> <see cref="M:Xen.Graphics.Stack.WorldMatrixStackProvider.GetMatrix(Microsoft.Xna.Framework.Matrix@)">world matrix</see>)</para>
            <para>Note: Intersection tests may be less efficient than boolean TestSphere</para>
            </summary>
            <param name="radius">Radius of the sphere</param>
            <param name="position">Position of the sphere in relation to the world matrix</param>
            <returns>Intersetction test result</returns>
        </member>
        <member name="M:Xen.ICuller.IntersectSphere(System.Single,Microsoft.Xna.Framework.Vector3)">
            <summary>
            <para>Intersect a sphere. World position will be inferred (eg, current <see cref="T:Xen.DrawState"/> <see cref="M:Xen.Graphics.Stack.WorldMatrixStackProvider.GetMatrix(Microsoft.Xna.Framework.Matrix@)">world matrix</see>)</para>
            <para>Note: Intersection tests may be less efficient than boolean TestSphere</para>
            </summary>
            <param name="radius">Radius of the sphere</param>
            <param name="position">Position of the sphere in relation to the world matrix</param>
            <returns>Intersetction test result</returns>
        </member>
        <member name="M:Xen.ICuller.GetWorldMatrix(Microsoft.Xna.Framework.Matrix@)">
            <summary>
            Gets the world matrix for the current context, eg the top of the rendering world matrix stack (as stored in the <see cref="T:Xen.DrawState"/> object)
            </summary>
            <param name="world"></param>
        </member>
        <member name="M:Xen.ICuller.GetWorldPosition(Microsoft.Xna.Framework.Vector3@)">
            <summary>
            Gets the world position for the current context, eg the top of the rendering world matrix stack (as stored in the <see cref="T:Xen.DrawState"/> object)
            </summary>
            <param name="position"></param>
        </member>
        <member name="M:Xen.ICuller.GetState">
            <summary>
            Gets the state of the application
            </summary>
            <returns></returns>
            <remarks><para>This is commonly the <see cref="T:Xen.DrawState"/>, however it is highly recommended that no drawing ever be done in a <see cref="M:Xen.ICullable.CullTest(Xen.ICuller)"/> method body</para></remarks>
        </member>
        <member name="P:Xen.ICuller.FrameIndex">
            <summary>
            Gets the current rendering frame index
            </summary>
            <remarks><para>This value is useful if an object needs to calculate culling data once per frame, but doesn't want to recalculate it if culled more than once during the frame</para>
            <para>Implementations should return the same value that DrawState.Properties.FrameIndex would return for the current frame</para></remarks>
        </member>
        <member name="F:Xen.DrawState.TicksInOneSecond">
            <summary>The number of ticks that are in one second (10000000)</summary>
        </member>
        <member name="M:Xen.DrawState.op_Explicit(Xen.DrawState)~Microsoft.Xna.Framework.Graphics.GraphicsDevice">
            <summary>
            Get the GraphicsDevice from the DrawState
            </summary>
        </member>
        <member name="M:Xen.DrawState.op_Implicit(Xen.DrawState)~Microsoft.Xna.Framework.GameTime">
            <summary>
            Cast the DrawState to an XNA gametime
            </summary>
        </member>
        <member name="M:Xen.DrawState.GetShader``1">
            <summary>
            <para>Gets an application wide global instance of a Shader by type</para>
            <para>Use this method to share instances and reduce the number of live objects (most useful for simpler shaders)</para>
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Xen.DrawState.PreFrameDraw(Xen.IFrameDraw)">
            <summary>
            <para>The the item passed in will have it's Draw method called at the start of the next frame, before the main application Draw method is next called</para>
            </summary>
        </member>
        <member name="M:Xen.DrawState.op_Addition(Xen.DrawState,Xen.Graphics.IShader)">
            <summary>Helper method used to wrap a Push method</summary>
        </member>
        <member name="M:Xen.DrawState.op_Addition(Xen.DrawState,Microsoft.Xna.Framework.Graphics.Effect)">
            <summary>Helper method used to wrap a Push method</summary>
        </member>
        <member name="M:Xen.DrawState.op_Addition(Xen.DrawState,Xen.Graphics.DeviceRenderState)">
            <summary>Helper method used to wrap a Push method</summary>
        </member>
        <member name="M:Xen.DrawState.op_Addition(Xen.DrawState,Xen.Graphics.AlphaBlendState)">
            <summary>Helper method used to wrap a Push method</summary>
        </member>
        <member name="M:Xen.DrawState.op_Addition(Xen.DrawState,Xen.Graphics.StencilState)">
            <summary>Helper method used to wrap a Push method</summary>
        </member>
        <member name="M:Xen.DrawState.op_Addition(Xen.DrawState,Xen.Graphics.DepthState)">
            <summary>Helper method used to wrap a Push method</summary>
        </member>
        <member name="M:Xen.DrawState.op_Addition(Xen.DrawState,Xen.Graphics.RasterState)">
            <summary>Helper method used to wrap a Push method</summary>
        </member>
        <member name="M:Xen.DrawState.op_Addition(Xen.DrawState,Xen.Camera.ICamera)">
            <summary>Helper method used to wrap a Push method</summary>
        </member>
        <member name="M:Xen.DrawState.op_Addition(Xen.DrawState,Microsoft.Xna.Framework.Matrix)">
            <summary>Helper method used to wrap a Push method</summary>
        </member>
        <member name="M:Xen.DrawState.op_Multiply(Xen.DrawState,Microsoft.Xna.Framework.Matrix)">
            <summary>Helper method used to wrap a PushMultiply method</summary>
        </member>
        <member name="M:Xen.DrawState.op_Addition(Xen.DrawState,Microsoft.Xna.Framework.Vector3)">
            <summary>Helper method used to wrap a Push method</summary>
        </member>
        <member name="M:Xen.DrawState.op_Multiply(Xen.DrawState,Microsoft.Xna.Framework.Vector3)">
            <summary>Helper method used to wrap a PushMultiply method</summary>
        </member>
        <member name="M:Xen.DrawState.op_Implicit(Xen.Graphics.ShaderSystem.ShaderSystemBase)~Xen.DrawState">
            <summary>
            Cast from the shader system to draw state
            </summary>
        </member>
        <member name="M:Xen.DrawState.op_Implicit(Xen.DrawState)~Xen.Graphics.ShaderSystem.ShaderSystemBase">
            <summary>
            Cast from the draw state to the shader system
            </summary>
        </member>
        <member name="M:Xen.DrawState.GetShaderAttributeNameUniqueID(System.String)">
            <summary>
            Gets the unique ID index for a non-global shader attribute. For use in a call to IShader.SetAttribute, IShader.SetTexture or IShader.SetSamplerState"/>
            </summary>
            <param name="name">case sensitive name of the shader attribute</param>
            <returns>globally unique index of the attribute name</returns>
        </member>
        <member name="M:Xen.DrawState.GetDynamicInstanceBuffer(System.Int32)">
            <summary>
            Returns a buffer that instances can be written to. Use to draw instances in a call to DrawInstances"/>
            </summary>
        </member>
        <member name="M:Xen.DrawState.GetDynamicInstanceBuffer(Microsoft.Xna.Framework.Matrix[],System.Int32)">
            <summary>
            Returns a buffer that instances with instances written to. Use to draw instances in a call to DrawInstances
            </summary>
        </member>
        <member name="M:Xen.DrawState.InternalDrawBatch(Xen.Graphics.IVertices,Xen.Graphics.IIndices,Microsoft.Xna.Framework.Graphics.PrimitiveType,Xen.Graphics.InstanceBuffer)">
            <summary>
            [Requires a HiDef graphics device to support hardware instancing]
            </summary>
            <param name="vertices">Vertex buffer of the instances to be drawn</param>
            <param name="indices">Index buffer of the instances to be drawn</param>
            <param name="primitiveType">Primitive type to be drawn</param>
            <param name="instances">Instance buffer that contains the instances to be drawn</param>
        </member>
        <member name="M:Xen.DrawState.DrawDynamicIndexedVertices``1(``0[],System.Int32[],Microsoft.Xna.Framework.Graphics.PrimitiveType,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            <para>Draw dynamic vertices as primitives with extended parametres, using an index buffer (indices)</para>
            <para>NOTE: When using this method, the vertex and index data will be copied every frame.</para>
            <para>This method is best for volatile vertex data that is changing every frame.</para>
            <para>Use a dynamic Vertices object for dynamic data that changes less frequently, or requires use with a VerticesGroup objcet.</para>
            </summary>
            <param name="vertices">source vertex data to use for drawing vertices</param>
            <param name="indices">indices to use when drawing</param>
            <param name="primitiveType">Primitive type to use when drawing the buffer</param>
            <param name="primitveCount">The number of primitives to draw</param>
            <param name="startIndex">The start index in the index buffer (defaults to the first index - 0)</param>
            <param name="vertexOffset">Starting offset into the vertex buffer (defaults to the first vertex - 0)</param>
            <param name="maximumIndex">The maximum index used by the index buffer. This determines how many vertices will be copied (zero will copy all vertices)</param>
        </member>
        <member name="M:Xen.DrawState.DrawDynamicIndexedVertices``1(``0[],System.Int16[],Microsoft.Xna.Framework.Graphics.PrimitiveType,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            <para>Draw dynamic vertices as primitives with extended parametres, using an index buffer (indices)</para>
            <para>NOTE: When using this method, the vertex and index data will be copied every frame.</para>
            <para>This method is best for volatile vertex data that is changing every frame.</para>
            <para>Use a dynamic Vertices object for dynamic data that changes less frequently, or requires use with a VerticesGroup objcet.</para>
            </summary>
            <param name="vertices">source vertex data to use for drawing vertices</param>
            <param name="indices">indices to use when drawing</param>
            <param name="primitiveType">Primitive type to use when drawing the buffer</param>
            <param name="primitveCount">The number of primitives to draw</param>
            <param name="startIndex">The start index in the index buffer (defaults to the first index - 0)</param>
            <param name="vertexOffset">Starting offset into the vertex buffer (defaults to the first vertex - 0)</param>
            <param name="maximumIndex">The maximum index used by the index buffer. This determines how many vertices will be copied (zero will copy all vertices)</param>
        </member>
        <member name="M:Xen.DrawState.DrawDynamicVertices``1(``0[],Microsoft.Xna.Framework.Graphics.PrimitiveType,System.Int32,System.Int32)">
            <summary>
            <para>Draw dynamic vertices as primitives with extended parametres</para>
            <para>NOTE: When using this method, the vertex data will be copied every frame.</para>
            <para>This method is best for volatile vertex data that is changing every frame.</para>
            <para>Use a dynamic Vertices object for dynamic data that changes less frequently, or requires use with a VerticesGroup objcet.</para>
            </summary>
            <param name="vertices">source vertex data to use for drawing vertices</param>
            <param name="primitiveType">Primitive type to use when drawing the buffer</param>
            <param name="primitveCount">The number of primitives to draw</param>
            <param name="vertexOffset">Starting offset into the vertex buffer (defaults to the first vertex - 0)</param>
        </member>
        <member name="M:Xen.DrawState.DrawDynamicIndexedVerticesBlending``1(``0[],System.Int32[],Microsoft.Xna.Framework.Graphics.PrimitiveType,Xen.Graphics.AnimationTransformArray,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            <para>Draw dynamic vertices as primitives with animation blending and extended parametres, using an index buffer (indices)</para>
            <para>NOTE: When using this method, the vertex and index data will be copied every frame.</para>
            <para>This method is best for volatile vertex data that is changing every frame.</para>
            <para>Use a dynamic Vertices object for dynamic data that changes less frequently, or requires use with a VerticesGroup objcet.</para>
            </summary>
            <param name="vertices">source vertex data to use for drawing vertices</param>
            <param name="indices">indices to use when drawing</param>
            <param name="primitiveType">Primitive type to use when drawing the buffer</param>
            <param name="primitveCount">The number of primitives to draw</param>
            <param name="startIndex">The start index in the index buffer (defaults to the first index - 0)</param>
            <param name="animationTransforms">Optional animation transform data for animation blending</param>
            <param name="vertexOffset">Starting offset into the vertex buffer (defaults to the first vertex - 0)</param>
            <param name="maximumIndex">The maximum index used by the index buffer. This determines how many vertices will be copied (zero will copy all vertices)</param>
        </member>
        <member name="M:Xen.DrawState.DrawDynamicIndexedVerticesBlending``1(``0[],System.Int16[],Microsoft.Xna.Framework.Graphics.PrimitiveType,Xen.Graphics.AnimationTransformArray,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            <para>Draw dynamic vertices as primitives with animation blending and extended parametres, using an index buffer (indices)</para>
            <para>NOTE: When using this method, the vertex and index data will be copied every frame.</para>
            <para>This method is best for volatile vertex data that is changing every frame.</para>
            <para>Use a dynamic Vertices object for dynamic data that changes less frequently, or requires use with a VerticesGroup objcet.</para>
            </summary>
            <param name="vertices">source vertex data to use for drawing vertices</param>
            <param name="indices">indices to use when drawing</param>
            <param name="primitiveType">Primitive type to use when drawing the buffer</param>
            <param name="primitveCount">The number of primitives to draw</param>
            <param name="animationTransforms">Optional animation transform data for animation blending</param>
            <param name="startIndex">The start index in the index buffer (defaults to the first index - 0)</param>
            <param name="vertexOffset">Starting offset into the vertex buffer (defaults to the first vertex - 0)</param>
            <param name="maximumIndex">The maximum index used by the index buffer. This determines how many vertices will be copied (zero will copy all vertices)</param>
        </member>
        <member name="M:Xen.DrawState.DrawDynamicVerticesBlending``1(``0[],Microsoft.Xna.Framework.Graphics.PrimitiveType,Xen.Graphics.AnimationTransformArray,System.Int32,System.Int32)">
            <summary>
            <para>Draw dynamic vertices as primitives with animation blending and extended parametres</para>
            <para>NOTE: When using this method, the vertex data will be copied every frame.</para>
            <para>This method is best for volatile vertex data that is changing every frame.</para>
            <para>Use a dynamic Vertices object for dynamic data that changes less frequently, or requires use with a VerticesGroup objcet.</para>
            </summary>
            <param name="vertices">source vertex data to use for drawing vertices</param>
            <param name="primitiveType">Primitive type to use when drawing the buffer</param>
            <param name="primitveCount">The number of primitives to draw</param>
            <param name="animationTransforms">Optional animation transform data for animation blending</param>
            <param name="vertexOffset">Starting offset into the vertex buffer (defaults to the first vertex - 0)</param>
        </member>
        <member name="M:Xen.DrawState.DrawDynamicIndexedVertices``1(``0[],System.Int32[],Microsoft.Xna.Framework.Graphics.PrimitiveType)">
            <summary>
            <para>Draw dynamic vertices as primitives, using an optional index buffer (indices)</para>
            <para>NOTE: When using this method, the vertex and index data will be copied every frame.</para>
            <para>This method is best for volatile vertex data that is changing every frame.</para>
            <para>Use a dynamic Vertices object for dynamic data that changes less frequently, or requires use with a VerticesGroup objcet.</para>
            </summary>
            <param name="vertices">source vertex data to use for drawing vertices</param>
            <param name="indices">indices to use when drawing (may be null)</param>
            <param name="primitiveType">Primitive type to use when drawing the buffer</param>
        </member>
        <member name="M:Xen.DrawState.DrawDynamicIndexedVertices``1(``0[],System.Int16[],Microsoft.Xna.Framework.Graphics.PrimitiveType)">
            <summary>
            <para>Draw dynamic vertices as primitives, using an optional index buffer (indices)</para>
            <para>NOTE: When using this method, the vertex and index data will be copied every frame.</para>
            <para>This method is best for volatile vertex data that is changing every frame.</para>
            <para>Use a dynamic Vertices object for dynamic data that changes less frequently, or requires use with a VerticesGroup objcet.</para>
            </summary>
            <param name="vertices">source vertex data to use for drawing vertices</param>
            <param name="indices">indices to use when drawing (may be null)</param>
            <param name="primitiveType">Primitive type to use when drawing the buffer</param>
        </member>
        <member name="M:Xen.DrawState.DrawDynamicVertices``1(``0[],Microsoft.Xna.Framework.Graphics.PrimitiveType)">
            <summary>
            <para>Draw dynamic vertices as primitives</para>
            <para>NOTE: When using this method, the vertex data will be copied every frame.</para>
            <para>This method is best for volatile vertex data that is changing every frame.</para>
            <para>Use a dynamic Vertices object for dynamic data that changes less frequently, or requires use with a VerticesGroup objcet.</para>
            </summary>
            <param name="vertices">source vertex data to use for drawing vertices</param>
            <param name="primitiveType">Primitive type to use when drawing the buffer</param>
        </member>
        <member name="P:Xen.DrawState.Application">
            <summary>
            Application instance
            </summary>
        </member>
        <member name="P:Xen.DrawState.DrawTarget">
            <summary>
            Current DrawTarget that is being drawn to
            </summary>
        </member>
        <member name="P:Xen.DrawState.ApproximateFrameRate">
            <summary>
            Approximate frame rate average for the last 20 drawn frames
            </summary>
        </member>
        <member name="P:Xen.DrawState.DeltaTimeFrequency">
            <summary>
            Time delta (change) for the last frame as a frequency. Eg, 60 for 60fps
            </summary>
        </member>
        <member name="P:Xen.DrawState.DeltaTimeSeconds">
            <summary>
            Time delta (change) for the last frame as a number of seconds. Eg, 0.0166 for 60fps
            </summary>
        </member>
        <member name="P:Xen.DrawState.DeltaTimeTicks">
            <summary>
            Accurate delta time
            </summary>
        </member>
        <member name="P:Xen.DrawState.TotalTimeTicks">
            <summary>
            Accurate total time
            </summary>
        </member>
        <member name="P:Xen.DrawState.TotalTimeSeconds">
            <summary>
            Total application time in seconds
            </summary>
        </member>
        <member name="P:Xen.DrawState.Properties">
            <summary>
            A collection of useful extnension properties and state objects
            </summary>
        </member>
        <member name="P:Xen.DrawState.Shader">
            <summary>
            Gets the rendering shader stack, use this to assign shaders
            </summary>
        </member>
        <member name="P:Xen.DrawState.DrawFlags">
            <summary>
            Gets the draw flag stack
            </summary>
        </member>
        <member name="P:Xen.DrawState.ShaderGlobals">
            <summary>
            Gets the shader system global interface
            </summary>
        </member>
        <member name="P:Xen.DrawState.RenderState">
            <summary>
            Gets the current <see cref="T:Xen.Graphics.DeviceRenderState"/>. Members of this instance can be directly modified. Always push/pop the render state when drawing. To set the entire render state, see RenderState.Push or RenderState.Set
            </summary>
            <remarks><para>It is highly recommended that changes to render state are doen through this instance, rather than directly through the GraphicsDevice.</para>
            <para>If render state is changed through the GraphicsDevice, then the internal state cache will become invalid, and must be reset with a call to <see cref="M:Xen.DrawState.DirtyInternalRenderState(Xen.Graphics.StateFlag)"/>, with the appropriate flags set indicating what parts of the render state have changed</para></remarks>
        </member>
        <member name="P:Xen.DrawState.WorldMatrix">
            <summary>
            Gets the world matrix stack
            </summary>
        </member>
        <member name="P:Xen.DrawState.Camera">
            <summary>
            Gets the camera stack
            </summary>
        </member>
        <member name="P:Xen.DrawState.Cullers">
            <summary>
            Gets the cullers stack
            </summary>
        </member>
        <member name="P:Xen.DrawState.Culler">
            <summary>
            Gets the ICuller interface
            </summary>
        </member>
        <member name="P:Xen.AppState.PlayerInput">
            <summary>
            Always an array of length 4 (PlayerInput[4])
            </summary>
        </member>
        <member name="P:Xen.AppState.MouseState">
            <summary>
            [Windows Only]
            Using <see cref="P:Xen.AppState.PlayerInput"/> is recommended over direct state access
            </summary>
        </member>
        <member name="P:Xen.AppState.GamePadState">
            <summary>
            Using <see cref="P:Xen.AppState.PlayerInput"/> is recommended over direct state access
            </summary>
        </member>
        <member name="P:Xen.AppState.UserValues">
            <summary></summary>
        </member>
        <member name="T:Xen.Graphics.VertexElementAttribute">
            <summary>
            Attribute for declaring exact use for an element in a vertex
            </summary>
            <remarks>
            <para>The vertex buffer generic class Vertices&lt;T&gt; class will automatically try and determine how the vertex structures fields should be used. However, if the autodetection fails, you can manually specify it with this attirubte.
            </para>
            <para>Most specical types in <see cref="N:Microsoft.Xna.Framework.Graphics.PackedVector"/> are automatically supported, so do not need manual declaration.</para>
            </remarks>
            <example>
            <code lang="csharp">
            // an example vertex structure
            struct VertexWithColour
            {
            	public Vector3 position;	//will be automatically detected, based on name and type
            
            	public Color colour0;		//will also be automatically detected as Color type on index 0
            
            	//public int c1;				//the vertex buffer will fail to automatically detect how to use this value
            
            	//must manually define it's use:
            	//specify Colour, byte4 with use index '1'
            
            	[VertexElement(VertexElementUsage.Color,VertexElementFormat.Byte4,1)]
            	public int c1;
            }
            </code>
            </example>
        </member>
        <member name="M:Xen.Graphics.VertexElementAttribute.SizeOfFormatType(Microsoft.Xna.Framework.Graphics.VertexElementFormat)">
            <summary>
            Gets the size (in bytes) of a vertex element format
            </summary>
            <param name="format"></param>
            <returns></returns>
        </member>
        <member name="M:Xen.Graphics.VertexElementAttribute.CalculateVertexStride(Microsoft.Xna.Framework.Graphics.VertexElement[])">
            <summary>
            Computes the stride for a vertex format
            </summary>
            <param name="elements"></param>
            <returns></returns>
        </member>
        <member name="M:Xen.Graphics.VertexElementAttribute.ExtractUsage(Microsoft.Xna.Framework.Graphics.VertexElement[],Microsoft.Xna.Framework.Graphics.VertexElementUsage,System.Int32,Microsoft.Xna.Framework.Graphics.VertexElementFormat@,System.Int32@)">
            <summary>
            Extracts the format and offset of a usage index (simple, but occasionally useful)
            </summary>
            <param name="elements"></param>
            <param name="usage"></param>
            <param name="index"></param>
            <param name="format"></param>
            <param name="offset"></param>
            <returns></returns>
        </member>
        <member name="M:Xen.Graphics.VertexElementAttribute.#ctor(Microsoft.Xna.Framework.Graphics.VertexElementUsage,Microsoft.Xna.Framework.Graphics.VertexElementFormat)">
            <summary></summary>
            <param name="usage">Usage of the element, eg <see cref="P:Xen.Graphics.VertexElementAttribute.VertexElementUsage"/>.Position.</param>
            <param name="format">Data type format of the element, eg a <see cref="T:Microsoft.Xna.Framework.Vector4"/> is <see cref="P:Xen.Graphics.VertexElementAttribute.VertexElementFormat"/>.Vector4</param>
        </member>
        <member name="M:Xen.Graphics.VertexElementAttribute.#ctor(Microsoft.Xna.Framework.Graphics.VertexElementUsage)">
            <summary></summary>
            <param name="usage">Usage of the element, eg <see cref="P:Xen.Graphics.VertexElementAttribute.VertexElementUsage"/>.Position.</param>
        </member>
        <member name="M:Xen.Graphics.VertexElementAttribute.#ctor(Microsoft.Xna.Framework.Graphics.VertexElementUsage,System.Byte)">
            <summary></summary>
            <param name="usage">Usage of the element, eg <see cref="P:Xen.Graphics.VertexElementAttribute.VertexElementUsage"/>.Position.</param>
            <param name="usageIndex">Usage index of the element, eg COLOR1 has a usage index of 1</param>
        </member>
        <member name="M:Xen.Graphics.VertexElementAttribute.#ctor(Microsoft.Xna.Framework.Graphics.VertexElementUsage,Microsoft.Xna.Framework.Graphics.VertexElementFormat,System.Byte)">
            <summary></summary>
            <param name="usage">Usage of the element, eg <see cref="P:Xen.Graphics.VertexElementAttribute.VertexElementUsage"/>.Position.</param>
            <param name="usageIndex">Usage index of the element, eg COLOR1 has a usage index of 1</param>
            <param name="format">Data type format of the element, eg a <see cref="T:Microsoft.Xna.Framework.Vector4"/> is <see cref="P:Xen.Graphics.VertexElementAttribute.VertexElementFormat"/>.Vector4</param>
        </member>
        <member name="P:Xen.Graphics.VertexElementAttribute.UsageIndex">
            <summary>
            Usage index of the element, eg COLOR1 has a usage index of 1
            </summary>
        </member>
        <member name="P:Xen.Graphics.VertexElementAttribute.VertexElementFormat">
            <summary>
            Data type format of the element, eg a <see cref="T:Microsoft.Xna.Framework.Vector4"/> is <see cref="P:Xen.Graphics.VertexElementAttribute.VertexElementFormat"/>.Vector4.
            </summary>
        </member>
        <member name="P:Xen.Graphics.VertexElementAttribute.VertexElementUsage">
            <summary>
            Usage of the element, eg <see cref="P:Xen.Graphics.VertexElementAttribute.VertexElementUsage"/>.Position.
            </summary>
        </member>
        <member name="T:Xen.Graphics.VertexElementAttribute.IgnoredAttribute">
            <summary></summary>
        </member>
        <member name="T:Xen.Graphics.ResourceUsage">
            <summary>
            Flags that can specify resource usage for <see cref="T:Xen.Graphics.IVertices">Vertex Buffers</see> and <see cref="T:Xen.Graphics.IIndices">Index Buffers</see>.
            </summary>
            <remarks>The <see cref="F:Xen.Graphics.ResourceUsage.Dynamic"/> flag allows for using the SetDirtyRange methods of <see cref="M:Xen.Graphics.IVertices.SetDirtyRange(System.Int32,System.Int32)">Vertex Buffers</see> and <see cref="M:Xen.Graphics.IIndices.SetDirtyRange(System.Int32,System.Int32)">Index Buffers</see></remarks>
        </member>
        <member name="F:Xen.Graphics.ResourceUsage.None">
            <summary>
            Default usage
            </summary>
        </member>
        <member name="F:Xen.Graphics.ResourceUsage.Dynamic">
            <summary>
            Buffer will be allocated in a way optimised for content that changes frequently
            </summary>
        </member>
        <member name="F:Xen.Graphics.ResourceUsage.DynamicSequential">
            <summary>
            [Use with caution] Buffer is allocated as <see cref="F:Xen.Graphics.ResourceUsage.Dynamic"/>. All data writes are assumed to be non-overlapping and performed in order starting from zero. (See remarks for details)
            </summary>
            <remarks>
            <para>This flag is the equivalent of using <see cref="F:Microsoft.Xna.Framework.Graphics.SetDataOptions.Discard"/> for any data changes starting at zero, and <see cref="F:Microsoft.Xna.Framework.Graphics.SetDataOptions.NoOverwrite"/> for the rest.</para>
            <para>Hence it is a requirement that data copies be done in-order, and always starting from zero for their use order.</para>
            <para>The way to use this flag is with a large buffer that gets small amounts of data written over a number of frames (with each small block of data  not overwriting previous, and writes being performed in order starting from zero).</para>
            <para>NOTE: Misuse of this flag can cause unexpected behaviour. What you are seeing on screen can be upto 5 frames behind what the CPU is processing. The driver will assume buffer writes not starting at zero are copying to memory that the application is no longer using. Hence misuse of this flag makes it possible to have the CPU write data to the GPU that will then get used to draw a <i>previous frame</i>. If such a case occurs without using this flag, the CPU will wait for the GPU to catch up, so the copy does not overwrite data that may be in use (this can cause a significant pipeline stall)</para>
            <para>IMPORTANT: Also note, due to the usage cases for DynamicSequential, when the buffer is created it's data will not be automatically filled. A call to SetDirtyRange() will be required first.</para>
            </remarks>
        </member>
        <member name="F:Xen.Graphics.ResourceUsage.Readable">
            <summary>
            The buffer will be Read/Write. This flag is required for calling <see cref="M:Xen.Graphics.IVertices.TryExtractVertexData``1(Microsoft.Xna.Framework.Graphics.VertexElementUsage,System.Int32,``0[])"/>
            </summary>
        </member>
        <member name="T:Xen.Graphics.DrawStateProperties">
            <summary>
            A class for exposing properties of the DrawState class that may be less useful, but still desirable.
            </summary>
        </member>
        <member name="P:Xen.Graphics.DrawStateProperties.ViewMatrix">
            <summary>
            Gets the current View Matrix
            </summary>
        </member>
        <member name="P:Xen.Graphics.DrawStateProperties.ProjectionMatrix">
            <summary>
            Gets the current Projection Matrix
            </summary>
        </member>
        <member name="P:Xen.Graphics.DrawStateProperties.ViewProjectionMatrix">
            <summary>
            Gets the current View Projection Matrix
            </summary>
        </member>
        <member name="P:Xen.Graphics.DrawStateProperties.WorldMatrix">
            <summary>
            Gets the current World Matrix
            </summary>
        </member>
        <member name="P:Xen.Graphics.DrawStateProperties.WorldProjectionMatrix">
            <summary>
            Gets the current World Projection Matrix
            </summary>
        </member>
        <member name="P:Xen.Graphics.DrawStateProperties.WorldViewMatrix">
            <summary>
            Gets the current World View Matrix
            </summary>
        </member>
        <member name="P:Xen.Graphics.DrawStateProperties.WorldViewProjectionMatrix">
            <summary>
            Gets the current World View Projection Matrix
            </summary>
        </member>
        <member name="P:Xen.Graphics.DrawStateProperties.SupportsHardwareInstancing">
            <summary>
            Hardware supports Shader Model 3 hardware instancing, or is running on the xbox360
            </summary>
        </member>
        <member name="P:Xen.Graphics.DrawStateProperties.FrameIndex">
            <summary>Gets the frame index (incremented every time <see cref="M:Xen.Application.Frame(Xen.FrameState)"/> is called)</summary>
        </member>
        <member name="P:Xen.Graphics.DrawStateProperties.WhiteTexture">
            <summary>
            A generic texture that is solid white
            </summary>
        </member>
        <member name="P:Xen.Graphics.DrawStateProperties.FlatNormalMapTexture">
            <summary>
            A generic texture that is solid RGB 0.5,0.5,1.0 - which can be used as a stand in for a normal map
            </summary>
        </member>
        <member name="P:Xen.Graphics.DrawStateProperties.BlackTexture">
            <summary>
            A generic texture that is solid black
            </summary>
        </member>
        <member name="T:Xen.XnaDrawableGameComponentWrapper">
            <summary>
            Wrapper for placement of an XNA GameComponent in the main list, while letting it be drawn in a DrawTarget.
            </summary>
        </member>
        <member name="T:Xen.XnaExtensions">
            <summary>
            Static extensions class providing Xen compatible methods to XNA classes
            </summary>
        </member>
        <member name="M:Xen.XnaExtensions.Draw(Microsoft.Xna.Framework.Graphics.VertexBuffer,Xen.DrawState,Microsoft.Xna.Framework.Graphics.IndexBuffer,Microsoft.Xna.Framework.Graphics.PrimitiveType,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            [XEN EXTENSION] Draw an XNA vertex buffer
            </summary>
        </member>
        <member name="M:Xen.XnaExtensions.Draw(Microsoft.Xna.Framework.Graphics.VertexBuffer,Xen.DrawState,Microsoft.Xna.Framework.Graphics.IndexBuffer,Microsoft.Xna.Framework.Graphics.PrimitiveType)">
            <summary>
            [XEN EXTENSION] Draw an XNA vertex buffer
            </summary>
        </member>
        <member name="M:Xen.XnaExtensions.DrawBlending(Microsoft.Xna.Framework.Graphics.VertexBuffer,Xen.DrawState,Microsoft.Xna.Framework.Graphics.IndexBuffer,Microsoft.Xna.Framework.Graphics.PrimitiveType,Xen.Graphics.AnimationTransformArray,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            [XEN EXTENSION] Draw an XNA vertex buffer, with blended animation
            </summary>
        </member>
        <member name="M:Xen.XnaExtensions.DrawBlending(Microsoft.Xna.Framework.Graphics.VertexBuffer,Xen.DrawState,Microsoft.Xna.Framework.Graphics.IndexBuffer,Microsoft.Xna.Framework.Graphics.PrimitiveType,Xen.Graphics.AnimationTransformArray)">
            <summary>
            [XEN EXTENSION] Draw an XNA vertex buffer, with blended animation
            </summary>
        </member>
        <member name="M:Xen.XnaExtensions.Draw(Microsoft.Xna.Framework.DrawableGameComponent,Xen.DrawState)">
            <summary>
            [XEN EXTENSION] Draw an XNA drawable game component
            </summary>
        </member>
        <member name="M:Xen.XnaExtensions.Draw(Microsoft.Xna.Framework.DrawableGameComponent,Xen.FrameState)">
            <summary>
            [XEN EXTENSION] Draw an XNA drawable game component
            </summary>
        </member>
        <member name="M:Xen.XnaExtensions.Update(Microsoft.Xna.Framework.GameComponent,Xen.UpdateState)">
            <summary>
            [XEN EXTENSION] Update an XNA game component
            </summary>
        </member>
        <member name="T:Xen.Graphics.Stack.CameraStack">
            <summary>
            DrawState camera stack, storing the current and previous cameras. 
            </summary>
        </member>
        <member name="M:Xen.Graphics.Stack.CameraStack.op_Addition(Xen.Graphics.Stack.CameraStack,Xen.Camera.ICamera)">
            <summary>
            Wrapper on Push
            </summary>
        </member>
        <member name="M:Xen.Graphics.Stack.CameraStack.GetCamera">
            <summary>
            Gets the current camera at the top of the camera stack
            </summary>
        </member>
        <member name="M:Xen.Graphics.Stack.CameraStack.GetCameraMatrix(Microsoft.Xna.Framework.Matrix@)">
            <summary>
            Gets the matrix for this camera's position/rotation
            </summary>
            <param name="matrix"></param>
        </member>
        <member name="M:Xen.Graphics.Stack.CameraStack.Push(Xen.Camera.ICamera)">
            <summary>
            Push a new Camera on to the top of the camera stack. All rendering from this call onwards will use the new camera. Restore the previous camera with a call to <see cref="M:Xen.Graphics.Stack.CameraStack.Pop"/>
            </summary>
            <param name="camera"></param>
        </member>
        <member name="M:Xen.Graphics.Stack.CameraStack.Push">
            <summary>
            Push a the current camera to the top of the camera stack. Restore the previous camera with a call to <see cref="M:Xen.Graphics.Stack.CameraStack.Pop"/>
            </summary>
        </member>
        <member name="M:Xen.Graphics.Stack.CameraStack.SetCamera(Xen.Camera.ICamera)">
            <summary>
            Sets the Camera on to the top of the camera stack. All rendering from this call onwards will use the new camera. Restore the previous camera with a call to <see cref="M:Xen.Graphics.Stack.CameraStack.Pop"/>
            </summary>
            <param name="camera"></param>
        </member>
        <member name="M:Xen.Graphics.Stack.CameraStack.Pop">
            <summary>
            Restores the last Camera stored with a call to <see cref="M:Xen.Graphics.Stack.CameraStack.Push(Xen.Camera.ICamera)"/>
            </summary>
        </member>
        <member name="M:Xen.Graphics.Stack.CameraStack.GetViewMatrix(Microsoft.Xna.Framework.Matrix@)">
            <summary>
            <para>Gets the current view matrix</para>
            <para>The view matrix is the Inverse of the Camera Matrix (see <see cref="M:Xen.Graphics.Stack.CameraStack.GetCameraMatrix(Microsoft.Xna.Framework.Matrix@)"/></para>
            </summary>
        </member>
        <member name="M:Xen.Graphics.Stack.CameraStack.GetProjectionMatrix(Microsoft.Xna.Framework.Matrix@,Microsoft.Xna.Framework.Vector2@,System.Int32@)">
            <summary>
            Gets the current projection matrix
            </summary>
        </member>
        <member name="M:Xen.Graphics.Stack.CameraStack.GetProjectionMatrix(Microsoft.Xna.Framework.Matrix@,Microsoft.Xna.Framework.Vector2@)">
            <summary>
            Gets the current projection matrix
            </summary>
        </member>
        <member name="M:Xen.Graphics.Stack.CameraStack.GetProjectionMatrix(Microsoft.Xna.Framework.Matrix@,Microsoft.Xna.Framework.Vector2)">
            <summary>
            Gets the current projection matrix
            </summary>
        </member>
        <member name="M:Xen.Graphics.Stack.CameraStack.GetViewMatrix(Microsoft.Xna.Framework.Matrix@,System.Int32@)">
            <summary>
            <para>Gets the current view matrix</para>
            <para>The view matrix is the Inverse of the Camera Matrix (see <see cref="M:Xen.Graphics.Stack.CameraStack.GetCameraMatrix(Microsoft.Xna.Framework.Matrix@)"/></para>
            </summary>
        </member>
        <member name="M:Xen.Graphics.Stack.CameraStack.GetCameraMatrix(Microsoft.Xna.Framework.Matrix@,System.Int32@)">
            <summary>
            Gets the world matrix representing the current camera position and rotation
            </summary>
        </member>
        <member name="M:Xen.Graphics.Stack.CameraStack.GetCameraPosition(Microsoft.Xna.Framework.Vector3@)">
            <summary>
            Gets the camera position in world space
            </summary>
        </member>
        <member name="M:Xen.Graphics.Stack.CameraStack.GetCameraViewDirection(Microsoft.Xna.Framework.Vector3@)">
            <summary>
            Get the direction the camera is looking in
            </summary>
        </member>
        <member name="M:Xen.Graphics.Stack.CameraStack.GetCameraPosition(Microsoft.Xna.Framework.Vector4@,System.Int32@)">
            <summary>
            Gets the camera position in world space
            </summary>
        </member>
        <member name="M:Xen.Graphics.Stack.CameraStack.GetCameraViewDirection(Microsoft.Xna.Framework.Vector4@,System.Int32@)">
            <summary>
            Gets the world matrix representing the current camera position and rotation
            </summary>
        </member>
        <member name="M:Xen.Graphics.Stack.CameraStack.ProjectToTarget(Microsoft.Xna.Framework.Vector3@,Microsoft.Xna.Framework.Vector2@)">
            <summary>
            <para>Projects a position in 3D object space into pixel coordinates of the screen (or current DrawTarget)</para>
            <para>Returns false if the projected point is behind the camera</para>
            </summary>
            <param name="position">3D position in object space to project into screen coordinates</param>
            <param name="screenCoordinate">screen coordinates of the projected position</param>
            <returns>True if the projected position is in front of the camera</returns>
        </member>
        <member name="M:Xen.Graphics.Stack.CameraStack.ProjectWorldToTarget(Microsoft.Xna.Framework.Vector3@,Microsoft.Xna.Framework.Vector2@)">
            <summary>
            <para>Projects a world position in 3D space into pixel coordinates of the screen (or current DrawTarget)</para>
            <para>Returns false if the projected point is behind the camera</para>
            </summary>
            <param name="worldPosition">3D position in world space to project into screen coordinates</param>
            <param name="screenCoordinate">screen coordinates of the projected position</param>
            <returns>True if the projected position is in front of the camera</returns>
        </member>
        <member name="M:Xen.Graphics.Stack.CameraStack.ProjectFromTarget(Microsoft.Xna.Framework.Vector2@,System.Single,Microsoft.Xna.Framework.Vector3@)">
            <summary>
            Projects a position in coordinates of the screen (or current DrawTarget) into a 3D position in world space
            </summary>
            <param name="screenPosition">Position in screen space to project into world space</param>
            <param name="projectDepth">Depth to project from the camera position</param>
            <param name="worldPosition">projected world position</param>
        </member>
        <member name="T:Xen.Graphics.Stack.CameraStack.UsingPop">
            <summary>
            Structure used for a using block with a Push method
            </summary>
        </member>
        <member name="M:Xen.Graphics.Stack.CameraStack.UsingPop.Dispose">
            <summary>Invokes the Pop metohd</summary>
        </member>
        <member name="T:Xen.Graphics.Stack.CullersStack">
            <summary>
            DrawState cullers stack, storing pre and post cullers. 
            </summary>
        </member>
        <member name="M:Xen.Graphics.Stack.CullersStack.PushPreCuller(Xen.ICullPrimitive)">
            <summary>
            Pushes a culler onto the pre-culling stack (pre-culling cull tests occurs <i>before</i> the default onscreen Culler). Fast cull operations are usually added here
            </summary>
        </member>
        <member name="M:Xen.Graphics.Stack.CullersStack.PopPreCuller">
            <summary>
            Removes the culler on the top of the pre-culling stack
            </summary>
        </member>
        <member name="M:Xen.Graphics.Stack.CullersStack.PushPostCuller(Xen.ICullPrimitive)">
            <summary>
            Pushes a culler onto the post-culling stack (post-culling cull tests  occurs <i>after</i> the default onscreen Culler). More expensive culling operations are usually added here
            </summary>
            <param name="culler"></param>
        </member>
        <member name="M:Xen.Graphics.Stack.CullersStack.PopPostCuller">
            <summary>
            Removes the culler on the top of the post-culling stack
            </summary>
        </member>
        <member name="T:Xen.Graphics.Stack.CullersStack.UsingPreCuller">
            <summary>
            Structure used for a using block with a Push method
            </summary>
        </member>
        <member name="M:Xen.Graphics.Stack.CullersStack.UsingPreCuller.Dispose">
            <summary>Invokes the Pop metohd</summary>
        </member>
        <member name="T:Xen.Graphics.Stack.CullersStack.UsingPostCuller">
            <summary>
            Structure used for a using block with a Push method
            </summary>
        </member>
        <member name="M:Xen.Graphics.Stack.CullersStack.UsingPostCuller.Dispose">
            <summary>Invokes the Pop metohd</summary>
        </member>
        <member name="T:Xen.Transform">
            <summary>
            Stores a decomposed matrix transform in 32 bytes, Storing <see cref="T:Microsoft.Xna.Framework.Quaternion"/> <see cref="F:Xen.Transform.Rotation"/>, <see cref="T:Microsoft.Xna.Framework.Vector3"/> <see cref="F:Xen.Transform.Translation"/> and float <see cref="F:Xen.Transform.Scale"/>
            </summary>
        </member>
        <member name="M:Xen.Transform.#ctor(Microsoft.Xna.Framework.Quaternion,Microsoft.Xna.Framework.Vector3,System.Single)">
            <summary>
            Construct a transform
            </summary>
            <param name="rotation"></param>
            <param name="scale"></param>
            <param name="translation"></param>
        </member>
        <member name="M:Xen.Transform.#ctor(Microsoft.Xna.Framework.Matrix@,System.Boolean)">
            <summary>
            Construct this transform from a matrix
            </summary>
            <param name="matrix"></param>
            <param name="performValidityCheck">When true, the matrix will be checked to make sure it will produce a valid transform</param>
        </member>
        <member name="M:Xen.Transform.#ctor(Microsoft.Xna.Framework.Matrix,System.Boolean)">
            <summary>
            Construct this transform from a matrix
            </summary>
            <param name="matrix"></param>
            <param name="performValidityCheck">When true, the matrix will be checked to make sure it will produce a valid transform</param>
        </member>
        <member name="M:Xen.Transform.#ctor(Microsoft.Xna.Framework.Matrix)">
            <summary>Construct this transform from a matrix. Debug builds will validate the matrix</summary>
        </member>
        <member name="M:Xen.Transform.#ctor(Microsoft.Xna.Framework.Matrix@)">
            <summary>Construct this transform from a matrix. Debug builds will validate the matrix</summary>
        </member>
        <member name="F:Xen.Transform.Rotation">
            <summary>
            Rotation <see cref="T:Microsoft.Xna.Framework.Quaternion"/>
            </summary>
        </member>
        <member name="F:Xen.Transform.Translation">
            <summary>
            Translation vector (position)
            </summary>
        </member>
        <member name="F:Xen.Transform.Scale">
            <summary>
            Scale value (usually should be 1)
            </summary>
        </member>
        <member name="M:Xen.Transform.Validate">
            <summary>
            Makes sure nothing is NaN
            </summary>
        </member>
        <member name="M:Xen.Transform.GetMatrix(Microsoft.Xna.Framework.Matrix@)">
            <summary>
            Constructs a <see cref="T:Microsoft.Xna.Framework.Matrix"/> from this transform
            </summary>
            <param name="mat"></param>
        </member>
        <member name="M:Xen.Transform.Interpolate(Xen.Transform@,Xen.Transform@,System.Single,Xen.Transform@)">
            <summary>
            Interpolate between two transforms
            </summary>
            <param name="from"></param>
            <param name="to"></param>
            <param name="amount"></param>
            <param name="result"></param>
        </member>
        <member name="M:Xen.Transform.Interpolate(Xen.Transform@,System.Single)">
            <summary>
            Interpolate to another transform
            </summary>
            <param name="to"></param>
            <param name="amount"></param>
            <returns></returns>
        </member>
        <member name="M:Xen.Transform.Interpolate(Xen.Transform,System.Single)">
            <summary>
            Interpolate to another transform
            </summary>
            <param name="to"></param>
            <param name="amount"></param>
            <returns></returns>
        </member>
        <member name="M:Xen.Transform.#ctor(System.IO.BinaryReader)">
            <summary>
            Construct the transform from a binary source
            </summary>
            <param name="reader"></param>
        </member>
        <member name="M:Xen.Transform.op_Multiply(Xen.Transform,Xen.Transform)">
            <summary>
            Multiply operator
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="M:Xen.Transform.Multiply(Xen.Transform@,Xen.Transform@,Xen.Transform@)">
            <summary>
            Multiply two transforms
            </summary>
            <param name="transform1"></param>
            <param name="transform2"></param>
            <param name="result"></param>
        </member>
        <member name="M:Xen.Transform.Write(System.IO.BinaryWriter)">
            <summary>
            Write the transform as bytes (32 bytes)
            </summary>
            <param name="writer"></param>
        </member>
        <member name="M:Xen.Transform.InterpolateToIdentity(System.Single)">
            <summary>Interpolate this transform towards the identity transform</summary>
        </member>
        <member name="M:Xen.Transform.GetTransformArrayAsMatrix4x3(Xen.Transform[],Microsoft.Xna.Framework.Vector4[])">
            <summary>
            Convert a Transform array into matrix 4x3 format, stored as a Vector4 array
            </summary>
        </member>
        <member name="P:Xen.Transform.Identity">
            <summary>
            Idenity transform
            </summary>
        </member>
        <member name="T:Xen.Graphics.StateFlag">
            <summary>
            Flags to represent aspects of the graphics render state that may be tracked by the application
            </summary>
            <remarks>
            <para>This flag is used to specify what render states has become 'dirty'</para>
            <para>Internally the application keeps track of what it thinks the render state is, to make changing state more efficient.</para>
            <para>By specifying that a render state group is dirty, the application ignores what it thinks the state is, and assumes it is entirely different.</para>
            <para>This forces the application to reapply all states the next time something is drawn.</para>
            </remarks>
        </member>
        <member name="F:Xen.Graphics.StateFlag.None">
            <summary>
            No state flag
            </summary>
        </member>
        <member name="F:Xen.Graphics.StateFlag.AlphaBlend">
            <summary>
            AlphaBlending render states (<see cref="T:Xen.Graphics.AlphaBlendState"/>)
            </summary>
        </member>
        <member name="F:Xen.Graphics.StateFlag.StencilTest">
            <summary>
            Stencil testing render states (<see cref="T:Xen.Graphics.StencilState"/>)
            </summary>
        </member>
        <member name="F:Xen.Graphics.StateFlag.Raster">
            <summary>
            Depth testing, Colour writed and face culling render states (<see cref="T:Xen.Graphics.RasterState"/>)
            </summary>
        </member>
        <member name="F:Xen.Graphics.StateFlag.Shaders">
            <summary>
            Vertex and pixel shaders currently bound (XNA <see cref="T:Microsoft.Xna.Framework.Graphics.Effect"/> objects also change vertex and pixel shaders)
            </summary>
        </member>
        <member name="F:Xen.Graphics.StateFlag.Textures">
            <summary>
            Pixel and vertex shader texture and sampler states
            </summary>
        </member>
        <member name="F:Xen.Graphics.StateFlag.VerticesAndIndices">
            <summary>
            Currently bound vertex streams, vertex declaration and indices
            </summary>
        </member>
        <member name="F:Xen.Graphics.StateFlag.All">
            <summary>
            Every state tracked by the application (Prefer using a combination of the other flags if possible)
            </summary>
        </member>
        <member name="T:Xen.Graphics.Stack.DeviceRenderStateStack">
            <summary>
            Stores the <see cref="T:Xen.Graphics.DeviceRenderState"/> stack. Use <see cref="M:Xen.Graphics.Stack.DeviceRenderStateStack.Set(Xen.Graphics.DeviceRenderState@)"/> or <see cref="M:Xen.Graphics.Stack.DeviceRenderStateStack.Push(Xen.Graphics.DeviceRenderState@)"/> to set the entire render state.
            </summary>
        </member>
        <member name="M:Xen.Graphics.Stack.DeviceRenderStateStack.op_Addition(Xen.Graphics.Stack.DeviceRenderStateStack,Xen.Graphics.DeviceRenderState)">
            <summary>
            Wrapper on the Push method
            </summary>
        </member>
        <member name="M:Xen.Graphics.Stack.DeviceRenderStateStack.op_Addition(Xen.Graphics.Stack.DeviceRenderStateStack,Xen.Graphics.AlphaBlendState)">
            <summary>
            Wrapper on the Push method
            </summary>
        </member>
        <member name="M:Xen.Graphics.Stack.DeviceRenderStateStack.op_Addition(Xen.Graphics.Stack.DeviceRenderStateStack,Xen.Graphics.StencilState)">
            <summary>
            Wrapper on the Push method
            </summary>
        </member>
        <member name="M:Xen.Graphics.Stack.DeviceRenderStateStack.op_Addition(Xen.Graphics.Stack.DeviceRenderStateStack,Xen.Graphics.RasterState)">
            <summary>
            Wrapper on the Push method
            </summary>
        </member>
        <member name="F:Xen.Graphics.Stack.DeviceRenderStateStack.CurrentStencilState">
            <summary>
            Get/Set/Modify the current stencil test render states to be used during rendering
            </summary>
        </member>
        <member name="F:Xen.Graphics.Stack.DeviceRenderStateStack.CurrentBlendState">
            <summary>
            Get/Set/Modify the current alpha blending render states to be used during rendering
            </summary>
        </member>
        <member name="F:Xen.Graphics.Stack.DeviceRenderStateStack.CurrentRasterState">
            <summary>
            Get/Set/Modify the current depth test, colour write and face culling render states to be used during rendering
            </summary>
        </member>
        <member name="F:Xen.Graphics.Stack.DeviceRenderStateStack.CurrentDepthState">
            <summary>
            Get/Set/Modify the current depth render states to be used during rendering
            </summary>
        </member>
        <member name="M:Xen.Graphics.Stack.DeviceRenderStateStack.op_Implicit(Xen.Graphics.Stack.DeviceRenderStateStack)~Xen.Graphics.DeviceRenderState">
            <summary>
            Cast to a <see cref="T:Xen.Graphics.DeviceRenderState"/> implicitly
            </summary>
            <param name="source"></param>
            <returns></returns>
        </member>
        <member name="M:Xen.Graphics.Stack.DeviceRenderStateStack.Push">
            <summary>
            <para>Saves the current render state onto the render state stack. Reset the state back with a call to <see cref="M:Xen.Graphics.Stack.DeviceRenderStateStack.Pop"/></para>
            <para>Note: this method can be used in a 'using() {}' block to automatically call <see cref="M:Xen.Graphics.Stack.DeviceRenderStateStack.Pop"/></para>
            </summary>
            <remarks><para>If you wish to modify the render state temporarily, then it is best to call PushRenderState() before making change, then call <see cref="M:Xen.Graphics.Stack.DeviceRenderStateStack.Pop"/> after rendering is complete.</para><para>This will be a lot more efficient than manually storing the states that are changed</para></remarks>
        </member>
        <member name="M:Xen.Graphics.Stack.DeviceRenderStateStack.Set(Xen.Graphics.DeviceRenderState@)">
            <summary>
            Overwrites the current render state with the provided state. To Save the previous state, see <see cref="M:Xen.Graphics.Stack.DeviceRenderStateStack.Push(Xen.Graphics.DeviceRenderState@)"/>
            </summary>
            <param name="state"></param>
        </member>
        <member name="M:Xen.Graphics.Stack.DeviceRenderStateStack.Push(Xen.Graphics.DeviceRenderState@)">
            <summary>
            <para>Saves the current render state onto the render state stack, then copies the provided render state in. Reset the state back with a call to <see cref="M:Xen.Graphics.Stack.DeviceRenderStateStack.Pop"/></para>
            <para>Note: this method can be used in a 'using() {}' block to automatically call <see cref="M:Xen.Graphics.Stack.DeviceRenderStateStack.Pop"/></para>
            </summary>
            <remarks><para>If you wish to modify the render state temporarily, then it is best to call this method before making change, then call <see cref="M:Xen.Graphics.Stack.DeviceRenderStateStack.Pop"/> after rendering is complete to restore the previous state.</para><para>This will be a lot more efficient than manually storing the states that are changed</para></remarks>
        </member>
        <member name="M:Xen.Graphics.Stack.DeviceRenderStateStack.Push(Xen.Graphics.AlphaBlendState@)">
            <summary>
            <para>Saves the current render state onto the render state stack, then copies the provided alpha blend render state in. Reset the state back with a call to <see cref="M:Xen.Graphics.Stack.DeviceRenderStateStack.Pop"/></para>
            <para>Note: this method can be used in a 'using() {}' block to automatically call <see cref="M:Xen.Graphics.Stack.DeviceRenderStateStack.Pop"/></para>
            </summary>
        </member>
        <member name="M:Xen.Graphics.Stack.DeviceRenderStateStack.Push(Xen.Graphics.StencilState@)">
            <summary>
            <para>Saves the current render state onto the render state stack, then copies the provided stenicl render state in. Reset the state back with a call to <see cref="M:Xen.Graphics.Stack.DeviceRenderStateStack.Pop"/></para>
            <para>Note: this method can be used in a 'using() {}' block to automatically call <see cref="M:Xen.Graphics.Stack.DeviceRenderStateStack.Pop"/></para>
            </summary>
        </member>
        <member name="M:Xen.Graphics.Stack.DeviceRenderStateStack.Push(Xen.Graphics.RasterState@)">
            <summary>
            <para>Saves the current render state onto the render state stack, then copies the provided raster render state in. Reset the state back with a call to <see cref="M:Xen.Graphics.Stack.DeviceRenderStateStack.Pop"/></para>
            <para>Note: this method can be used in a 'using() {}' block to automatically call <see cref="M:Xen.Graphics.Stack.DeviceRenderStateStack.Pop"/></para>
            </summary>
        </member>
        <member name="M:Xen.Graphics.Stack.DeviceRenderStateStack.Push(Xen.Graphics.DepthState@)">
            <summary>
            <para>Saves the current render state onto the render state stack, then copies the provided depth render state in. Reset the state back with a call to <see cref="M:Xen.Graphics.Stack.DeviceRenderStateStack.Pop"/></para>
            <para>Note: this method can be used in a 'using() {}' block to automatically call <see cref="M:Xen.Graphics.Stack.DeviceRenderStateStack.Pop"/></para>
            </summary>
        </member>
        <member name="M:Xen.Graphics.Stack.DeviceRenderStateStack.Push(Xen.Graphics.AlphaBlendState)">
            <summary>
            <para>Saves the current render state onto the render state stack, then copies the provided alpha blend render state in. Reset the state back with a call to <see cref="M:Xen.Graphics.Stack.DeviceRenderStateStack.Pop"/></para>
            <para>Note: this method can be used in a 'using() {}' block to automatically call <see cref="M:Xen.Graphics.Stack.DeviceRenderStateStack.Pop"/></para>
            </summary>
        </member>
        <member name="M:Xen.Graphics.Stack.DeviceRenderStateStack.Push(Xen.Graphics.StencilState)">
            <summary>
            <para>Saves the current render state onto the render state stack, then copies the provided stenicl render state in. Reset the state back with a call to <see cref="M:Xen.Graphics.Stack.DeviceRenderStateStack.Pop"/></para>
            <para>Note: this method can be used in a 'using() {}' block to automatically call <see cref="M:Xen.Graphics.Stack.DeviceRenderStateStack.Pop"/></para>
            </summary>
        </member>
        <member name="M:Xen.Graphics.Stack.DeviceRenderStateStack.Push(Xen.Graphics.RasterState)">
            <summary>
            <para>Saves the current render state onto the render state stack, then copies the provided raster render state in. Reset the state back with a call to <see cref="M:Xen.Graphics.Stack.DeviceRenderStateStack.Pop"/></para>
            <para>Note: this method can be used in a 'using() {}' block to automatically call <see cref="M:Xen.Graphics.Stack.DeviceRenderStateStack.Pop"/></para>
            </summary>
        </member>
        <member name="M:Xen.Graphics.Stack.DeviceRenderStateStack.Push(Xen.Graphics.DepthState)">
            <summary>
            <para>Saves the current render state onto the render state stack, then copies the provided depth render state in. Reset the state back with a call to <see cref="M:Xen.Graphics.Stack.DeviceRenderStateStack.Pop"/></para>
            <para>Note: this method can be used in a 'using() {}' block to automatically call <see cref="M:Xen.Graphics.Stack.DeviceRenderStateStack.Pop"/></para>
            </summary>
        </member>
        <member name="M:Xen.Graphics.Stack.DeviceRenderStateStack.Pop">
            <summary>
            Restores the last <see cref="T:Xen.Graphics.DeviceRenderState"/> saved by a call to <see cref="M:Xen.Graphics.Stack.DeviceRenderStateStack.Push"/>
            </summary>
        </member>
        <member name="M:Xen.Graphics.Stack.DeviceRenderStateStack.InternalSyncToGraphicsDevice">
            <summary>
            Syncs the current cached state to the graphics device.
            <para>This logic is called automatically for all Xen classes and Xna wrappers</para>
            </summary>
        </member>
        <member name="M:Xen.Graphics.Stack.DeviceRenderStateStack.InternalDirtyRenderState(Xen.Graphics.StateFlag)">
            <summary>
            <para>Dirties internally tracked Xen render state caches.</para>
            </summary>
        </member>
        <member name="P:Xen.Graphics.Stack.DeviceRenderStateStack.RenderStackSize">
            <summary>
            Sets the size of the world matrix and render state stacks (default is 128)
            </summary>
        </member>
        <member name="T:Xen.Graphics.Stack.DeviceRenderStateStack.UsingPop">
            <summary>
            Structure used for a using block with a Push method
            </summary>
        </member>
        <member name="M:Xen.Graphics.Stack.DeviceRenderStateStack.UsingPop.Dispose">
            <summary>Invokes the Pop metohd</summary>
        </member>
        <member name="T:Xen.Graphics.DeviceRenderState">
            <summary>
            Stores the state of the most commonly used graphics render states.
            </summary>
        </member>
        <member name="M:Xen.Graphics.DeviceRenderState.#ctor(Xen.Graphics.AlphaBlendState,Xen.Graphics.RasterState,Xen.Graphics.StencilState,Xen.Graphics.DepthState)">
            <summary>
            Construct a complete render state
            </summary>
        </member>
        <member name="F:Xen.Graphics.DeviceRenderState.Stencil">
            <summary>
            Get/Set/Modify the stencil test render states to be used during rendering
            </summary>
        </member>
        <member name="F:Xen.Graphics.DeviceRenderState.Depth">
            <summary>
            Get/Set/Modify the depth buffer states to be used during rendering
            </summary>
        </member>
        <member name="F:Xen.Graphics.DeviceRenderState.Blend">
            <summary>
            Get/Set/Modify the alpha blending render states to be used during rendering
            </summary>
        </member>
        <member name="F:Xen.Graphics.DeviceRenderState.Raster">
            <summary>
            Get/Set/Modify the colour write and face culling render states to be used during rendering
            </summary>
        </member>
        <member name="M:Xen.Graphics.DeviceRenderState.GetHashCode">
            <summary>
            Fast has code of all the render states
            </summary>
            <returns></returns>
        </member>
        <member name="M:Xen.Graphics.DeviceRenderState.Equals(System.Object)">
            <summary></summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="T:Xen.Graphics.AlphaBlendState">
             <summary>
             Packed representation of common Alpha Blending states. 4 bytes
             </summary>
             <remarks>
             <para>When a pixel is drawn, it usually overwrites the existing pixel.</para>
             <para>For example, if you draw a quad in the centre of the screen, drawing that quad draws over the existing pixels on screen. Usually before drawing the quad, you would clear the screen first. If the screen is cleared to black, and the quad is white, the existing black colour values are overwritten with white colour values.</para>
             <para>The existing pixels are known as the 'destination' pixels, and the pixels being written are known as 'source' pixels.</para>
             <para>In the example, the desination pixels are black colour values, while the source pixels are white colour values.</para>
             <code>
             //destination values are written
             destination.rgba = source.rgba;
             </code>
             <para>When alpha blending is enabled, the value that is written is the result of an equation.</para>
             <para>A common alpha blending operation is 'additive' blending, where the source and destination colours are added together (this is commonly used in particle effects such as light flares and fire, as it 'adds' light, and brightens the on screen image (the destination pixels)) :</para>
             <code>
             //additive blending
             destination.rgba = destination.rgba + source.rgba;
             </code>
             <para>In such a case, the pixels already on screen (destination) will mostly stay visible, with the pixels being drawn (source) added to them</para>
             <para></para>
             <para>To set additive blending, the following states should be set:</para>
             <code>
             	AlphaBlendState state = new AlphaBlendState();
            
            		state.BlendOperation   = BlendFunction.Add;		//This is the default value for BlendOperation
            		state.DestinationBlend = Blend.One;				//This is the default value for DestinationBlend
            		state.SourceBlend      = Blend.One;				//This is the default value for SourceBlend
             
            		state.Enabled = true;							//This is not the default value (the default is false)
             
             </code>
             <para>What does this mean? Alpha blending can be more complex than simple additive blending. To understand, you need to know the complete blending equation.</para>
             <para>The actual blending equation is:</para>
             <code>
             destination.rgba = (destination.rgba * DestinationBlend) BlendOperation (source.rgba * SourceBlend);
             </code>
             <para>As can be seen, it's more complex. With the settings used above above, the equation becomes:</para>
             <code>
             //additive blending
             destination.rgba = (destination.rgba * Blend.One) BlendFunction.Add (source.rgba * Blend.One);
             
             //which is...
             destination.rgba = (destination.rgba * 1) + (source.rgba * 1);
             
             //simplified...
             destination.rgba = destination.rgba + source.rgba;
             </code>
             <para>The blend operations and modes control only the mathematical operations used in the equation.</para>
             <para>This simple blending mode works well in a lot of cases, but you can quickly add too much colour. Most render targets (and the screen) are low precision, and cannot store r/g/b/a values greater than 1.0, so addtive blending can quickly lead to 'blown out' effects that clamp to full white (RGB = 1,1,1)</para>
             <para></para>
             <para>An example of a more complex blending mode is Alpha Blending. Not to be confused by the name, 'Alpha Blending' as a blend state and 'Alpha Blending' as a device render state are different things. For clarity, I'll call it 'SourceAlpha blending'</para>
             <para>With SourceAlpha blending, the source pixels store an alpha value that represents how transparent they are. Eg, the texture for leaves on a tree will store an alpha value of 1.0 on the leaf pixels, and a value of 0.0 around them in the 'transparent' pixels.</para>
             <para>To achieve SourceAlpha blending, the blend equation needs to perform a linear interpolation (fade) from the destination (background) to the source (tree leaves). </para>
             <para>A simple linear interpolation is...</para>
             <code>
             finalColour = treeColour * treeAlpha + backgroundColour * (1-treeAlpha)
             </code>
             <para>Or in blend states:</para>
             <code>
             destination.rgba = source.rgba * source.a + destination.rgba * (1-source.a);
             </code>
             <para>Converted to a AlphaBlendState object, this becomes:</para>
             <code>
             	AlphaBlendState state = new AlphaBlendState();
            
            		state.BlendOperation   = BlendFunction.Add;	
            		state.DestinationBlend = Blend.InverseSourceAlpha;				
            		state.SourceBlend      = Blend.SourceAlpha;		
             
            		state.Enabled = true;	
             
             </code>
             <para>Note that 'InverseSourceAlpha' really means 'OneMinusSourceAlpha'. This is important if you use high precision render targets that can store values above 1.0!</para>
             <para></para>
             <para>Also, For advanced use, <see cref="P:Xen.Graphics.AlphaBlendState.SeparateAlphaBlendEnabled"/> can be set to true, doing so allows defining a separate equation just for the alpha channel, like so:</para>
             <code>
             destination.rgb = (destination.rgb * DestinationBlend) BlendOperation (source.rgb * SourceBlend);
             destination.a = (destination.a * DestinationBlendAlpha) BlendOperationAlpha (source.a * SourceBlendAlpha);
             </code>
             <para></para>
             <para>Note: If the blend mode modifies the destination (<see cref="P:Xen.Graphics.AlphaBlendState.DestinationBlend"/> is anything other than <see cref="F:Microsoft.Xna.Framework.Graphics.Blend.One"/>), then drawing pixels in different orders will produce different results. This is especially true if depth writing is still enabled, as drawing the pixel does not completely overwrite the previous colour. For example, if multiple trees are drawn, potentially one on top of the other, then it is best to draw the trees in order from back to front. </para>
             </remarks>
        </member>
        <member name="M:Xen.Graphics.AlphaBlendState.op_Explicit(System.UInt32)~Xen.Graphics.AlphaBlendState">
            <summary></summary>
            <param name="state"></param>
            <returns></returns>
        </member>
        <member name="M:Xen.Graphics.AlphaBlendState.op_Implicit(Xen.Graphics.AlphaBlendState)~System.UInt32">
            <summary></summary>
            <param name="state"></param>
            <returns></returns>
        </member>
        <member name="M:Xen.Graphics.AlphaBlendState.op_Equality(Xen.Graphics.AlphaBlendState,Xen.Graphics.AlphaBlendState)">
            <summary></summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="M:Xen.Graphics.AlphaBlendState.op_Inequality(Xen.Graphics.AlphaBlendState,Xen.Graphics.AlphaBlendState)">
            <summary></summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="M:Xen.Graphics.AlphaBlendState.Equals(System.Object)">
            <summary></summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:Xen.Graphics.AlphaBlendState.GetHashCode">
            <summary>
            Gets the hash code, eqivalent to the internal bitfield
            </summary>
            <returns></returns>
        </member>
        <member name="M:Xen.Graphics.AlphaBlendState.SetToNoBlending">
            <summary>Set the render state to no Alpha Blending, resetting all states (This is not equivalent to setting <see cref="P:Xen.Graphics.AlphaBlendState.Enabled"/> to false, however it has the same effect)</summary>
        </member>
        <member name="M:Xen.Graphics.AlphaBlendState.SetToAlphaBlending">
            <summary>Set the render state to standard Alpha Blending (blending based on the alpha value of the source component, desitination colour is interpolated to the source colour based on source alpha)</summary>
        </member>
        <member name="M:Xen.Graphics.AlphaBlendState.SetToAdditiveBlending">
            <summary>Set the render state to Additive Alpha Blending (blending based on the alpha value of the source component, the desitination colour is added to the source colour modulated by alpha)</summary>
        </member>
        <member name="M:Xen.Graphics.AlphaBlendState.SetToPremodulatedAlphaBlending">
            <summary>Set the render state to Premodulated Alpha Blending (Assumes the source colour data has been premodulated with the inverse of the alpha value, useful for reducing colour bleeding and accuracy problems at alpha edges)</summary>
        </member>
        <member name="M:Xen.Graphics.AlphaBlendState.SetToAlphaAdditiveBlending">
            <summary>Set the render state to Additive Alpha Blending (blending based on the alpha value of the source component, the desitination colour is added to the source colour modulated by alpha)</summary>
        </member>
        <member name="M:Xen.Graphics.AlphaBlendState.SetToAdditiveSaturateBlending">
            <summary>Set the render state to Additive Saturate Blending (the alpha value is ignored, the desitination colour is added to the source colour, however the source colour is multipled by the inverse of the destination colour, preventing the addition from blowing out to pure white (eg, 0.75 + 0.75 * (1-0.75) = 0.9375))</summary>
        </member>
        <member name="M:Xen.Graphics.AlphaBlendState.SetToModulateBlending">
            <summary>Set the render state to Modulate (multiply) Blending (the alpha value is ignored, the desitination colour is multipled with the source colour)</summary>
        </member>
        <member name="M:Xen.Graphics.AlphaBlendState.SetToModulateAddBlending">
            <summary>Set the render state to Modulate Add (multiply+add) Blending (the alpha value is ignored, the desitination colour multipled with the source colour is added to the desitnation colour)</summary>
        </member>
        <member name="M:Xen.Graphics.AlphaBlendState.SetToModulateX2Blending">
            <summary>Set the render state to Modulate (multiply) Blending, scaled by 2 (the alpha value is ignored, the desitination colour is multipled with the source colour, scaled by two)</summary>
        </member>
        <member name="M:Xen.Graphics.AlphaBlendState.#ctor(Microsoft.Xna.Framework.Graphics.Blend,Microsoft.Xna.Framework.Graphics.Blend)">
            <summary>
            Create a alpha blend state with the given source and destination blend modes
            </summary>
            <param name="sourceBlend"></param>
            <param name="destinationBlend"></param>
        </member>
        <member name="P:Xen.Graphics.AlphaBlendState.None">
            <summary>State that disables Alpha Blending</summary>
        </member>
        <member name="P:Xen.Graphics.AlphaBlendState.Alpha">
            <summary>State that enables standard Alpha Blending (blending based on the alpha value of the source component, desitination colour is interpolated to the source colour based on source alpha)</summary>
        </member>
        <member name="P:Xen.Graphics.AlphaBlendState.PremodulatedAlpha">
            <summary>State that enables Premodulated Alpha Blending (Assumes the source colour data has been premodulated with the source alpha value, useful for reducing colour bleeding and accuracy problems at alpha edges)</summary>
        </member>
        <member name="P:Xen.Graphics.AlphaBlendState.AlphaAdditive">
            <summary>State that enables Additive Alpha Blending (blending based on the alpha value of the source component, the desitination colour is added to the source colour modulated by alpha)</summary>
        </member>
        <member name="P:Xen.Graphics.AlphaBlendState.Additive">
            <summary>State that enables standard Additive Blending (the alpha value is ignored, the desitination colour is added to the source colour)</summary>
        </member>
        <member name="P:Xen.Graphics.AlphaBlendState.AdditiveSaturate">
            <summary>State that enables Additive Saturate Blending (the alpha value is ignored, the desitination colour is added to the source colour, however the source colour is multipled by the inverse of the destination colour, preventing the addition from blowing out to pure white (eg, 0.75 + 0.75 * (1-0.75) = 0.9375))</summary>
        </member>
        <member name="P:Xen.Graphics.AlphaBlendState.Modulate">
            <summary>State that enables Modulate (multiply) Blending (the alpha value is ignored, the desitination colour is multipled with the source colour)</summary>
        </member>
        <member name="P:Xen.Graphics.AlphaBlendState.ModulateAdd">
            <summary>State that enables Modulate Add (multiply+add) Blending (the alpha value is ignored, the desitination colour multipled with the source colour is added to the desitnation colour)</summary>
        </member>
        <member name="P:Xen.Graphics.AlphaBlendState.ModulateX2">
            <summary>State that enables Modulate (multiply) Blending, scaled by 2 (the alpha value is ignored, the desitination colour is multipled with the source colour, scaled by two)</summary>
        </member>
        <member name="P:Xen.Graphics.AlphaBlendState.Enabled">
            <summary>
            Gets/Sets if alpha blending is enabled
            </summary>
        </member>
        <member name="P:Xen.Graphics.AlphaBlendState.SeparateAlphaBlendEnabled">
            <summary>
            Gets/Sets if separate alpha blending is enabled (Separate alpha blending applies an alternative blend equation to the alpha channel than the RGB channels). See <see cref="P:Xen.Graphics.AlphaBlendState.BlendOperationAlpha"/>, <see cref="P:Xen.Graphics.AlphaBlendState.SourceBlendAlpha"/> and <see cref="P:Xen.Graphics.AlphaBlendState.DestinationBlendAlpha"/>
            </summary>
        </member>
        <member name="P:Xen.Graphics.AlphaBlendState.BlendOperation">
            <summary>
            Gets/Sets the blending function operation. See <see cref="T:Xen.Graphics.AlphaBlendState"/> remarks for details
            </summary>
        </member>
        <member name="P:Xen.Graphics.AlphaBlendState.BlendOperationAlpha">
            <summary>
            Gets/Sets the blending function operation, this value only effects the alpha channel and only when <see cref="P:Xen.Graphics.AlphaBlendState.SeparateAlphaBlendEnabled"/> is true. See <see cref="T:Xen.Graphics.AlphaBlendState"/> remarks for details
            </summary>
        </member>
        <member name="P:Xen.Graphics.AlphaBlendState.SourceBlend">
            <summary>
            Gets/Sets the blending function source (drawn pixel) input multiply value. See <see cref="T:Xen.Graphics.AlphaBlendState"/> remarks for details
            </summary>
        </member>
        <member name="P:Xen.Graphics.AlphaBlendState.DestinationBlend">
            <summary>
            Gets/Sets the blending function destination (existing pixel) input multiply value. See <see cref="T:Xen.Graphics.AlphaBlendState"/> remarks for details
            </summary>
        </member>
        <member name="P:Xen.Graphics.AlphaBlendState.SourceBlendAlpha">
            <summary>
            Gets/Sets the blending function source (drawn pixel) input multiply value, this value only effects the alpha channel and only when <see cref="P:Xen.Graphics.AlphaBlendState.SeparateAlphaBlendEnabled"/> is true. See <see cref="T:Xen.Graphics.AlphaBlendState"/> remarks for details
            </summary>
        </member>
        <member name="P:Xen.Graphics.AlphaBlendState.DestinationBlendAlpha">
            <summary>
            Gets/Sets the blending function destination (existing pixel) input multiply value, this value only effects the alpha channel and only when <see cref="P:Xen.Graphics.AlphaBlendState.SeparateAlphaBlendEnabled"/> is true. See <see cref="T:Xen.Graphics.AlphaBlendState"/> remarks for details
            </summary>
        </member>
        <member name="T:Xen.Graphics.DepthState">
            <summary>
            Packed representation of Depth Testing states. 1 byte
            </summary>
        </member>
        <member name="M:Xen.Graphics.DepthState.op_Explicit(System.Byte)~Xen.Graphics.DepthState">
            <summary></summary>
        </member>
        <member name="M:Xen.Graphics.DepthState.op_Implicit(Xen.Graphics.DepthState)~System.Int32">
            <summary></summary>
        </member>
        <member name="M:Xen.Graphics.DepthState.op_Equality(Xen.Graphics.DepthState,Xen.Graphics.DepthState)">
            <summary></summary>
        </member>
        <member name="M:Xen.Graphics.DepthState.op_Inequality(Xen.Graphics.DepthState,Xen.Graphics.DepthState)">
            <summary></summary>
        </member>
        <member name="M:Xen.Graphics.DepthState.Equals(System.Object)">
            <summary></summary>
        </member>
        <member name="M:Xen.Graphics.DepthState.GetHashCode">
            <summary>
            Gets the hash code. Returned value is the internal bitfield value
            </summary>
            <returns></returns>
        </member>
        <member name="P:Xen.Graphics.DepthState.DepthTestEnabled">
            <summary>
            Gets/Sets if depth testing is enabled
            </summary>
            <remarks><para>If depth testing is disabled, then pixels will always be drawn, even if they are behind another object on screen.</para></remarks>
        </member>
        <member name="P:Xen.Graphics.DepthState.DepthWriteEnabled">
            <summary>
            Gets/Sets if depth writing is enabled
            </summary>
            <remarks><para>If depth writing is disabled, pixels that are drawn will still go through normal depth testing, however they will not write a new depth value into the depth buffer. This is most useful for transparent effects, and any effect that does not have a physical representation (eg, a light cone, particle effects, etc).</para>
            <para>Usually, 'solid' objects with depth writing enabled will be drawn first. Such as the world, characters, models, etc. Then non-solid and effect geometry is drawn without depth writing. If this order is reversed, the solid geometry can overwrite the effects.</para></remarks>
        </member>
        <member name="P:Xen.Graphics.DepthState.DepthTestFunction">
            <summary>
            Changes the comparsion function used when depth testing. WARNING:  On some video cards, changing this value can disable hierarchical z-buffer optimizations for the rest of the frame
            </summary>
            <remarks>
            <para>Changing the depth test function from Less to Greater midframe is <i>not recommended</i>.</para>
            <para>Changing between <see cref="F:Microsoft.Xna.Framework.Graphics.CompareFunction.LessEqual"/> and <see cref="F:Microsoft.Xna.Framework.Graphics.CompareFunction.Equal"/> is usually OK.</para>
            <para>On newer video cards, keeping the depth test function consistent throughout the frame will still maintain peek effciency, however some older cards are only full speed when using <see cref="F:Microsoft.Xna.Framework.Graphics.CompareFunction.LessEqual"/> or <see cref="F:Microsoft.Xna.Framework.Graphics.CompareFunction.Equal"/></para>
            <para>Setting <see cref="P:Xen.Graphics.DepthState.DepthTestEnabled"/> to false is the preferred to using <see cref="F:Microsoft.Xna.Framework.Graphics.CompareFunction.Always"/>.</para>
            </remarks>
        </member>
        <member name="T:Xen.Graphics.RasterState">
            <summary>
            Packed representation of Colour buffer masking and Backface Cull mode states. 2 bytes
            </summary>
        </member>
        <member name="M:Xen.Graphics.RasterState.op_Explicit(System.UInt16)~Xen.Graphics.RasterState">
            <summary></summary>
            <param name="state"></param>
            <returns></returns>
        </member>
        <member name="M:Xen.Graphics.RasterState.op_Implicit(Xen.Graphics.RasterState)~System.UInt16">
            <summary></summary>
            <param name="state"></param>
            <returns></returns>
        </member>
        <member name="M:Xen.Graphics.RasterState.op_Equality(Xen.Graphics.RasterState,Xen.Graphics.RasterState)">
            <summary></summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="M:Xen.Graphics.RasterState.op_Inequality(Xen.Graphics.RasterState,Xen.Graphics.RasterState)">
            <summary></summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="M:Xen.Graphics.RasterState.Equals(System.Object)">
            <summary></summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:Xen.Graphics.RasterState.GetHashCode">
            <summary>
            Gets the hash code. Returned value is the internal bitfield value
            </summary>
            <returns></returns>
        </member>
        <member name="P:Xen.Graphics.RasterState.ColourWriteMask">
            <summary>
            Gets/Sets a mask for the colour channels (RGBA) that are written to the colour buffer. Set to <see cref="F:Microsoft.Xna.Framework.Graphics.ColorWriteChannels.None"/> to disable all writing to the colour buffer.
            </summary>
        </member>
        <member name="P:Xen.Graphics.RasterState.CullMode">
            <summary>
            Gets/Sets the backface culling render state. Default value of <see cref="F:Microsoft.Xna.Framework.Graphics.CullMode.CullCounterClockwiseFace">CullCounterClockwiseFace</see>
            </summary>
        </member>
        <member name="P:Xen.Graphics.RasterState.FillMode">
            <summary>
            Gets/Sets a mask for the <see cref="P:Xen.Graphics.RasterState.FillMode"/> for the device (eg, <see cref="F:Microsoft.Xna.Framework.Graphics.FillMode.WireFrame"/> or <see cref="F:Microsoft.Xna.Framework.Graphics.FillMode.Solid"/>)
            </summary>
        </member>
        <member name="P:Xen.Graphics.RasterState.MultiSampleAntiAlias">
            <summary>
            Gets/Sets if anti aliasing is enabled
            </summary>
        </member>
        <member name="P:Xen.Graphics.RasterState.ScissorTestEnable">
            <summary>
            Gets/Sets if scissor testing is enabled
            </summary>
        </member>
        <member name="T:Xen.Graphics.StencilState">
            <summary>
            Packed representation of Stencil Testing state. 8 bytes
            </summary>
            <remarks>
            <para>On most systems, the depth buffer is either 32 or 16 bits in size. However, with a 32bit size depth buffer, the accuracy is usually only 24bits. (True 32bit depth buffers are not supported on any DX9 video cards)</para>
            <para>When the depth is 24bits, the remaining 8bits can be used as the stencil buffer (see <see cref="F:Microsoft.Xna.Framework.Graphics.DepthFormat.Depth24Stencil8"/>).</para>
            <para>In this case the stencil buffer is an 8bit integer format, (similar to a single colour in 32bit RGBA). Values range from 0 to 255.</para>
            <para>The difference with a stencil buffer is that operations performed on it are based almost entirely on bitmasks, increments/decrements and swapping values. It acts in a similar way to a .net <see cref="T:System.Byte"/>.</para>
            <para></para>
            <para>The name 'stencil testing' is somewhat misleading as it involves two operations, stencil reading and stencil writing.</para>
            <para>When stencil testing is enabled, both of these are enabled, however the default comparisons and write maskes/options all have no effect.</para>
            <para>For example, to 'mask' an area on screen (eg, to draw into a circle, and only a circle) then then stencil testing can be used in two passes:</para>
            <para>Assuming the stencil buffer is cleared to zero, the circle can be drawn first.</para>
            <para>With stencil testing enabled, the circile is drawn. The stencil reference value (<see cref="P:Xen.Graphics.StencilState.ReferenceValue"/>) is set to 1. The <see cref="P:Xen.Graphics.StencilState.StencilPassOperation"/> is set to <see cref="F:Microsoft.Xna.Framework.Graphics.StencilOperation.Replace"/>, which means the value in the stencil buffer (when the pixel is drawn) will be <i>replaced</i> with the reference value (which is 1). Setting <see cref="P:Xen.Graphics.RasterState.ColourWriteMask"/> to None may be desired to make the circle not visible.</para>
            <para>Next, the scene inside the circle is drawn. With stencil testing enabled, the reference is set to 1 again and the <see cref="P:Xen.Graphics.StencilState.StencilFunction"/> is set to <see cref="F:Microsoft.Xna.Framework.Graphics.CompareFunction.Equal"/>. This way, the stencil function will only pass when the stencil value in the stencil buffer is <i>equal</i> to the <i>reference value</i> of 1. This way nothing outside the circle is drawn.</para>
            <para>Note that the ciricle will still be drawn into the stencil buffer at this stage.</para>
            <para></para>
            <para>Stencil testing has more complex features. The most significant, is that the stencil value can be modified in different ways for three cases.</para>
            <para>These cases are: When the stencil function passes, the stencil function passes but Z-testing fails and finally when the stencil function fails.</para>
            <para>Finally, stencil testing can be configured independantly for backfacing triangles (by setting <see cref="P:Xen.Graphics.StencilState.TwoSidedStencilModeEnabled"/> to true). (Note that <see cref="P:Xen.Graphics.RasterState.CullMode"/> must also be set to None for this to take effect).</para>
            <para></para>
            <para>Stencil testing can be used for some very complex effects, such as stencil shadows.</para>
            <para>An example is determining how many pixels are within a <i>closed convex</i> volume (such as a sphere or cube) that does not intersect the near or far clip plane. Assuming a stencil buffer cleared to zero:</para>
            <para>In such a case, drawing the volume (with colour writes <i>and</i> depth writes disabled) and setting the stencil pass operation to <see cref="F:Microsoft.Xna.Framework.Graphics.StencilOperation.Increment"/> and the stencil <i>backface z-fail</i> stencil operation to <see cref="F:Microsoft.Xna.Framework.Graphics.StencilOperation.Decrement"/> will leave the stencil buffer unchanged for all pixels that are within the volume.</para>
            <para>Drawing the volume again, with stencil function set to Equal to a reference value of 0, only those existing pixels within the volume will be drawn.</para>
            </remarks>
        </member>
        <member name="M:Xen.Graphics.StencilState.op_Explicit(System.UInt64)~Xen.Graphics.StencilState">
            <summary></summary>
            <param name="state"></param>
            <returns></returns>
        </member>
        <member name="M:Xen.Graphics.StencilState.op_Implicit(Xen.Graphics.StencilState)~System.UInt64">
            <summary></summary>
            <param name="state"></param>
            <returns></returns>
        </member>
        <member name="M:Xen.Graphics.StencilState.op_Equality(Xen.Graphics.StencilState,Xen.Graphics.StencilState)">
            <summary></summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="M:Xen.Graphics.StencilState.op_Inequality(Xen.Graphics.StencilState,Xen.Graphics.StencilState)">
            <summary></summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="M:Xen.Graphics.StencilState.Equals(System.Object)">
            <summary></summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:Xen.Graphics.StencilState.GetHashCode">
            <summary>
            Gets the hash code. Returned value is the bitwise XOR of the two internal bitfields.
            </summary>
            <returns></returns>
        </member>
        <member name="P:Xen.Graphics.StencilState.Enabled">
            <summary>
            Gets/Sets if stencil testing is enabled
            </summary>
            <remarks>See <see cref="T:Xen.Graphics.StencilState"/> remarks for details</remarks>
        </member>
        <member name="P:Xen.Graphics.StencilState.TwoSidedStencilModeEnabled">
            <summary>
            Gets/Sets if using independant stencil testing functions/operations for back and front facing triangles is enabled
            </summary>
            <remarks>See <see cref="T:Xen.Graphics.StencilState"/> remarks for details</remarks>
        </member>
        <member name="P:Xen.Graphics.StencilState.StencilPassZFailOperation">
            <summary>
            Gets/Sets the operation performed on the stencil buffer is the <see cref="P:Xen.Graphics.StencilState.StencilFunction"/> passes, the but depth test fails
            </summary>
            <remarks>See <see cref="T:Xen.Graphics.StencilState"/> remarks for details</remarks>
        </member>
        <member name="P:Xen.Graphics.StencilState.StencilPassOperation">
            <summary>
            Gets/Sets the operation performed on the stencil buffer is the <see cref="P:Xen.Graphics.StencilState.StencilFunction"/> and depth test pass
            </summary>
            <remarks>See <see cref="T:Xen.Graphics.StencilState"/> remarks for details</remarks>
        </member>
        <member name="P:Xen.Graphics.StencilState.StencilFailOperation">
            <summary>
            Gets/Sets the operation performed on the stencil buffer is the <see cref="P:Xen.Graphics.StencilState.StencilFunction"/> fails
            </summary>
            <remarks>See <see cref="T:Xen.Graphics.StencilState"/> remarks for details</remarks>
        </member>
        <member name="P:Xen.Graphics.StencilState.BackfaceStencilPassZFailOperation">
            <summary>
            Gets/Sets the operation performed on the stencil buffer is the <see cref="P:Xen.Graphics.StencilState.StencilFunction"/> passes, the but depth test fails when the pixel being drawn is from a backfacing triangle and <see cref="P:Xen.Graphics.StencilState.TwoSidedStencilModeEnabled"/> is true
            </summary>
            <remarks>See <see cref="T:Xen.Graphics.StencilState"/> remarks for details</remarks>
        </member>
        <member name="P:Xen.Graphics.StencilState.BackfaceStencilPassOperation">
            <summary>
            Gets/Sets the operation performed on the stencil buffer is the <see cref="P:Xen.Graphics.StencilState.StencilFunction"/> and the depth test pass, when the pixel being drawn is from a backfacing triangle and <see cref="P:Xen.Graphics.StencilState.TwoSidedStencilModeEnabled"/> is true
            </summary>
            <remarks>See <see cref="T:Xen.Graphics.StencilState"/> remarks for details</remarks>
        </member>
        <member name="P:Xen.Graphics.StencilState.BackfaceStencilFailOperation">
            <summary>
            Gets/Sets the operation performed on the stencil buffer is the <see cref="P:Xen.Graphics.StencilState.StencilFunction"/> fails, when the pixel being drawn is from a backfacing triangle and <see cref="P:Xen.Graphics.StencilState.TwoSidedStencilModeEnabled"/> is true
            </summary>
            <remarks>See <see cref="T:Xen.Graphics.StencilState"/> remarks for details</remarks>
        </member>
        <member name="P:Xen.Graphics.StencilState.StencilFunction">
            <summary>
            Gets/Sets the comparison function performed with the value in the stencil buffer and the <see cref="P:Xen.Graphics.StencilState.ReferenceValue"/>
            </summary>
            <remarks>See <see cref="T:Xen.Graphics.StencilState"/> remarks for details</remarks>
        </member>
        <member name="P:Xen.Graphics.StencilState.BackfaceStencilFunction">
            <summary>
            Gets/Sets the comparison function performed with the value in the stencil buffer and the <see cref="P:Xen.Graphics.StencilState.ReferenceValue"/>, when the pixel being drawn is from a backfacing triangle and <see cref="P:Xen.Graphics.StencilState.TwoSidedStencilModeEnabled"/> is true
            </summary>
            <remarks>See <see cref="T:Xen.Graphics.StencilState"/> remarks for details</remarks>
        </member>
        <member name="P:Xen.Graphics.StencilState.ReferenceValue">
            <summary>
            Gets/Sets the reference value used in the <see cref="P:Xen.Graphics.StencilState.StencilFunction"/> comparison
            </summary>
            <remarks>See <see cref="T:Xen.Graphics.StencilState"/> remarks for details</remarks>
        </member>
        <member name="P:Xen.Graphics.StencilState.StencilReadMask">
            <summary>
            Gets/Sets a bitmask used during stencil buffer reads. The default value is 255 (full mask).
            </summary>
            <remarks>See <see cref="T:Xen.Graphics.StencilState"/> remarks for details</remarks>
        </member>
        <member name="P:Xen.Graphics.StencilState.StencilWriteMask">
            <summary>
            Gets/Sets a bitmask used during stencil buffer writes. The default value is 255 (full mask).
            </summary>
            <remarks>See <see cref="T:Xen.Graphics.StencilState"/> remarks for details</remarks>
        </member>
        <member name="T:Xen.Graphics.IVertices">
            <summary>
            Interface to a vertex buffer. Stores raw geometry data for vertices (eg, position, colour, etc)
            </summary>
        </member>
        <member name="M:Xen.Graphics.IVertices.Draw(Xen.DrawState,Xen.Graphics.IIndices,Microsoft.Xna.Framework.Graphics.PrimitiveType)">
            <summary>
            Draw the buffer
            </summary>
            <param name="state"></param>
            <param name="indices">Indices to use when drawing (may be null)</param>
            <param name="primitiveType">Primitive type to use when drawing the buffer</param>
        </member>
        <member name="M:Xen.Graphics.IVertices.Draw(Xen.DrawState,Xen.Graphics.IIndices,Microsoft.Xna.Framework.Graphics.PrimitiveType,System.Int32,System.Int32,System.Int32)">
            <summary>
            Draw the buffer with extended parametres
            </summary>
            <param name="state"></param>
            <param name="indices">Indices to use when drawing (may be null)</param>
            <param name="primitiveType">Primitive type to use when drawing the buffer</param>
            <param name="primitveCount">The number of primitives to draw</param>
            <param name="startIndex">The start index in the index buffer (defaults to the first index - 0)</param>
            <param name="vertexOffset">Starting offset into the vertex buffer (defaults to the first vertex - 0)</param>
        </member>
        <member name="M:Xen.Graphics.IVertices.DrawInstances(Xen.DrawState,Xen.Graphics.IIndices,Microsoft.Xna.Framework.Graphics.PrimitiveType,Xen.Graphics.InstanceBuffer)">
            <summary>
            Draw multiple instances of the vertex buffer
            </summary>
            <param name="state"></param>
            <param name="indices">Indices to use when drawing (may be null)</param>
            <param name="primitiveType">Primitive type to use when drawing the buffer</param>
            <param name="instances">A buffer providing a list of instance world matrices to draw</param>
        </member>
        <member name="M:Xen.Graphics.IVertices.DrawInstances(Xen.DrawState,Xen.Graphics.IIndices,Microsoft.Xna.Framework.Graphics.PrimitiveType,Microsoft.Xna.Framework.Matrix[],System.Int32)">
            <summary>
            Draw multiple instances of the vertex buffer
            </summary>
            <param name="state"></param>
            <param name="indices">Indices to use when drawing (may be null)</param>
            <param name="primitiveType">Primitive type to use when drawing the buffer</param>
            <param name="instances">An array providing a list of instance world matrices to draw</param>
            <param name="count">The number of instances to draw</param>
        </member>
        <member name="M:Xen.Graphics.IVertices.DrawBlending(Xen.DrawState,Xen.Graphics.IIndices,Microsoft.Xna.Framework.Graphics.PrimitiveType,Xen.Graphics.AnimationTransformArray)">
            <summary>
            Draw the buffer using weighted vertex blending (animation)
            </summary>
            <param name="state"></param>
            <param name="indices">Indices to use when drawing (may be null)</param>
            <param name="primitiveType">Primitive type to use when drawing the buffer</param>
            <param name="animationTransforms">A buffer providing a list of animation transform matrices</param>
        </member>
        <member name="M:Xen.Graphics.IVertices.DrawBlending(Xen.DrawState,Xen.Graphics.IIndices,Microsoft.Xna.Framework.Graphics.PrimitiveType,Xen.Graphics.AnimationTransformArray,System.Int32,System.Int32,System.Int32)">
            <summary>
            Draw the buffer using weighted vertex blending (animation) and extended parametres
            </summary>
            <param name="state"></param>
            <param name="indices">Indices to use when drawing (may be null)</param>
            <param name="primitiveType">Primitive type to use when drawing the buffer</param>
            <param name="primitveCount">The number of primitives to draw</param>
            <param name="startIndex">The start index in the index buffer (defaults to the first index - 0)</param>
            <param name="vertexOffset">Starting offset into the vertex buffer (defaults to the first vertex - 0)</param>
            <param name="animationTransforms">A buffer providing a list of animation transform matrices</param>
        </member>
        <member name="M:Xen.Graphics.IVertices.SetDirty">
            <summary>
            Tells the buffer that the source data it was created with has changed (Requires that <see cref="P:Xen.Graphics.IVertices.ResourceUsage"/> is set to <see cref="F:Xen.Graphics.ResourceUsage.Dynamic"/>)
            </summary>
        </member>
        <member name="M:Xen.Graphics.IVertices.SetDirtyRange(System.Int32,System.Int32)">
            <summary>
            Tells the buffer that the source data it was created with has changed in the specified range (Requires that <see cref="P:Xen.Graphics.IVertices.ResourceUsage"/> is set to <see cref="F:Xen.Graphics.ResourceUsage.Dynamic"/>)
            </summary>
            <param name="count">number of elements that should be updated</param>
            <param name="startIndex"></param>
        </member>
        <member name="M:Xen.Graphics.IVertices.Warm(Xen.IState)">
            <summary>
            Preload (warm) the resource before its first use
            </summary>
            <param name="state"></param>
        </member>
        <member name="M:Xen.Graphics.IVertices.Warm(Xen.Application)">
            <summary>
            Preload (warm) the resource before its first use
            </summary>
            <param name="application"></param>
        </member>
        <member name="M:Xen.Graphics.IVertices.TryExtractVertexData``1(Microsoft.Xna.Framework.Graphics.VertexElementUsage,System.Int32,``0[])">
            <summary>
            Attempt to extract vertex data for a specific vertex element type from the internal vertex data
            <para>Note: This method requires the IVertices object has been warmed, and that it has ResourceUsage marked as 'Readable'</para>
            </summary>
            <typeparam name="T"></typeparam>
            <param name="usage">The element to extract, eg <see cref="F:Microsoft.Xna.Framework.Graphics.VertexElementUsage.Position"/></param>
            <param name="usageIndex">The usage index of the element to extract, typically zero (eg, TEXCOORD3 would have a usage index of 3)</param>
            <param name="output">An array large enough to store the output data</param>
            <returns>Returns true if the data has been written</returns>
        </member>
        <member name="P:Xen.Graphics.IVertices.Count">
            <summary>
            Number of vertices
            </summary>
            <remarks>returns -1 if currently not known. This value will be updated when the buffer is processed</remarks>
        </member>
        <member name="P:Xen.Graphics.IVertices.Stride">
            <summary>
            Byte stride of the vertex data
            </summary>
        </member>
        <member name="P:Xen.Graphics.IVertices.ResourceUsage">
            <summary>
            Gets or Sets the resource usage of the buffer. Set to <see cref="P:Xen.Graphics.IVertices.ResourceUsage"/>.Dynamic to allow use of <see cref="M:Xen.Graphics.IVertices.SetDirtyRange(System.Int32,System.Int32)"/>
            </summary>
        </member>
        <member name="P:Xen.Graphics.IVertices.VertexType">
            <summary>
            Gets the type of the vertex contents
            </summary>
        </member>
        <member name="T:Xen.Graphics.Vertices`1">
            <summary>
            Generic vertex buffer, automatically copies data and sets up a <see cref="T:Microsoft.Xna.Framework.Graphics.VertexDeclaration"/> object.
            </summary>
            <remarks>
            <para>Vertices objects are created by passing in the vertex data to the constructor.</para>
            <para>There are two constructors, one for IEnumerable data and a params T[] constructor, for for directly passing in values.</para>
            <para>The class knows about common types like the generic List class.</para>
            <para>Once created, the vertices object can be used. No further setup is required.</para>
            <para></para>
            <para>
            The vertices class will examine the array data type and construct a vertex declaration automatically. (Provided the structure members are public, are hardware supported types and are logically named). If this automatic generation fails, then the <see cref="T:Xen.Graphics.VertexElementAttribute"/> attribute can be used to exactly specify structure layout.</para><para>See <see cref="T:Xen.Graphics.VertexElementAttribute"/> for more details.
            </para>
            <example>
            <para>Using the existing XNA vertex structures to create four vertices:</para>
            <code>
            IList&lt;VertexPositionColor&gt; items = new List&lt;VertexPositionColor&gt;();
            items.Add(new VertexPositionColor(new Vector3(0,0,0), Color.Red));
            items.Add(new VertexPositionColor(new Vector3(0,1,0), Color.Green));
            items.Add(new VertexPositionColor(new Vector3(1,1,0), Color.Green));
            items.Add(new VertexPositionColor(new Vector3(1,0,0), Color.Red));
            
            IVertices verts = new Vertices&lt;VertexPositionColor&gt;(items);
            </code>
            <para>Using the params constructor:</para>
            <code>
            IVertices verts = new Vertices&lt;VertexPositionColor&gt;(
            	new VertexPositionColor(new Vector3(0,0,0), Color.Red),
            	new VertexPositionColor(new Vector3(0,1,0), Color.Green),
            	new VertexPositionColor(new Vector3(1,1,0), Color.Green),
            	new VertexPositionColor(new Vector3(1,0,0), Color.Red));
            </code>
            </example>
            <para></para>
            <para>To create a dynamic vertex buffer, set the <see cref="P:Xen.Graphics.Vertices`1.ResourceUsage"/> of the buffer to <see cref="P:Xen.Graphics.Vertices`1.ResourceUsage"/>.Dynamic before it's used</para>
            <example>
            <code>
            verts = new new Vertices&lt;VertexPositionColor&gt;(items);
            verts.ResourceUsage = ResourceUsage.Dynamic;
            </code></example>
            <para>When a buffer is allocated dynamically, you can tell the buffer it's source data has changed by calling <see cref="M:Xen.Graphics.IVertices.SetDirty"/> or <see cref="M:Xen.Graphics.IVertices.SetDirtyRange(System.Int32,System.Int32)"/>. (The source data is the collection passed into the constructor). Internally the vertices object only keeps a weak reference to the source data.</para>
            </remarks>
            <typeparam name="VertexType"></typeparam>
        </member>
        <member name="M:Xen.Graphics.Vertices`1.CreateRawDataVertices(`0[],Microsoft.Xna.Framework.Graphics.VertexElement[])">
            <summary>
            [NOT VALIDATED] Use with caution. No validation is performed by this method. Creates a vertex buffer from a raw data array, using a user specified <see cref="T:Microsoft.Xna.Framework.Graphics.VertexElement"/> array.
            </summary>
            <param name="data"></param>
            <param name="elements"></param>
            <returns></returns>
            <remarks>This method is only here to get around some limitations of the XNA content pipeline</remarks>
        </member>
        <member name="M:Xen.Graphics.Vertices`1.CreateRawDataVertices(Microsoft.Xna.Framework.Graphics.VertexBuffer,Microsoft.Xna.Framework.Graphics.VertexElement[])">
            <summary>
            [NOT VALIDATED] Use with caution. No validation is performed by this method. Creates a vertex buffer from a raw data array, using a user specified <see cref="T:Microsoft.Xna.Framework.Graphics.VertexElement"/> array.
            </summary>
            <remarks>This method is only here to get around some limitations of the XNA content pipeline</remarks>
        </member>
        <member name="M:Xen.Graphics.Vertices`1.CreateSingleElementVertices(`0[],Microsoft.Xna.Framework.Graphics.VertexElementUsage,System.Int32)">
            <summary>
            <para>Creates a vertex buffer that will map an array of float or vector primitives to a specified Vertex Usage and index</para>
            </summary>
            <param name="data"></param>
            <param name="elementUsage"></param>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:Xen.Graphics.Vertices`1.#ctor(`0[])">
            <summary>
            Params Array Constructor
            </summary>
            <param name="vertices">vertex data containing vertices</param>
        </member>
        <member name="M:Xen.Graphics.Vertices`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Collection constructor
            </summary>
            <param name="vertices">vertex data</param>
        </member>
        <member name="M:Xen.Graphics.Vertices`1.Finalize">
            <summary>Finalizer, calls dispose.</summary>
        </member>
        <member name="M:Xen.Graphics.Vertices`1.SetDirty">
            <summary>
            Call when source vertex data has changed and the vertex buffer requires updating.
            </summary>
            <remarks><see cref="P:Xen.Graphics.Vertices`1.ResourceUsage"/> must be set to <see cref="T:Xen.Graphics.ResourceUsage"/>.Dynamic</remarks>
        </member>
        <member name="M:Xen.Graphics.Vertices`1.SetDirtyRange(System.Int32,System.Int32)">
            <summary>
            Call when source vertex data has changed with a given range and the vertex buffer requires updating.
            </summary>
            <remarks><see cref="P:Xen.Graphics.Vertices`1.ResourceUsage"/> must be set to <see cref="T:Xen.Graphics.ResourceUsage"/>.Dynamic</remarks>
        </member>
        <member name="M:Xen.Graphics.Vertices`1.Draw(Xen.DrawState,Xen.Graphics.IIndices,Microsoft.Xna.Framework.Graphics.PrimitiveType)">
            <summary>
            Draw the vertices as primitives, using an optional index buffer (indices)
            </summary>
            <param name="state"></param>
            <param name="indices">indices to use when drawing (may be null)</param>
            <param name="primitiveType">Primitive type to draw, eg PrimitiveType.TriangleList</param>
            <remarks></remarks>
        </member>
        <member name="M:Xen.Graphics.Vertices`1.Draw(Xen.DrawState,Xen.Graphics.IIndices,Microsoft.Xna.Framework.Graphics.PrimitiveType,System.Int32,System.Int32,System.Int32)">
            <summary>
            Draw the vertices as primitives with extended parametres, using an optional index buffer (indices)
            </summary>
            <param name="state"></param>
            <param name="indices">indices to use when drawing (may be null)</param>
            <param name="primitiveType">Primitive type to use when drawing the buffer</param>
            <param name="primitveCount">The number of primitives to draw</param>
            <param name="startIndex">The start index in the index buffer (defaults to the first index - 0)</param>
            <param name="vertexOffset">Starting offset into the vertex buffer (defaults to the first vertex - 0)</param>
        </member>
        <member name="M:Xen.Graphics.Vertices`1.DrawBlending(Xen.DrawState,Xen.Graphics.IIndices,Microsoft.Xna.Framework.Graphics.PrimitiveType,Xen.Graphics.AnimationTransformArray)">
            <summary>
            Draw the vertices as primitives using weighted vertex blending (animation), using an optional index buffer (indices)
            </summary>
            <param name="state"></param>
            <param name="indices">indices to use when drawing (may be null)</param>
            <param name="primitiveType">Primitive type to draw, eg PrimitiveType.TriangleList</param>
            <param name="animationTransforms">A buffer providing a list of animation transform matrices</param>
            <remarks></remarks>
        </member>
        <member name="M:Xen.Graphics.Vertices`1.DrawBlending(Xen.DrawState,Xen.Graphics.IIndices,Microsoft.Xna.Framework.Graphics.PrimitiveType,Xen.Graphics.AnimationTransformArray,System.Int32,System.Int32,System.Int32)">
            <summary>
            Draw the vertices as primitives using weighted vertex blending (animation) and extended parametres, using an optional index buffer (indices)
            </summary>
            <param name="state"></param>
            <param name="indices">indices to use when drawing (may be null)</param>
            <param name="primitiveType">Primitive type to use when drawing the buffer</param>
            <param name="primitveCount">The number of primitives to draw</param>
            <param name="startIndex">The start index in the index buffer (defaults to the first index - 0)</param>
            <param name="vertexOffset">Starting offset into the vertex buffer (defaults to the first vertex - 0)</param>
            <param name="animationTransforms">A buffer providing a list of animation transform matrices</param>
        </member>
        <member name="M:Xen.Graphics.Vertices`1.DrawInstances(Xen.DrawState,Xen.Graphics.IIndices,Microsoft.Xna.Framework.Graphics.PrimitiveType,Xen.Graphics.InstanceBuffer)">
            <summary>
            Draw multiple instances of the vertex buffer
            </summary>
            <param name="state"></param>
            <param name="indices">Indices to use when drawing (may be null)</param>
            <param name="primitiveType">Primitive type to use when drawing the buffer</param>
            <param name="instances">A buffer providing a list of instance world matrices to draw</param>
        </member>
        <member name="M:Xen.Graphics.Vertices`1.DrawInstances(Xen.DrawState,Xen.Graphics.IIndices,Microsoft.Xna.Framework.Graphics.PrimitiveType,Microsoft.Xna.Framework.Matrix[],System.Int32)">
            <summary>
            Draw multiple instances of the vertex buffer
            </summary>
            <param name="state"></param>
            <param name="indices">Indices to use when drawing (may be null)</param>
            <param name="primitiveType">Primitive type to use when drawing the buffer</param>
            <param name="instances">An array providing a list of instance world matrices to draw</param>
            <param name="count">The number of instances to draw</param>
        </member>
        <member name="M:Xen.Graphics.Vertices`1.Dispose">
            <summary>
            Dispose all graphics resources
            </summary>
        </member>
        <member name="P:Xen.Graphics.Vertices`1.ResourceUsage">
            <summary>
            Gets/Sets the <see cref="P:Xen.Graphics.Vertices`1.ResourceUsage"/> of the vertices
            </summary>
            <remarks>This value may only be set before the resource's first use</remarks>
        </member>
        <member name="P:Xen.Graphics.Vertices`1.Count">
            <summary>
            Number of vertices stored in the buffer, -1 if not yet known
            </summary>
        </member>
        <member name="P:Xen.Graphics.Vertices`1.Stride">
            <summary>
            Byte stride of each vertex
            </summary>
        </member>
        <member name="T:Xen.Graphics.AnimationTransformArray">
            <summary>
            Stores a list of animation transforms, stored in float4x3 format
            </summary>
        </member>
        <member name="M:Xen.Graphics.AnimationTransformArray.#ctor(System.Int32)">
            <summary>
            Construct the hierachy from a bone count
            </summary>
        </member>
        <member name="M:Xen.Graphics.AnimationTransformArray.#ctor(Xen.Transform[])">
            <summary>
            Construct the hierachy from a set of bone transforms
            </summary>
        </member>
        <member name="M:Xen.Graphics.AnimationTransformArray.#ctor(Microsoft.Xna.Framework.Matrix[])">
            <summary>
            Construct the hierachy from a set of bone transforms
            </summary>
        </member>
        <member name="M:Xen.Graphics.AnimationTransformArray.UpdateTransformArray(Xen.Transform[])">
            <summary>
            Update the transform data
            </summary>
        </member>
        <member name="M:Xen.Graphics.AnimationTransformArray.UpdateTransformArray(Xen.Graphics.AnimationTransformArray,System.UInt32[])">
            <summary>
            Update the transform data, by remapping another transform array
            </summary>
        </member>
        <member name="M:Xen.Graphics.AnimationTransformArray.GetBoneMatrix(System.Int32,Microsoft.Xna.Framework.Matrix@)">
            <summary>
            Gets the matrix for the given bone
            </summary>
        </member>
        <member name="M:Xen.Graphics.AnimationTransformArray.UpdateTransformArray(Microsoft.Xna.Framework.Matrix[])">
            <summary>
            Update the transform data
            </summary>
        </member>
        <member name="M:Xen.Graphics.AnimationTransformArray.ClearTransformArray">
            <summary>
            Resets the transform to an identiy state
            </summary>
        </member>
        <member name="M:Xen.Graphics.AnimationTransformArray.HasChanged(System.Int32@)">
            <summary>
            Returns true if the animation data has a different change index
            </summary>
        </member>
        <member name="P:Xen.Graphics.AnimationTransformArray.MatrixData">
            <summary>
            Stored matrix data in 4x3 format. Returns null if in a cleared state.
            </summary>
        </member>
        <member name="P:Xen.Graphics.AnimationTransformArray.IsIdentiyState">
            <summary>
            Returns true when the transform array is in an identity / cleared state
            </summary>
        </member>
        <member name="T:Xen.XNALogic">
            <summary>
            This class wraps either an XNAGameAppWrapper (which wraps the XNA Game class) or XNAWinFormsAppWrapper, which wraps a windows form. Either class is presented as the same common class
            </summary>
        </member>
        <member name="M:Xen.XNALogic.Run">
            <summary></summary>
        </member>
        <member name="M:Xen.XNALogic.Exit">
            <summary></summary>
        </member>
        <member name="M:Xen.XNALogic.Dispose">
            <summary>
            Dispose the wrapper
            </summary>
        </member>
        <member name="P:Xen.XNALogic.Services">
            <summary></summary>
        </member>
        <member name="P:Xen.XNALogic.Content">
            <summary></summary>
        </member>
        <member name="P:Xen.XNALogic.Components">
            <summary></summary>
        </member>
        <member name="P:Xen.XNALogic.IsActive">
            <summary></summary>
        </member>
        <member name="E:Xen.XNALogic.Exiting">
            <summary></summary>
        </member>
        <member name="P:Xen.XNALogic.Window">
            <summary></summary>
        </member>
        <member name="P:Xen.XNALogic.WindowHandle">
            <summary></summary>
        </member>
        <member name="P:Xen.XNALogic.VSyncEnabled">
            <summary></summary>
        </member>
        <member name="T:Xen.UpdateFrequency">
            <summary>
            <para>Enumeration representing the frequency an <see cref="T:Xen.IUpdate"/> object wishes to have it's Update() method called (With a special <see cref="F:Xen.UpdateFrequency.Terminate"/> case to have the object removed from the update list).</para>
            <para>NOTE: User input is updated at 60hz, any class responding to user input should use <see cref="F:Xen.UpdateFrequency.FullUpdate60hz"/></para>
            </summary>
        </member>
        <member name="F:Xen.UpdateFrequency.OncePerFrame">
            <summary>
            Call update once per frame
            </summary>
        </member>
        <member name="F:Xen.UpdateFrequency.OncePerFrameAsync">
            <summary>
            <para>Call update once per frame asynchronously with other <see cref="F:Xen.UpdateFrequency.OncePerFrameAsync"/> instances</para>
            <para>Note: Update implementations need to be thread safe when using asynchronous updates. Async adds overhead which can make simple Update methods slower!</para>
            </summary>
            <remarks>
            <para>Asynchronous updates have an overhead for setup of the asynchronous update process.</para>
            <para>If there are fewer items to be updated than threads, then the update processes will not be run asynchronously.</para>
            </remarks>
        </member>
        <member name="F:Xen.UpdateFrequency.FullUpdate60hz">
            <summary>
            <para>Call update 60 times per second</para>
            <para>NOTE: User input is updated at 60hz, any class responding to user input should use <see cref="F:Xen.UpdateFrequency.FullUpdate60hz"/></para>
            </summary>
        </member>
        <member name="F:Xen.UpdateFrequency.FullUpdate60hzAsync">
            <summary>
            <para>Call update 60 times per second asynchronously with other <see cref="F:Xen.UpdateFrequency.FullUpdate60hzAsync"/> instances</para>
            <para>NOTE: User input is updated at 60hz, any class responding to user input should use <see cref="F:Xen.UpdateFrequency.FullUpdate60hz"/></para>
            <para>Note: Update implementations need to be thread safe when using asynchronous updates. Async adds overhead which can make simple Update methods slower!</para>
            </summary>
            <remarks>
            <para>Asynchronous updates have an overhead for setup of the asynchronous update process.</para>
            <para>If there are fewer items to be updated than threads, then the update processes will not be run asynchronously.</para>
            </remarks>
        </member>
        <member name="F:Xen.UpdateFrequency.HalfUpdate30hz">
            <summary>
            Call update at least 30 times per second
            </summary>
        </member>
        <member name="F:Xen.UpdateFrequency.HalfUpdate30hzAsync">
            <summary>
            <para>Call update at least 30 times per second asynchronously with other <see cref="F:Xen.UpdateFrequency.HalfUpdate30hzAsync"/> instances</para>
            <para>Note: Update implementations need to be thread safe when using asynchronous updates. Async adds overhead which can make simple Update methods slower!</para>
            </summary>
            <remarks>
            <para>Asynchronous updates have an overhead for setup of the asynchronous update process.</para>
            <para>If there are fewer items to be updated than threads, then the update processes will not be run asynchronously.</para>
            </remarks>
        </member>
        <member name="F:Xen.UpdateFrequency.PartialUpdate15hz">
            <summary>
            Call update at least 15 times per second
            </summary>
        </member>
        <member name="F:Xen.UpdateFrequency.PartialUpdate10hz">
            <summary>
            Call update at least 10 times per second
            </summary>
        </member>
        <member name="F:Xen.UpdateFrequency.PartialUpdate5hz">
            <summary>
            Call update at least 5 times per second
            </summary>
        </member>
        <member name="F:Xen.UpdateFrequency.PartialUpdate1hz">
            <summary>
            Call update at least once every second
            </summary>
        </member>
        <member name="F:Xen.UpdateFrequency.Terminate">
            <summary>
            This object no longer needs to be updated, and should be removed from the update list.
            </summary>
            <remarks>This is the preferred method for removing an object from an <see cref="T:Xen.UpdateManager"/></remarks>
        </member>
        <member name="T:Xen.ICullableInstance">
            <summary>
            Interface for an object that can cull world matrix defined instances using an <see cref="T:Xen.ICuller"/>. An example use may be off-screen culling
            </summary>
        </member>
        <member name="M:Xen.ICullableInstance.CullTest(Xen.ICuller,Microsoft.Xna.Framework.Matrix@)">
            <summary>
            Perform a cull test on an instance of an object. Returns false if the CullTest fails (for example, the object is offscreen)
            </summary>
            <param name="culler"></param>
            <returns>Returns false if the CullTest fails (for example, the object is offscreen)</returns>
            <param name="instance">Local matrix of the instance to CullTest</param>
        </member>
        <member name="T:Xen.IDrawBatch">
            <summary>
            <para>Interface to a sepecial object that can drawn itself as a batch. All batch drawable objects also are <see cref="T:Xen.IDraw"/> instances</para>
            <para>Most DrawBatch objects will use hardware instancing when supported</para>
            </summary>
            <remarks>
            <para>This interface is usually used by low level geometry classes</para>
            <para>See the <see cref="T:Xen.Graphics.StreamFrequency"/> class for details on using hardware instancing to draw large numbers of complex objects efficiently.</para>
            </remarks>
        </member>
        <member name="M:Xen.IDrawBatch.DrawBatch(Xen.DrawState,Xen.Graphics.InstanceBuffer)">
            <summary>
            <para>Draw multiple instances of the object</para>
            </summary>
            <param name="state">Current state of the application</param>
            <param name="instances">Buffer containing the instances to draw (either created directly, or allocated dynamically with DrawState.GetDynamicInstanceBuffer)</param>
        </member>
        <member name="M:Xen.IDrawBatch.DrawBatch(Xen.DrawState,Microsoft.Xna.Framework.Matrix[],System.Int32)">
            <summary>
            <para>Draw multiple instances of the object</para>
            </summary>
        </member>
        <member name="T:Xen.Application">
            <summary>
            Base class for implementing a xen application. Implement this class in a simliar manner to the XNA <see cref="T:Microsoft.Xna.Framework.Game"/> class
            </summary>
            <remarks>This class can be explicitaly cast to an XNA Game instance:
            <example>
            <code>
            Xen.Application app = ...;
            
            //...
            Microsoft.Xna.Framework.Game xnaGame = (Microsoft.Xna.Framework.Game)app;
            </code>
            </example></remarks>
        </member>
        <member name="M:Xen.Application.PreFrameDraw(Xen.IFrameDraw)">
            <summary>
            <para>The the item passed in will be drawn at the start of the next frame, before the main application Draw method is called</para>
            </summary>
        </member>
        <member name="M:Xen.Application.#ctor">
            <summary>
            Constructor
            </summary>
            <remarks>This method sets up the input manager</remarks>
        </member>
        <member name="M:Xen.Application.GetApplicationInstance">
            <summary>
            Gets the running Application instance for this thread
            </summary>
            <returns></returns>
        </member>
        <member name="M:Xen.Application.op_Implicit(Xen.Application)~Microsoft.Xna.Framework.Game">
            <summary>
            Get the XNA Application instance
            </summary>
            <param name="application"></param>
            <returns></returns>
        </member>
        <member name="M:Xen.Application.Run">
            <summary>
            Start the main application loop. This method should be called from the entry point of the application
            </summary>
        </member>
        <member name="M:Xen.Application.Shutdown">
            <summary>
            Immediately shuts down the application (WinForms hosted applications will shutdown at the end of the frame)
            </summary>
        </member>
        <member name="M:Xen.Application.Initialise">
            <summary>
            Implement all application specific initalisation code in here
            </summary>
        </member>
        <member name="M:Xen.Application.Update(Xen.UpdateState)">
            <summary>
            Called at the start of the update loop, 60 times per frame
            </summary>
            <param name="state"></param>
        </member>
        <member name="M:Xen.Application.Frame(Xen.FrameState)">
            <summary>
            Run all drawing code for the frame
            </summary>
            <param name="state"></param>
        </member>
        <member name="M:Xen.Application.InitialisePlayerInput(Xen.Input.PlayerInputCollection)">
            <summary>
            Override this method to modify the setup of the player input objects before the application starts
            </summary>
            <param name="playerInput"></param>
        </member>
        <member name="M:Xen.Application.SetupGraphicsDeviceManager(Microsoft.Xna.Framework.GraphicsDeviceManager,Microsoft.Xna.Framework.Graphics.RenderTargetUsage@)">
            <summary>
            Override this method to change the graphics device options before the application starts (eg, set resolution, fullscreen, etc)
            </summary>
            <param name="graphics">XNA GraphicsDeviceManager (NOTE: This value will be null when displaying with Windows Forms)</param>
            <param name="presentation">Allows modification of the <see cref="T:Microsoft.Xna.Framework.Graphics.PresentationParameters"/> <see cref="T:Microsoft.Xna.Framework.Graphics.RenderTargetUsage"/> for the primary display</param>
        </member>
        <member name="M:Xen.Application.LoadContent(Xen.ContentState)">
            <summary>
            Override this method to perform custom content loading through an XNA ContentManager
            </summary>
            <param name="state"></param>
        </member>
        <member name="M:Xen.Application.UnloadContent">
            <summary>
            Override this method to perform custom content unloading
            </summary>
        </member>
        <member name="P:Xen.Application.MinimumDesiredFrameRate">
            <summary>
            <para>Gets/Sets the minimum desired frame rate. If the frame rate dips below this value, the application update loop will be slowed down to compensate</para>
            <para>Note: The reported frame rate from the application will not drop below this value</para>
            </summary>
        </member>
        <member name="P:Xen.Application.ApplicationRequiresGamerServices">
            <summary>
            Override this property and return true if your Application requires gamer services
            </summary>
        </member>
        <member name="P:Xen.Application.ThreadPool">
            <summary>
            Gets the application thread pool instance
            </summary>
        </member>
        <member name="P:Xen.Application.UserValues">
            <summary>
            A dictionary for placing global values, if desired
            </summary>
        </member>
        <member name="P:Xen.Application.Content">
            <summary>
            Get an instance to an application wide Content manager
            </summary>
        </member>
        <member name="P:Xen.Application.XnaComponents">
            <summary>
            Access the XNA base game <see cref="T:Microsoft.Xna.Framework.GameComponentCollection"/>. Use with caution, Using Game Components is not tested/supported (Not supported when using WinForms)
            </summary>
        </member>
        <member name="P:Xen.Application.Services">
            <summary>
            Access the XNA base game <see cref="T:Microsoft.Xna.Framework.GameServiceContainer"/> Services
            </summary>
        </member>
        <member name="P:Xen.Application.IsActive">
            <summary>
             Indicates if this application is currently the active application.
            </summary>
        </member>
        <member name="P:Xen.Application.GamerServices">
            <summary>
            Get the XNA GamerServices object for this application
            </summary>
        </member>
        <member name="P:Xen.Application.Window">
            <summary>
            Gets the Window the application is being displayed on (This value is null when using Windows Forms hosting)
            </summary>
        </member>
        <member name="P:Xen.Application.TitleSafeArea">
            <summary>
            Gets the graphics device Title Safe Area
            </summary>
        </member>
        <member name="P:Xen.Application.WindowWidth">
            <summary>
            Gets the width (in pixels) of the render window
            </summary>
        </member>
        <member name="P:Xen.Application.WindowHeight">
            <summary>
            Gets the height (in pixels) of the render window
            </summary>
        </member>
        <member name="P:Xen.Application.UpdateManager">
            <summary>
            Gets the application <see cref="P:Xen.Application.UpdateManager"/> instance. Add objects implementing <see cref="T:Xen.IUpdate"/> to this manager to perform update logic
            </summary>
        </member>
        <member name="P:Xen.Application.IsHiDefDevice">
            <summary>
            Returns true if this application is running an XNA 4 HiDef device
            </summary>
        </member>
        <member name="T:Xen.Application.ApplicationProviderService">
            <summary>
            XNA Service that returns the <see cref="P:Xen.Application.ApplicationProviderService.Application"/>. Useful for warming resources when loading through the content pipeline.
            </summary>
        </member>
        <member name="P:Xen.Application.ApplicationProviderService.Application">
            <summary>
            Gets the <see cref="P:Xen.Application.ApplicationProviderService.Application"/>
            </summary>
        </member>
        <member name="T:Xen.Camera.ControlledCamera3D">
            <summary>
            Base class for a camera that is controlled by <see cref="T:Xen.Input.PlayerInput"/>
            </summary>
        </member>
        <member name="M:Xen.Camera.ControlledCamera3D.#ctor(Xen.UpdateManager,Xen.Camera.Projection)">
            <summary>
            Constructor
            </summary>
            <param name="updaterManager"></param>
            <param name="projection"></param>
        </member>
        <member name="M:Xen.Camera.ControlledCamera3D.Update(Xen.UpdateState,Xen.Input.State.InputState)">
            <summary>
            Update method to implement
            </summary>
            <param name="state"></param>
            <param name="input"></param>
        </member>
        <member name="M:Xen.Camera.ControlledCamera3D.Dispose">
            <summary>
            Dispose this camera (the camera will stop listening to player input)
            </summary>
        </member>
        <member name="P:Xen.Camera.ControlledCamera3D.PlayerIndex">
            <summary>
            Gets/Sets the player input index
            </summary>
        </member>
        <member name="P:Xen.Camera.ControlledCamera3D.RotationSensitivity">
            <summary>
            Gets/Sets the rotational sensitivity
            </summary>
        </member>
        <member name="P:Xen.Camera.ControlledCamera3D.MovementSensitivity">
            <summary>
            Gets/Sets the movement sensitivity
            </summary>
        </member>
        <member name="P:Xen.Camera.ControlledCamera3D.IsDisposed">
            <summary></summary>
        </member>
        <member name="T:Xen.Camera.FirstPersonControlledCamera3D">
            <summary>
            Simple 'First Person' style free roaming camera controlled by a <see cref="T:Xen.Input.PlayerInput"/>
            </summary>
        </member>
        <member name="M:Xen.Camera.FirstPersonControlledCamera3D.#ctor(Xen.UpdateManager)">
            <summary>
            Construct the camera
            </summary>
            <param name="updateManager"></param>
        </member>
        <member name="M:Xen.Camera.FirstPersonControlledCamera3D.#ctor(Xen.UpdateManager,Microsoft.Xna.Framework.Vector3)">
            <summary>
            Construct the camera
            </summary>
            <param name="updateManager"></param>
            <param name="startPosition"></param>
        </member>
        <member name="M:Xen.Camera.FirstPersonControlledCamera3D.#ctor(Xen.UpdateManager,Microsoft.Xna.Framework.Vector3,System.Boolean)">
            <summary>
            Construct the camera
            </summary>
            <param name="updateManager"></param>
            <param name="startPosition"></param>
            <param name="zUp">If true, the Z-Axis is treated as the up/down axis, otherwise Y-Axis is treated as up/down</param>
        </member>
        <member name="M:Xen.Camera.FirstPersonControlledCamera3D.#ctor(Xen.UpdateManager,Microsoft.Xna.Framework.Vector3,System.Boolean,Xen.Camera.Projection)">
            <summary>
            Construct the camera
            </summary>
            <param name="updateManager"></param>
            <param name="startPosition"></param>
            <param name="zUp">If true, the Z-Axis is treated as the up/down axis, otherwise Y-Axis is treated as up/down</param>
            <param name="projection"></param>
        </member>
        <member name="M:Xen.Camera.FirstPersonControlledCamera3D.Update(Xen.UpdateState,Xen.Input.State.InputState)">
            <summary></summary>
            <param name="state"></param>
            <param name="input"></param>
        </member>
        <member name="M:Xen.Camera.FirstPersonControlledCamera3D.LookAt(Microsoft.Xna.Framework.Vector3@,Microsoft.Xna.Framework.Vector3@,Microsoft.Xna.Framework.Vector3@)">
            <summary>
            Sets the <see cref="P:Xen.Camera.Camera3D.CameraMatrix"/> to a matrix that will make the camera look at a target
            </summary>
            <param name="cameraPosition"></param>
            <param name="lookAtTarget"></param>
            <param name="upVector">Vector representing the up direction for the camera. This vector is required to determine how the camera is orientated around the direction it is looking in</param>
            <remarks>
            <para>Using <see cref="M:Microsoft.Xna.Framework.Matrix.CreateLookAt(Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3)"/> is not recommended because it creats a View matrix, so it cannot be used for non-camera matrices. The <see cref="P:Xen.Camera.Camera3D.CameraMatrix"/> of a camera is the Inverse (<see cref="M:Microsoft.Xna.Framework.Matrix.Invert(Microsoft.Xna.Framework.Matrix)"/>) of the View Matrix (<see cref="M:Xen.Camera.ICamera.GetViewMatrix(Microsoft.Xna.Framework.Matrix@)"/>), so trying to set the camera matrix using Matrix.CreateLookAt will produce highly unexpected results.
            </para></remarks>
        </member>
        <member name="P:Xen.Camera.FirstPersonControlledCamera3D.ZAxisUp">
            <summary>
            By default the Y-axis is up/down, set to true to make the Z-axis up/down.
            </summary>
        </member>
        <member name="P:Xen.Camera.FirstPersonControlledCamera3D.VerticalAxisCap">
            <summary>
            Set the maximum angle the camera can look up/down
            </summary>
        </member>
        <member name="T:Xen.Input.State.KeyboardMouseState">
            <summary>
            Structure storing current raw keyboard and mouse state (used for internal logic classes only)
            </summary>
        </member>
        <member name="P:Xen.Input.State.KeyboardMouseState.KeyboardState">
            <summary>
            Current keyboard state
            </summary>
        </member>
        <member name="P:Xen.Input.State.KeyboardMouseState.MousePositionPrevious">
            <summary>
            [Windows Only]
            </summary>
        </member>
        <member name="P:Xen.Input.State.KeyboardMouseState.MouseState">
            <summary>
            [Windows Only] Current mouse state
            </summary>
        </member>
        <member name="T:Xen.Input.State.Button">
            <summary>
            Structure storing the state of a digital (on/off) button
            </summary>
        </member>
        <member name="M:Xen.Input.State.Button.op_Implicit(Xen.Input.State.Button)~System.Boolean">
            <summary>
            Implicit conversion to a boolean (equivalent of <see cref="P:Xen.Input.State.Button.IsDown"/>)
            </summary>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="P:Xen.Input.State.Button.IsDown">
            <summary>
            True if the button is pressed
            </summary>
        </member>
        <member name="P:Xen.Input.State.Button.OnPressed">
            <summary>
            Will return true for the SINGLE FRAME the button changes state from unpressed to pressed
            </summary>
        </member>
        <member name="P:Xen.Input.State.Button.OnReleased">
            <summary>
            Will return true for the SINGLE FRAME the button changes state from pressed to unpressed
            </summary>
        </member>
        <member name="P:Xen.Input.State.Button.DownDuration">
            <summary>
            Number of seconds the button has been held down for
            </summary>
        </member>
        <member name="P:Xen.Input.State.Button.ReleaseTime">
            <summary>
            Number of seconds since the the botton was last released (May be useful for calculating double presses)
            </summary>
        </member>
        <member name="T:Xen.Input.State.InputButtons">
            <summary>
            Structure storing the current state of a gamepad's buttons
            </summary>
        </member>
        <member name="P:Xen.Input.State.InputButtons.A">
            <summary></summary>
        </member>
        <member name="P:Xen.Input.State.InputButtons.B">
            <summary></summary>
        </member>
        <member name="P:Xen.Input.State.InputButtons.X">
            <summary></summary>
        </member>
        <member name="P:Xen.Input.State.InputButtons.Y">
            <summary></summary>
        </member>
        <member name="P:Xen.Input.State.InputButtons.Back">
            <summary></summary>
        </member>
        <member name="P:Xen.Input.State.InputButtons.Start">
            <summary></summary>
        </member>
        <member name="P:Xen.Input.State.InputButtons.LeftStickClick">
            <summary></summary>
        </member>
        <member name="P:Xen.Input.State.InputButtons.RightStickClick">
            <summary></summary>
        </member>
        <member name="P:Xen.Input.State.InputButtons.DpadLeft">
            <summary></summary>
        </member>
        <member name="P:Xen.Input.State.InputButtons.DpadRight">
            <summary></summary>
        </member>
        <member name="P:Xen.Input.State.InputButtons.DpadUp">
            <summary></summary>
        </member>
        <member name="P:Xen.Input.State.InputButtons.DpadDown">
            <summary></summary>
        </member>
        <member name="P:Xen.Input.State.InputButtons.LeftShoulder">
            <summary></summary>
        </member>
        <member name="P:Xen.Input.State.InputButtons.RightShoulder">
            <summary></summary>
        </member>
        <member name="T:Xen.Input.State.InputThumbSticks">
            <summary>
            Structure storing the current state of a gamepad's thumbsticks
            </summary>
        </member>
        <member name="P:Xen.Input.State.InputThumbSticks.LeftStick">
            <summary></summary>
        </member>
        <member name="P:Xen.Input.State.InputThumbSticks.RightStick">
            <summary></summary>
        </member>
        <member name="T:Xen.Input.State.InputTriggers">
            <summary>
            Structure storing the current state of a gamepad's triggers
            </summary>
        </member>
        <member name="P:Xen.Input.State.InputTriggers.LeftTrigger">
            <summary></summary>
        </member>
        <member name="P:Xen.Input.State.InputTriggers.RightTrigger">
            <summary></summary>
        </member>
        <member name="T:Xen.Input.State.InputState">
            <summary>
            Structure storing the current state of a gamepad's buttons, triggers and thumbsticks
            </summary>
        </member>
        <member name="P:Xen.Input.State.InputState.Triggers">
            <summary></summary>
        </member>
        <member name="P:Xen.Input.State.InputState.ThumbSticks">
            <summary></summary>
        </member>
        <member name="P:Xen.Input.State.InputState.Buttons">
            <summary></summary>
        </member>
        <member name="T:Xen.Input.State.KeyState">
            <summary>
            Stores a list of <see cref="T:Xen.Input.State.Button"/> Key States
            </summary>
        </member>
        <member name="P:Xen.Input.State.KeyState.Item(Microsoft.Xna.Framework.Input.Keys)">
            <summary>
            Button Indexer (Keys)
            </summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="P:Xen.Input.State.KeyState.A">
            <summary>The 'A' button</summary>
        </member>
        <member name="P:Xen.Input.State.KeyState.Add">
            <summary>The 'Add' button</summary>
        </member>
        <member name="P:Xen.Input.State.KeyState.Apps">
            <summary>The 'Apps' button</summary>
        </member>
        <member name="P:Xen.Input.State.KeyState.Attn">
            <summary>The 'Attn' button</summary>
        </member>
        <member name="P:Xen.Input.State.KeyState.B">
            <summary>The 'B' button</summary>
        </member>
        <member name="P:Xen.Input.State.KeyState.Back">
            <summary>The 'Back' button</summary>
        </member>
        <member name="P:Xen.Input.State.KeyState.BrowserBack">
            <summary>The 'BrowserBack' button</summary>
        </member>
        <member name="P:Xen.Input.State.KeyState.BrowserFavorites">
            <summary>The 'BrowserFavorites' button</summary>
        </member>
        <member name="P:Xen.Input.State.KeyState.BrowserForward">
            <summary>The 'BrowserForward' button</summary>
        </member>
        <member name="P:Xen.Input.State.KeyState.BrowserHome">
            <summary>The 'BrowserHome' button</summary>
        </member>
        <member name="P:Xen.Input.State.KeyState.BrowserRefresh">
            <summary>The 'BrowserRefresh' button</summary>
        </member>
        <member name="P:Xen.Input.State.KeyState.BrowserSearch">
            <summary>The 'BrowserSearch' button</summary>
        </member>
        <member name="P:Xen.Input.State.KeyState.BrowserStop">
            <summary>The 'BrowserStop' button</summary>
        </member>
        <member name="P:Xen.Input.State.KeyState.C">
            <summary>The 'C' button</summary>
        </member>
        <member name="P:Xen.Input.State.KeyState.CapsLock">
            <summary>The 'CapsLock' button</summary>
        </member>
        <member name="P:Xen.Input.State.KeyState.ChatPadGreen">
            <summary>The 'ChatPadGreen' button</summary>
        </member>
        <member name="P:Xen.Input.State.KeyState.ChatPadOrange">
            <summary>The 'ChatPadOrange' button</summary>
        </member>
        <member name="P:Xen.Input.State.KeyState.Crsel">
            <summary>The 'Crsel' button</summary>
        </member>
        <member name="P:Xen.Input.State.KeyState.D">
            <summary>The 'D' button</summary>
        </member>
        <member name="P:Xen.Input.State.KeyState.D0">
            <summary>The 'D0' button</summary>
        </member>
        <member name="P:Xen.Input.State.KeyState.D1">
            <summary>The 'D1' button</summary>
        </member>
        <member name="P:Xen.Input.State.KeyState.D2">
            <summary>The 'D2' button</summary>
        </member>
        <member name="P:Xen.Input.State.KeyState.D3">
            <summary>The 'D3' button</summary>
        </member>
        <member name="P:Xen.Input.State.KeyState.D4">
            <summary>The 'D4' button</summary>
        </member>
        <member name="P:Xen.Input.State.KeyState.D5">
            <summary>The 'D5' button</summary>
        </member>
        <member name="P:Xen.Input.State.KeyState.D6">
            <summary>The 'D6' button</summary>
        </member>
        <member name="P:Xen.Input.State.KeyState.D7">
            <summary>The 'D7' button</summary>
        </member>
        <member name="P:Xen.Input.State.KeyState.D8">
            <summary>The 'D8' button</summary>
        </member>
        <member name="P:Xen.Input.State.KeyState.D9">
            <summary>The 'D9' button</summary>
        </member>
        <member name="P:Xen.Input.State.KeyState.Decimal">
            <summary>The 'Decimal' button</summary>
        </member>
        <member name="P:Xen.Input.State.KeyState.Delete">
            <summary>The 'Delete' button</summary>
        </member>
        <member name="P:Xen.Input.State.KeyState.Divide">
            <summary>The 'Divide' button</summary>
        </member>
        <member name="P:Xen.Input.State.KeyState.Down">
            <summary>The 'Down' button</summary>
        </member>
        <member name="P:Xen.Input.State.KeyState.E">
            <summary>The 'E' button</summary>
        </member>
        <member name="P:Xen.Input.State.KeyState.End">
            <summary>The 'End' button</summary>
        </member>
        <member name="P:Xen.Input.State.KeyState.Enter">
            <summary>The 'Enter' button</summary>
        </member>
        <member name="P:Xen.Input.State.KeyState.EraseEof">
            <summary>The 'EraseEof' button</summary>
        </member>
        <member name="P:Xen.Input.State.KeyState.Escape">
            <summary>The 'Escape' button</summary>
        </member>
        <member name="P:Xen.Input.State.KeyState.Execute">
            <summary>The 'Execute' button</summary>
        </member>
        <member name="P:Xen.Input.State.KeyState.Exsel">
            <summary>The 'Exsel' button</summary>
        </member>
        <member name="P:Xen.Input.State.KeyState.F">
            <summary>The 'F' button</summary>
        </member>
        <member name="P:Xen.Input.State.KeyState.F1">
            <summary>The 'F1' button</summary>
        </member>
        <member name="P:Xen.Input.State.KeyState.F10">
            <summary>The 'F10' button</summary>
        </member>
        <member name="P:Xen.Input.State.KeyState.F11">
            <summary>The 'F11' button</summary>
        </member>
        <member name="P:Xen.Input.State.KeyState.F12">
            <summary>The 'F12' button</summary>
        </member>
        <member name="P:Xen.Input.State.KeyState.F13">
            <summary>The 'F13' button</summary>
        </member>
        <member name="P:Xen.Input.State.KeyState.F14">
            <summary>The 'F14' button</summary>
        </member>
        <member name="P:Xen.Input.State.KeyState.F15">
            <summary>The 'F15' button</summary>
        </member>
        <member name="P:Xen.Input.State.KeyState.F16">
            <summary>The 'F16' button</summary>
        </member>
        <member name="P:Xen.Input.State.KeyState.F17">
            <summary>The 'F17' button</summary>
        </member>
        <member name="P:Xen.Input.State.KeyState.F18">
            <summary>The 'F18' button</summary>
        </member>
        <member name="P:Xen.Input.State.KeyState.F19">
            <summary>The 'F19' button</summary>
        </member>
        <member name="P:Xen.Input.State.KeyState.F2">
            <summary>The 'F2' button</summary>
        </member>
        <member name="P:Xen.Input.State.KeyState.F20">
            <summary>The 'F20' button</summary>
        </member>
        <member name="P:Xen.Input.State.KeyState.F21">
            <summary>The 'F21' button</summary>
        </member>
        <member name="P:Xen.Input.State.KeyState.F22">
            <summary>The 'F22' button</summary>
        </member>
        <member name="P:Xen.Input.State.KeyState.F23">
            <summary>The 'F23' button</summary>
        </member>
        <member name="P:Xen.Input.State.KeyState.F24">
            <summary>The 'F24' button</summary>
        </member>
        <member name="P:Xen.Input.State.KeyState.F3">
            <summary>The 'F3' button</summary>
        </member>
        <member name="P:Xen.Input.State.KeyState.F4">
            <summary>The 'F4' button</summary>
        </member>
        <member name="P:Xen.Input.State.KeyState.F5">
            <summary>The 'F5' button</summary>
        </member>
        <member name="P:Xen.Input.State.KeyState.F6">
            <summary>The 'F6' button</summary>
        </member>
        <member name="P:Xen.Input.State.KeyState.F7">
            <summary>The 'F7' button</summary>
        </member>
        <member name="P:Xen.Input.State.KeyState.F8">
            <summary>The 'F8' button</summary>
        </member>
        <member name="P:Xen.Input.State.KeyState.F9">
            <summary>The 'F9' button</summary>
        </member>
        <member name="P:Xen.Input.State.KeyState.G">
            <summary>The 'G' button</summary>
        </member>
        <member name="P:Xen.Input.State.KeyState.H">
            <summary>The 'H' button</summary>
        </member>
        <member name="P:Xen.Input.State.KeyState.Help">
            <summary>The 'Help' button</summary>
        </member>
        <member name="P:Xen.Input.State.KeyState.Home">
            <summary>The 'Home' button</summary>
        </member>
        <member name="P:Xen.Input.State.KeyState.I">
            <summary>The 'I' button</summary>
        </member>
        <member name="P:Xen.Input.State.KeyState.Insert">
            <summary>The 'Insert' button</summary>
        </member>
        <member name="P:Xen.Input.State.KeyState.J">
            <summary>The 'J' button</summary>
        </member>
        <member name="P:Xen.Input.State.KeyState.K">
            <summary>The 'K' button</summary>
        </member>
        <member name="P:Xen.Input.State.KeyState.L">
            <summary>The 'L' button</summary>
        </member>
        <member name="P:Xen.Input.State.KeyState.LaunchApplication1">
            <summary>The 'LaunchApplication1' button</summary>
        </member>
        <member name="P:Xen.Input.State.KeyState.LaunchApplication2">
            <summary>The 'LaunchApplication2' button</summary>
        </member>
        <member name="P:Xen.Input.State.KeyState.LaunchMail">
            <summary>The 'LaunchMail' button</summary>
        </member>
        <member name="P:Xen.Input.State.KeyState.Left">
            <summary>The 'Left' button</summary>
        </member>
        <member name="P:Xen.Input.State.KeyState.LeftAlt">
            <summary>The 'LeftAlt' button</summary>
        </member>
        <member name="P:Xen.Input.State.KeyState.LeftControl">
            <summary>The 'LeftControl' button</summary>
        </member>
        <member name="P:Xen.Input.State.KeyState.LeftShift">
            <summary>The 'LeftShift' button</summary>
        </member>
        <member name="P:Xen.Input.State.KeyState.LeftWindows">
            <summary>The 'LeftWindows' button</summary>
        </member>
        <member name="P:Xen.Input.State.KeyState.M">
            <summary>The 'M' button</summary>
        </member>
        <member name="P:Xen.Input.State.KeyState.MediaNextTrack">
            <summary>The 'MediaNextTrack' button</summary>
        </member>
        <member name="P:Xen.Input.State.KeyState.MediaPlayPause">
            <summary>The 'MediaPlayPause' button</summary>
        </member>
        <member name="P:Xen.Input.State.KeyState.MediaPreviousTrack">
            <summary>The 'MediaPreviousTrack' button</summary>
        </member>
        <member name="P:Xen.Input.State.KeyState.MediaStop">
            <summary>The 'MediaStop' button</summary>
        </member>
        <member name="P:Xen.Input.State.KeyState.Multiply">
            <summary>The 'Multiply' button</summary>
        </member>
        <member name="P:Xen.Input.State.KeyState.N">
            <summary>The 'N' button</summary>
        </member>
        <member name="P:Xen.Input.State.KeyState.NumLock">
            <summary>The 'NumLock' button</summary>
        </member>
        <member name="P:Xen.Input.State.KeyState.NumPad0">
            <summary>The 'NumPad0' button</summary>
        </member>
        <member name="P:Xen.Input.State.KeyState.NumPad1">
            <summary>The 'NumPad1' button</summary>
        </member>
        <member name="P:Xen.Input.State.KeyState.NumPad2">
            <summary>The 'NumPad2' button</summary>
        </member>
        <member name="P:Xen.Input.State.KeyState.NumPad3">
            <summary>The 'NumPad3' button</summary>
        </member>
        <member name="P:Xen.Input.State.KeyState.NumPad4">
            <summary>The 'NumPad4' button</summary>
        </member>
        <member name="P:Xen.Input.State.KeyState.NumPad5">
            <summary>The 'NumPad5' button</summary>
        </member>
        <member name="P:Xen.Input.State.KeyState.NumPad6">
            <summary>The 'NumPad6' button</summary>
        </member>
        <member name="P:Xen.Input.State.KeyState.NumPad7">
            <summary>The 'NumPad7' button</summary>
        </member>
        <member name="P:Xen.Input.State.KeyState.NumPad8">
            <summary>The 'NumPad8' button</summary>
        </member>
        <member name="P:Xen.Input.State.KeyState.NumPad9">
            <summary>The 'NumPad9' button</summary>
        </member>
        <member name="P:Xen.Input.State.KeyState.O">
            <summary>The 'O' button</summary>
        </member>
        <member name="P:Xen.Input.State.KeyState.Oem8">
            <summary>The 'Oem8' button</summary>
        </member>
        <member name="P:Xen.Input.State.KeyState.OemBackslash">
            <summary>The 'OemBackslash' button</summary>
        </member>
        <member name="P:Xen.Input.State.KeyState.OemClear">
            <summary>The 'OemClear' button</summary>
        </member>
        <member name="P:Xen.Input.State.KeyState.OemCloseBrackets">
            <summary>The 'OemCloseBrackets' button</summary>
        </member>
        <member name="P:Xen.Input.State.KeyState.OemComma">
            <summary>The 'OemComma' button</summary>
        </member>
        <member name="P:Xen.Input.State.KeyState.OemMinus">
            <summary>The 'OemMinus' button</summary>
        </member>
        <member name="P:Xen.Input.State.KeyState.OemOpenBrackets">
            <summary>The 'OemOpenBrackets' button</summary>
        </member>
        <member name="P:Xen.Input.State.KeyState.OemPeriod">
            <summary>The 'OemPeriod' button</summary>
        </member>
        <member name="P:Xen.Input.State.KeyState.OemPipe">
            <summary>The 'OemPipe' button</summary>
        </member>
        <member name="P:Xen.Input.State.KeyState.OemPlus">
            <summary>The 'OemPlus' button</summary>
        </member>
        <member name="P:Xen.Input.State.KeyState.OemQuestion">
            <summary>The 'OemQuestion' button</summary>
        </member>
        <member name="P:Xen.Input.State.KeyState.OemQuotes">
            <summary>The 'OemQuotes' button</summary>
        </member>
        <member name="P:Xen.Input.State.KeyState.OemSemicolon">
            <summary>The 'OemSemicolon' button</summary>
        </member>
        <member name="P:Xen.Input.State.KeyState.OemTilde">
            <summary>The 'OemTilde' button</summary>
        </member>
        <member name="P:Xen.Input.State.KeyState.P">
            <summary>The 'P' button</summary>
        </member>
        <member name="P:Xen.Input.State.KeyState.Pa1">
            <summary>The 'Pa1' button</summary>
        </member>
        <member name="P:Xen.Input.State.KeyState.PageDown">
            <summary>The 'PageDown' button</summary>
        </member>
        <member name="P:Xen.Input.State.KeyState.PageUp">
            <summary>The 'PageUp' button</summary>
        </member>
        <member name="P:Xen.Input.State.KeyState.Pause">
            <summary>The 'Pause' button</summary>
        </member>
        <member name="P:Xen.Input.State.KeyState.Play">
            <summary>The 'Play' button</summary>
        </member>
        <member name="P:Xen.Input.State.KeyState.Print">
            <summary>The 'Print' button</summary>
        </member>
        <member name="P:Xen.Input.State.KeyState.PrintScreen">
            <summary>The 'PrintScreen' button</summary>
        </member>
        <member name="P:Xen.Input.State.KeyState.ProcessKey">
            <summary>The 'ProcessKey' button</summary>
        </member>
        <member name="P:Xen.Input.State.KeyState.Q">
            <summary>The 'Q' button</summary>
        </member>
        <member name="P:Xen.Input.State.KeyState.R">
            <summary>The 'R' button</summary>
        </member>
        <member name="P:Xen.Input.State.KeyState.Right">
            <summary>The 'Right' button</summary>
        </member>
        <member name="P:Xen.Input.State.KeyState.RightAlt">
            <summary>The 'RightAlt' button</summary>
        </member>
        <member name="P:Xen.Input.State.KeyState.RightControl">
            <summary>The 'RightControl' button</summary>
        </member>
        <member name="P:Xen.Input.State.KeyState.RightShift">
            <summary>The 'RightShift' button</summary>
        </member>
        <member name="P:Xen.Input.State.KeyState.RightWindows">
            <summary>The 'RightWindows' button</summary>
        </member>
        <member name="P:Xen.Input.State.KeyState.S">
            <summary>The 'S' button</summary>
        </member>
        <member name="P:Xen.Input.State.KeyState.Scroll">
            <summary>The 'Scroll' button</summary>
        </member>
        <member name="P:Xen.Input.State.KeyState.Select">
            <summary>The 'Select' button</summary>
        </member>
        <member name="P:Xen.Input.State.KeyState.SelectMedia">
            <summary>The 'SelectMedia' button</summary>
        </member>
        <member name="P:Xen.Input.State.KeyState.Separator">
            <summary>The 'Separator' button</summary>
        </member>
        <member name="P:Xen.Input.State.KeyState.Sleep">
            <summary>The 'Sleep' button</summary>
        </member>
        <member name="P:Xen.Input.State.KeyState.Space">
            <summary>The 'Space' button</summary>
        </member>
        <member name="P:Xen.Input.State.KeyState.Subtract">
            <summary>The 'Subtract' button</summary>
        </member>
        <member name="P:Xen.Input.State.KeyState.T">
            <summary>The 'T' button</summary>
        </member>
        <member name="P:Xen.Input.State.KeyState.Tab">
            <summary>The 'Tab' button</summary>
        </member>
        <member name="P:Xen.Input.State.KeyState.U">
            <summary>The 'U' button</summary>
        </member>
        <member name="P:Xen.Input.State.KeyState.Up">
            <summary>The 'Up' button</summary>
        </member>
        <member name="P:Xen.Input.State.KeyState.V">
            <summary>The 'V' button</summary>
        </member>
        <member name="P:Xen.Input.State.KeyState.VolumeDown">
            <summary>The 'VolumeDown' button</summary>
        </member>
        <member name="P:Xen.Input.State.KeyState.VolumeMute">
            <summary>The 'VolumeMute' button</summary>
        </member>
        <member name="P:Xen.Input.State.KeyState.VolumeUp">
            <summary>The 'VolumeUp' button</summary>
        </member>
        <member name="P:Xen.Input.State.KeyState.W">
            <summary>The 'W' button</summary>
        </member>
        <member name="P:Xen.Input.State.KeyState.X">
            <summary>The 'X' button</summary>
        </member>
        <member name="P:Xen.Input.State.KeyState.Y">
            <summary>The 'Y' button</summary>
        </member>
        <member name="P:Xen.Input.State.KeyState.Z">
            <summary>The 'Z' button</summary>
        </member>
        <member name="P:Xen.Input.State.KeyState.Zoom">
            <summary>The 'Zoom' button</summary>
        </member>
        <member name="T:Xen.Input.State.KeyboardInputState">
            <summary>
            Stores a list of <see cref="T:Xen.Input.State.Button"/> objects representing keyboard keys
            </summary>
        </member>
        <member name="M:Xen.Input.State.KeyboardInputState.GetKeyArray">
            <summary>
            Allocates an array of all values in the <see cref="T:Microsoft.Xna.Framework.Input.Keys"/> enumerator
            </summary>
            <returns></returns>
        </member>
        <member name="M:Xen.Input.State.KeyboardInputState.TryGetKeyChar(Microsoft.Xna.Framework.Input.Keys,System.Char@)">
            <summary>
            <para>Gets the character for a given <see cref="T:Microsoft.Xna.Framework.Input.Keys"/> key. Eg: <see cref="F:Microsoft.Xna.Framework.Input.Keys.A"/> will output 'a'. Uses the current keyboard modifier key state; Shift will convert to upper case, etc.</para>
            <para>Returns false if the key character is unknown</para>
            </summary>
            <param name="key"></param>
            <param name="keyChar"></param>
            <returns></returns>
        </member>
        <member name="M:Xen.Input.State.KeyboardInputState.op_Implicit(Xen.Input.State.KeyboardInputState)~Microsoft.Xna.Framework.Input.KeyboardState">
            <summary></summary>
            <param name="input"></param>
            <returns></returns>
        </member>
        <member name="M:Xen.Input.State.KeyboardInputState.IsKeyDown(Microsoft.Xna.Framework.Input.Keys)">
            <summary>
            Returns true if a key is down
            </summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:Xen.Input.State.KeyboardInputState.IsKeyUp(Microsoft.Xna.Framework.Input.Keys)">
            <summary>
            Returns true if a key is up
            </summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:Xen.Input.State.KeyboardInputState.GetKey(Microsoft.Xna.Framework.Input.Keys)">
            <summary>
            Gets the <see cref="T:Xen.Input.State.Button"/> state of a key
            </summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:Xen.Input.State.KeyboardInputState.GetPressedKeys(System.Action{Microsoft.Xna.Framework.Input.Keys})">
            <summary>
            Calls the <paramref name="callback"/> for each <see cref="T:Microsoft.Xna.Framework.Input.Keys"/> key where <see cref="P:Xen.Input.State.Button.OnPressed"/> is true
            </summary>
            <param name="callback"></param>
        </member>
        <member name="M:Xen.Input.State.KeyboardInputState.GetPressedKeys(System.Collections.Generic.List{Microsoft.Xna.Framework.Input.Keys})">
            <summary>
            Adds a key to the <paramref name="pressedList"/> for each <see cref="T:Microsoft.Xna.Framework.Input.Keys"/> key where <see cref="P:Xen.Input.State.Button.OnPressed"/> is true
            </summary>
            <param name="pressedList"></param>
        </member>
        <member name="M:Xen.Input.State.KeyboardInputState.GetHeldKeys(System.Action{Microsoft.Xna.Framework.Input.Keys})">
            <summary>
            <para>Calls the <paramref name="callback"/> for each <see cref="T:Microsoft.Xna.Framework.Input.Keys"/> key where <see cref="P:Xen.Input.State.Button.IsDown"/> is true</para>
            </summary>
            <param name="callback"></param>
        </member>
        <member name="M:Xen.Input.State.KeyboardInputState.GetHeldKeys(System.Collections.Generic.List{Microsoft.Xna.Framework.Input.Keys})">
            <summary>
            <para>Adds a key to the <paramref name="heldKeyList"/> for each <see cref="T:Microsoft.Xna.Framework.Input.Keys"/> key where <see cref="P:Xen.Input.State.Button.IsDown"/> is true</para>
            <para>The list will be cleared before any keys are added</para>
            </summary>
            <param name="heldKeyList"></param>
        </member>
        <member name="P:Xen.Input.State.KeyboardInputState.KeyState">
            <summary>
            Gets the current KeyState
            </summary>
        </member>
        <member name="P:Xen.Input.State.KeyboardInputState.Item(Microsoft.Xna.Framework.Input.Keys)">
            <summary>
            Button Indexer (Keys)
            </summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="T:Xen.Input.State.MouseInputState">
            <summary>
            [Windows Only] Stores <see cref="T:Xen.Input.State.Button"/> objects representing mouse buttons
            </summary>
        </member>
        <member name="M:Xen.Input.State.MouseInputState.op_Implicit(Xen.Input.State.MouseInputState)~Microsoft.Xna.Framework.Input.MouseState">
            <summary></summary>
            <param name="input"></param>
            <returns></returns>
        </member>
        <member name="P:Xen.Input.State.MouseInputState.X">
            <summary>
            Horizontal position of the mouse cursor
            </summary>
        </member>
        <member name="P:Xen.Input.State.MouseInputState.Y">
            <summary>
            Vertical position of the mouse cursor
            </summary>
        </member>
        <member name="P:Xen.Input.State.MouseInputState.LeftButton">
            <summary>
            <see cref="T:Xen.Input.State.Button"/> state of the left mouse button
            </summary>
        </member>
        <member name="P:Xen.Input.State.MouseInputState.RightButton">
            <summary>
            <see cref="T:Xen.Input.State.Button"/> state of the right mouse button
            </summary>
        </member>
        <member name="P:Xen.Input.State.MouseInputState.MiddleButton">
            <summary>
            <see cref="T:Xen.Input.State.Button"/> state of the middle mouse button
            </summary>
        </member>
        <member name="P:Xen.Input.State.MouseInputState.XButton1">
            <summary>
            <see cref="T:Xen.Input.State.Button"/> state of the first X mouse button
            </summary>
        </member>
        <member name="P:Xen.Input.State.MouseInputState.XButton2">
            <summary>
            <see cref="T:Xen.Input.State.Button"/> state of the second X mouse button
            </summary>
        </member>
        <member name="P:Xen.Input.State.MouseInputState.ScrollWheelValue">
            <summary>
            Gets the total mouse scroll movement
            </summary>
        </member>
        <member name="P:Xen.Input.State.MouseInputState.ScrollWheelDelta">
            <summary>
            Gets the delta mouse scroll movement
            </summary>
        </member>
        <member name="T:Xen.Input.Mapping.InputMapper">
            <summary>
            This class provides overridable logic for mapping to controller buttons.
            </summary>
            <remarks>
            <para>
            If desired, this class can be overridden to map a physical button on the controller to a virtual button. Eg, 'b' could be swapped with 'a'. The player will press 'b', but the application will see 'a' being pressed.
            </para>
            </remarks>
        </member>
        <member name="M:Xen.Input.Mapping.InputMapper.SetFaceButtonStates(Xen.UpdateState,Xen.Input.State.InputState,System.Boolean,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Method that may be used when overriding one of the 'UpdateState' methods
            </summary>
        </member>
        <member name="M:Xen.Input.Mapping.InputMapper.SetDpadStates(Xen.UpdateState,Xen.Input.State.InputState,System.Boolean,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Method that may be used when overriding one of the 'UpdateState' methods
            </summary>
        </member>
        <member name="M:Xen.Input.Mapping.InputMapper.SetShoulderButtonStates(Xen.UpdateState,Xen.Input.State.InputState,System.Boolean,System.Boolean)">
            <summary>
            Method that may be used when overriding one of the 'UpdateState' methods
            </summary>
        </member>
        <member name="M:Xen.Input.Mapping.InputMapper.SetStickButtonStates(Xen.UpdateState,Xen.Input.State.InputState,System.Boolean,System.Boolean)">
            <summary>
            Method that may be used when overriding one of the 'UpdateState' methods
            </summary>
        </member>
        <member name="M:Xen.Input.Mapping.InputMapper.SetSpecialButtonStates(Xen.UpdateState,Xen.Input.State.InputState,System.Boolean,System.Boolean)">
            <summary>
            Method that may be used when overriding one of the 'UpdateState' methods
            </summary>
        </member>
        <member name="M:Xen.Input.Mapping.InputMapper.SetTriggerStates(Xen.UpdateState,Xen.Input.State.InputState,System.Single,System.Single)">
            <summary>
            Method that may be used when overriding one of the 'UpdateState' methods
            </summary>
        </member>
        <member name="M:Xen.Input.Mapping.InputMapper.SetStickStates(Xen.UpdateState,Xen.Input.State.InputState,Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2)">
            <summary>
            Method that may be used when overriding one of the 'UpdateState' methods
            </summary>
        </member>
        <member name="M:Xen.Input.Mapping.InputMapper.UpdateState(Xen.UpdateState,Xen.Input.State.InputState,Xen.Input.State.KeyboardMouseState,Xen.Input.Mapping.KeyboardMouseControlMapping)">
            <summary>
            Override this method to change how raw keyboard and mouse input values are translated to a <see cref="T:Xen.Input.State.InputState"/> object
            </summary>
            <param name="gameState"></param>
            <param name="state">structure to write input state values</param>
            <param name="inputState">stores raw keyboard state</param>
            <param name="mapping">stores the current mapped input values</param>
        </member>
        <member name="M:Xen.Input.Mapping.InputMapper.UpdateState(Xen.UpdateState,Xen.Input.State.InputState,Microsoft.Xna.Framework.Input.GamePadState)">
            <summary>
            Override this method to change how raw <see cref="T:Microsoft.Xna.Framework.Input.GamePadState"/> values are translated to a <see cref="T:Xen.Input.State.InputState"/> object
            </summary>
            <param name="gameState"></param>
            <param name="input"></param>
            <param name="state"></param>
        </member>
        <member name="P:Xen.Input.Mapping.InputMapper.KeyboardMouseState">
            <summary>
            Current state of the keyboard and mouse. Prefer use of UpdateState.KeyboardState and UpdateState.MouseState.
            </summary>
        </member>
        <member name="P:Xen.Input.Mapping.InputMapper.CentreMouseToWindow">
            <summary>
            [Windows Only] When using <see cref="F:Xen.Input.ControlInput.KeyboardMouse">KeyboardMouse</see> as the player <see cref="P:Xen.Input.PlayerInput.ControlInput">ControlInput</see>, Set to true to centre the mouse after each frame. Defaults to true when running in fullscreen, false otherwise.
            </summary>
        </member>
        <member name="P:Xen.Input.Mapping.InputMapper.MouseVisible">
            <summary>
            <para>[Windows Only] When using <see cref="F:Xen.Input.ControlInput.KeyboardMouse">KeyboardMouse</see> as the player <see cref="P:Xen.Input.PlayerInput.ControlInput">ControlInput</see>, Sets the visibility state of the mouse.</para>
            <para>This property has no effect when using Windows Forms hosting</para>
            </summary>
        </member>
        <member name="T:Xen.Input.Mapping.KeyboardMouseControlMap">
            <summary>
            Structure that stores a mapping for a single keyboard key / mouse input
            </summary>
            <remarks>
            <para>
            This class can be implicitly cast from a MouseInput enumeration and <see cref="T:Microsoft.Xna.Framework.Input.Keys"/> enumeration
            </para>
            <para>eg:</para>
            <example>
            <code>
            KeyboardMouseControlMap map = Keys.W;
            </code>
            </example>
            </remarks>
        </member>
        <member name="M:Xen.Input.Mapping.KeyboardMouseControlMap.#ctor(Microsoft.Xna.Framework.Input.Keys)">
            <summary>
            Create a mapping from a <see cref="T:Microsoft.Xna.Framework.Input.Keys"/> enum (note this class can be implicitly assigned from <see cref="T:Microsoft.Xna.Framework.Input.Keys"/>)
            </summary>
            <param name="key"></param>
            <remarks>
            <para>
            This class can be implicitly cast from a <see cref="T:Microsoft.Xna.Framework.Input.Keys"/> enumeration
            </para>
            <para>eg:</para>
            <example>
            <code>
            KeyboardMouseControlMap map = Keys.W;
            </code>
            </example>
            </remarks>
        </member>
        <member name="M:Xen.Input.Mapping.KeyboardMouseControlMap.ToString">
            <summary>Returns the name of the key or mouse selected</summary>
            <returns></returns>
        </member>
        <member name="M:Xen.Input.Mapping.KeyboardMouseControlMap.#ctor(Xen.Input.MouseInput)">
            <summary>
            [Windows Only] Create a mapping from a <see cref="T:Xen.Input.MouseInput"/> enum (note this class can be implicitly assigned from <see cref="T:Xen.Input.MouseInput"/>)
            </summary>
            <param name="mouse"></param>
            <remarks>
            <para>
            This class can be implicitly cast from a <see cref="T:Xen.Input.MouseInput"/> enumeration
            </para>
            <para>eg:</para>
            <example>
            <code>
            KeyboardMouseControlMap map = MouseInput.LeftButton;
            </code>
            </example>
            </remarks>
        </member>
        <member name="M:Xen.Input.Mapping.KeyboardMouseControlMap.op_Implicit(Xen.Input.MouseInput)~Xen.Input.Mapping.KeyboardMouseControlMap">
            <summary>
            <see cref="T:Xen.Input.MouseInput"/> implicit cast
            </summary>
            <param name="mouse"></param>
            <returns></returns>
        </member>
        <member name="M:Xen.Input.Mapping.KeyboardMouseControlMap.op_Implicit(Microsoft.Xna.Framework.Input.Keys)~Xen.Input.Mapping.KeyboardMouseControlMap">
            <summary>
            <see cref="T:Microsoft.Xna.Framework.Input.Keys"/> implicit cast
            </summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:Xen.Input.Mapping.KeyboardMouseControlMap.GetValue(Xen.Input.State.KeyboardMouseState,System.Boolean)">
            <summary>
            Get the value as a float
            </summary>
        </member>
        <member name="M:Xen.Input.Mapping.KeyboardMouseControlMap.GetValue(Xen.Input.State.KeyboardMouseState)">
            <summary>
            Get the value as a boolean
            </summary>
        </member>
        <member name="M:Xen.Input.Mapping.KeyboardMouseControlMap.CompareTo(Xen.Input.Mapping.KeyboardMouseControlMap)">
            <summary>
            IComparable implementation
            </summary>
            <param name="map"></param>
            <returns></returns>
        </member>
        <member name="P:Xen.Input.Mapping.KeyboardMouseControlMap.IsAnalog">
            <summary>
            True if this is an analog input (variable), false if it is digital (on/off)
            </summary>
        </member>
        <member name="P:Xen.Input.Mapping.KeyboardMouseControlMap.UsingMouse">
            <summary>
            [Windows Only] True if this mapping is using the mouse
            </summary>
        </member>
        <member name="P:Xen.Input.Mapping.KeyboardMouseControlMap.MouseInputMapping">
            <summary>
            [Windows Only] Gets/Sets the input directly as a <see cref="T:Xen.Input.MouseInput"/>
            </summary>
        </member>
        <member name="P:Xen.Input.Mapping.KeyboardMouseControlMap.KeyMapping">
            <summary>
            Gets/Sets the input directly as a <see cref="T:Microsoft.Xna.Framework.Input.Keys"/>
            </summary>
        </member>
        <member name="T:Xen.Input.Mapping.KeyboardMouseControlMapping">
            <summary>
            <para>This class is designed to only be used in windows, it maps keyboard and mouse inputs to a virtual controller</para>
            <para>Class that stores <see cref="T:Xen.Input.Mapping.KeyboardMouseControlMap">mapping objects</see> for mapping keyboard/mouse inputs into an equiavlent control mapping</para>
            </summary>
        </member>
        <member name="M:Xen.Input.Mapping.KeyboardMouseControlMapping.#ctor">
            <summary></summary>
        </member>
        <member name="M:Xen.Input.Mapping.KeyboardMouseControlMapping.TestForAnalogDigitalConflicts">
            <summary>
            Returns true there are analog/digital mismatches
            </summary>
            <returns></returns>
        </member>
        <member name="M:Xen.Input.Mapping.KeyboardMouseControlMapping.TestForConflicts">
            <summary>
            Returns true if two or more mappings share the same value
            </summary>
            <returns></returns>
        </member>
        <member name="P:Xen.Input.Mapping.KeyboardMouseControlMapping.RightTrigger">
            <summary>
            Gets/Sets the <see cref="T:Microsoft.Xna.Framework.Input.Keys"/> or <see cref="T:Microsoft.Xna.Framework.Input.Mouse"/> mapping for the right trigger (default is <see cref="F:Xen.Input.MouseInput.RightButton"/>)
            </summary>
        </member>
        <member name="P:Xen.Input.Mapping.KeyboardMouseControlMapping.LeftTrigger">
            <summary>
            Gets/Sets the <see cref="T:Microsoft.Xna.Framework.Input.Keys"/> or <see cref="T:Microsoft.Xna.Framework.Input.Mouse"/> mapping for the left trigger (default is <see cref="F:Xen.Input.MouseInput.LeftButton"/>)
            </summary>
        </member>
        <member name="P:Xen.Input.Mapping.KeyboardMouseControlMapping.RightStickClick">
            <summary>
            Gets/Sets the <see cref="T:Microsoft.Xna.Framework.Input.Keys"/> mapping for the right stick click button (default is <see cref="F:Microsoft.Xna.Framework.Input.Keys.R"/>)
            </summary>
        </member>
        <member name="P:Xen.Input.Mapping.KeyboardMouseControlMapping.LeftStickClick">
            <summary>
            Gets/Sets the <see cref="T:Microsoft.Xna.Framework.Input.Keys"/> mapping for the left stick click button (default is <see cref="F:Microsoft.Xna.Framework.Input.Keys.Q"/>)
            </summary>
        </member>
        <member name="P:Xen.Input.Mapping.KeyboardMouseControlMapping.RightShoulder">
            <summary>
            Gets/Sets the <see cref="T:Microsoft.Xna.Framework.Input.Keys"/> mapping for the right shoulder button (default is <see cref="F:Microsoft.Xna.Framework.Input.Keys.V"/>)
            </summary>
        </member>
        <member name="P:Xen.Input.Mapping.KeyboardMouseControlMapping.LeftShoulder">
            <summary>
            Gets/Sets the <see cref="T:Microsoft.Xna.Framework.Input.Keys"/> mapping for the left shoulder button (default is <see cref="F:Microsoft.Xna.Framework.Input.Keys.F"/>)
            </summary>
        </member>
        <member name="P:Xen.Input.Mapping.KeyboardMouseControlMapping.DpadRight">
            <summary>
            Gets/Sets the <see cref="T:Microsoft.Xna.Framework.Input.Keys"/> mapping for the d-pad right button (default is <see cref="F:Microsoft.Xna.Framework.Input.Keys.Right"/>)
            </summary>
        </member>
        <member name="P:Xen.Input.Mapping.KeyboardMouseControlMapping.DpadLeft">
            <summary>
            Gets/Sets the <see cref="T:Microsoft.Xna.Framework.Input.Keys"/> mapping for the d-pad left button (default is <see cref="F:Microsoft.Xna.Framework.Input.Keys.Left"/>)
            </summary>
        </member>
        <member name="P:Xen.Input.Mapping.KeyboardMouseControlMapping.DpadDown">
            <summary>
            Gets/Sets the <see cref="T:Microsoft.Xna.Framework.Input.Keys"/> mapping for the d-pad down button (default is <see cref="F:Microsoft.Xna.Framework.Input.Keys.Down"/>)
            </summary>
        </member>
        <member name="P:Xen.Input.Mapping.KeyboardMouseControlMapping.DpadUp">
            <summary>
            Gets/Sets the <see cref="T:Microsoft.Xna.Framework.Input.Keys"/> mapping for the d-pad up button (default is <see cref="F:Microsoft.Xna.Framework.Input.Keys.Up"/>)
            </summary>
        </member>
        <member name="P:Xen.Input.Mapping.KeyboardMouseControlMapping.Start">
            <summary>
            Gets/Sets the <see cref="T:Microsoft.Xna.Framework.Input.Keys"/> mapping for the start button (default is <see cref="F:Microsoft.Xna.Framework.Input.Keys.Enter"/>)
            </summary>
        </member>
        <member name="P:Xen.Input.Mapping.KeyboardMouseControlMapping.Back">
            <summary>
            Gets/Sets the <see cref="T:Microsoft.Xna.Framework.Input.Keys"/> mapping for the back button (default is <see cref="F:Microsoft.Xna.Framework.Input.Keys.Back"/>)
            </summary>
        </member>
        <member name="P:Xen.Input.Mapping.KeyboardMouseControlMapping.X">
            <summary>
            Gets/Sets the <see cref="T:Microsoft.Xna.Framework.Input.Keys"/> mapping for the 'x' button (default is <see cref="F:Microsoft.Xna.Framework.Input.Keys.Z"/>)
            </summary>
        </member>
        <member name="P:Xen.Input.Mapping.KeyboardMouseControlMapping.Y">
            <summary>
            Gets/Sets the <see cref="T:Microsoft.Xna.Framework.Input.Keys"/> mapping for the 'y' button (default is <see cref="F:Microsoft.Xna.Framework.Input.Keys.C"/>)
            </summary>
        </member>
        <member name="P:Xen.Input.Mapping.KeyboardMouseControlMapping.B">
            <summary>
            Gets/Sets the <see cref="T:Microsoft.Xna.Framework.Input.Keys"/> mapping for the 'b' button (default is <see cref="F:Microsoft.Xna.Framework.Input.Keys.E"/>)
            </summary>
        </member>
        <member name="P:Xen.Input.Mapping.KeyboardMouseControlMapping.A">
            <summary>
            Gets/Sets the <see cref="T:Microsoft.Xna.Framework.Input.Keys"/> mapping for the 'a' button (default is <see cref="F:Microsoft.Xna.Framework.Input.Keys.Space"/>)
            </summary>
        </member>
        <member name="P:Xen.Input.Mapping.KeyboardMouseControlMapping.LeftStickRight">
            <summary>
            Gets/Sets the <see cref="T:Microsoft.Xna.Framework.Input.Keys"/> or <see cref="T:Microsoft.Xna.Framework.Input.Mouse"/> mapping for the left stick's right direction (default is <see cref="F:Microsoft.Xna.Framework.Input.Keys.D"/>)
            </summary>
        </member>
        <member name="P:Xen.Input.Mapping.KeyboardMouseControlMapping.LeftStickLeft">
            <summary>
            Gets/Sets the <see cref="T:Microsoft.Xna.Framework.Input.Keys"/> or <see cref="T:Microsoft.Xna.Framework.Input.Mouse"/> mapping for the left stick's left direction (default is <see cref="F:Microsoft.Xna.Framework.Input.Keys.A"/>)
            </summary>
        </member>
        <member name="P:Xen.Input.Mapping.KeyboardMouseControlMapping.LeftStickBackward">
            <summary>
            Gets/Sets the <see cref="T:Microsoft.Xna.Framework.Input.Keys"/> or <see cref="T:Microsoft.Xna.Framework.Input.Mouse"/> mapping for the left stick's backwards direction (default is <see cref="F:Microsoft.Xna.Framework.Input.Keys.S"/>)
            </summary>
        </member>
        <member name="P:Xen.Input.Mapping.KeyboardMouseControlMapping.LeftStickForward">
            <summary>
            Gets/Sets the <see cref="T:Microsoft.Xna.Framework.Input.Keys"/> or <see cref="T:Microsoft.Xna.Framework.Input.Mouse"/> mapping for the left stick's forwards direction (default is <see cref="F:Microsoft.Xna.Framework.Input.Keys.W"/>)
            </summary>
        </member>
        <member name="P:Xen.Input.Mapping.KeyboardMouseControlMapping.RightStickRight">
            <summary>
            Gets/Sets the <see cref="T:Microsoft.Xna.Framework.Input.Keys"/> or <see cref="T:Microsoft.Xna.Framework.Input.Mouse"/> mapping for the right stick's right direction (default is <see cref="F:Xen.Input.MouseInput.XAxis"/>)
            </summary>
        </member>
        <member name="P:Xen.Input.Mapping.KeyboardMouseControlMapping.RightStickLeft">
            <summary>
            Gets/Sets the <see cref="T:Microsoft.Xna.Framework.Input.Keys"/> or <see cref="T:Microsoft.Xna.Framework.Input.Mouse"/> mapping for the right stick's left direction (default is <see cref="F:Xen.Input.MouseInput.XAxis"/>)
            </summary>
        </member>
        <member name="P:Xen.Input.Mapping.KeyboardMouseControlMapping.RightStickBackward">
            <summary>
            Gets/Sets the <see cref="T:Microsoft.Xna.Framework.Input.Keys"/> or <see cref="T:Microsoft.Xna.Framework.Input.Mouse"/> mapping for the right stick's backwards direction (default is <see cref="F:Xen.Input.MouseInput.YAxis"/>)
            </summary>
        </member>
        <member name="P:Xen.Input.Mapping.KeyboardMouseControlMapping.RightStickForward">
            <summary>
            Gets/Sets the <see cref="T:Microsoft.Xna.Framework.Input.Keys"/> or <see cref="T:Microsoft.Xna.Framework.Input.Mouse"/> mapping for the right stick's forwards direction (default is <see cref="F:Xen.Input.MouseInput.YAxis"/>)
            </summary>
        </member>
        <member name="T:Xen.Threading.WaitCallback">
            <summary>
            Provides a callback to wait for a task to complete
            </summary>
        </member>
        <member name="M:Xen.Threading.WaitCallback.WaitForCompletion">
            <summary>
            Wait for the task to complete, where possible another task will be performed while waiting
            </summary>
        </member>
        <member name="P:Xen.Threading.WaitCallback.TaskComplete">
            <summary>
            True if the task has completed
            </summary>
        </member>
        <member name="T:Xen.Threading.ThreadPool">
            <summary>
            A thread pool for running tasks on threads at varying priority (such as the <see cref="P:Xen.Application.ThreadPool"/> instance)
            </summary>
        </member>
        <member name="M:Xen.Threading.ThreadPool.#ctor(Xen.Application)">
            <summary>
            Constructs a thread pool with <see cref="P:System.Environment.ProcessorCount"/>-1 threads
            </summary>
        </member>
        <member name="M:Xen.Threading.ThreadPool.#ctor(Xen.Application,System.Int32)">
            <summary>
            Constructs a thread pool with a specific number of threads
            </summary>
        </member>
        <member name="M:Xen.Threading.ThreadPool.Finalize">
            <summary>
            Dispose
            </summary>
        </member>
        <member name="M:Xen.Threading.ThreadPool.WaitForAllTasksComplete">
            <summary>
            Wait for all non-background tasks to complete
            </summary>
        </member>
        <member name="M:Xen.Threading.ThreadPool.WaitForAllBackgroundTasksComplete">
            <summary>
            Wait for all background tasks to complete
            </summary>
        </member>
        <member name="M:Xen.Threading.ThreadPool.QueueTask(Xen.Threading.IAction,System.Object)">
            <summary>
            Run a task on a thread. If no threads are free then the task will be buffered and run at a later time. On single threaded systems the task will run immediately
            </summary>
            <param name="task">Task to run</param>
            <param name="taskData">Optional data to pass to the task</param>
            <returns>Returns a callback that can be used to wait for task completion</returns>
        </member>
        <member name="M:Xen.Threading.ThreadPool.RunBackgroundTask(Xen.Threading.IAction,System.Object)">
            <summary>
            Run a task on a low-priority background thread
            </summary>
            <param name="task">Task to run</param>
            <param name="taskData">Optional data to pass to the task</param>
            <returns>Returns a callback to wait for task completion</returns>
        </member>
        <member name="M:Xen.Threading.ThreadPool.Dispose">
            <summary>
            Dispose the thread pool
            </summary>
        </member>
        <member name="P:Xen.Threading.ThreadPool.Application">
            <summary>
            Get the Application associated with this thread pool
            </summary>
        </member>
        <member name="P:Xen.Threading.ThreadPool.ThreadCount">
            <summary>
            Gets the number of worker threads created
            </summary>
        </member>
        <member name="T:Xen.Graphics.InstanceBuffer">
            <summary>
            A buffer providing fleixble setup for instancing matrices (for use with IVertices.DrawInstances)
            </summary>
        </member>
        <member name="M:Xen.Graphics.InstanceBuffer.#ctor(System.Int32)">
            <summary>
            Construct a new instance buffer, with the specified maximum number of indices
            </summary>
            <param name="maxCount"></param>
        </member>
        <member name="M:Xen.Graphics.InstanceBuffer.#ctor(Microsoft.Xna.Framework.Matrix[])">
            <summary>
            Construct a new instance buffer, with the specified list of static instances. The instances will be readonly
            </summary>
        </member>
        <member name="M:Xen.Graphics.InstanceBuffer.AddInstance(Xen.DrawState)">
            <summary>
            Add an instance to the buffer, using the DrawState to get the current World Matrix
            </summary>
            <param name="state"></param>
        </member>
        <member name="M:Xen.Graphics.InstanceBuffer.AddInstance(Microsoft.Xna.Framework.Vector3@)">
            <summary>
            Add an instance to the buffer
            </summary>
            <param name="position"></param>
        </member>
        <member name="M:Xen.Graphics.InstanceBuffer.AddInstance(Microsoft.Xna.Framework.Matrix@)">
            <summary>
            Add an instance directly to the buffer
            </summary>
        </member>
        <member name="M:Xen.Graphics.InstanceBuffer.Clear">
            <summary>
            Clear the instance list
            </summary>
        </member>
        <member name="P:Xen.Graphics.InstanceBuffer.InstanceCount">
            <summary>
            Gets the number of instances added to the buffer
            </summary>
        </member>
        <member name="P:Xen.Graphics.InstanceBuffer.MaxInstanceCount">
            <summary>
            Gets the maximum number of instances that can be added to this buffer
            </summary>
        </member>
        <member name="T:Xen.Graphics.StreamFrequency">
            <summary>
            Sets parametres for hardware instancing when drawing with a VerticesGroup object (Supported on windows with vertex shader 3 or greater, emulated on Xbox360 when using <see cref="F:Xen.Graphics.StreamFrequency.DataLayout.Stream0Geometry_Stream1InstanceData"/>)
            </summary>
            <remarks>
            <para>Hardware instancing is not supported on the xbox 360, only PCs with vertex shader model 3.0 are supported.</para>
            <para>However, when using <see cref="F:Xen.Graphics.StreamFrequency.DataLayout.Stream0Geometry_Stream1InstanceData"/>, support is emulated on the Xbox by repeating index data.</para>
            <para>Hardware instancing uses two or more vertex buffers, with each buffer being repeated.</para>
            <para>Common usage, would be to have the first buffer store the model geometry, repeated X number of times.
            With the second buffer storing per-instance data, such as the world matrix.
            Instance data is repeated for each vertex. A 5 vertex mesh drawn 3 times will repeat the instance (world matrix) data AAAAABBBBBCCCCC, where the vertices are repeated ABCDEABCDEABCDE.</para>
            <para>The DrawBatch methods in <see cref="T:Xen.DrawState"/> are an easy way to automatically setup the instance data buffer in an optimal way.</para>
            <para></para>
            <para>Supporting instancing in a shader is fairly simple:</para>
            <para>Instead of using the WORLDVIEWPROJECTION matrix to transform your vertices,
            use the VIEWPROJECTION matrix multipled by the world matrix from instance data:</para>
            <para></para>
            <para>Non instancing example:</para>
            <code>
            float4x4 worldViewProjection : WORLDVIEWPROJECTION;
            
            void SimpleVS(in float4 position : POSITION, out float4 out_position : POSITION)
            {
            	out_position = mul(pos,worldViewProjection);
            }
            </code>
            <para>Instancing example:</para>
            <code>
            float4x4 viewProjection : VIEWPROJECTION;
            
            void SimpleInstancedVS(	in  float4 position		: POSITION, 
            						out float4 out_position : POSITION,
            						in  float4 worldX		: POSITION12,
            						in  float4 worldY		: POSITION13,
            						in  float4 worldZ		: POSITION14,
            						in  float4 worldW		: POSITION15)
            {
            	float4x4 world = float4x4(worldX,worldY,worldZ,worldW);
            
            	out_position = mul(mul(pos,world),viewProjection);
            }
            </code>
            <para>This can also be done with a simple structure:</para>
            <code>
            struct __InstanceWorldMatirx
            {
            	float4 position12 : POSITION12;
            	float4 position13 : POSITION13;
            	float4 position14 : POSITION14;
            	float4 position15 : POSITION15;
            };
            
            float4x4 viewProjection : VIEWPROJECTION;
            
            void SimpleInstancedVS(	in  float4 position		: POSITION, 
            						out float4 out_position : POSITION,
            						in  __InstanceWorldMatirx world)
            {
            	out_position = mul(mul(pos,(float4x4)world),viewProjection);
            }
            </code>
            <para></para>
            <para><b>Shader Instancing:</b></para>
            <para>It is highly recommended to implement shader-instancing for rendring smaller batches of small objects, or for supporting instancing on older hardware and the xbox</para>
            <para>Shader instancing is a technique where the instance matrices are stored as shader constants, and the vertex/index data is duplicated to draw multiple instances.</para>
            <para>The disadvantage is the extra memory overhead is considerable for large meshes. Each vertex must also store an index to the instance matrix to use.</para>
            <para>For vertex-shader 2.0, there is uaully room for an array of 50-60 matrices</para>
            <code>
            float4x4 viewProjection : VIEWPROJECTION;
            float4x4 world[60];
            
            void ShaderInstancedVS(	in  float4 position		: POSITION, 
            						out float4 out_position : POSITION, 
            						in  float  index		: POSITION1)
            {
            	out_position = mul(mul(pos,world[index]),viewProjection);
            }
            </code>
            </remarks>
            <seealso cref="T:Xen.DrawState"/>
        </member>
        <member name="M:Xen.Graphics.StreamFrequency.#ctor(Xen.Graphics.VerticesGroup,System.Int32)">
            <summary>
            Setup the frequency data and source vertex buffer
            </summary>
            <param name="vertices"></param>
            <param name="repeatCount">Number of times the vertex data should be repeated</param>
        </member>
        <member name="M:Xen.Graphics.StreamFrequency.#ctor(Xen.Graphics.VerticesGroup,Xen.Graphics.StreamFrequency.DataLayout)">
            <summary>
            Automatic setup of frequency data from a vertices group (eg, geometry and instance data in two buffers)
            </summary>
            <param name="vertices"></param>
            <param name="layout"></param>
        </member>
        <member name="M:Xen.Graphics.StreamFrequency.SetData(System.Int32,System.Int32)">
            <summary>
            Set the raw frequency/indexFrequency/dataFrequency values. Only exposed as their use is so badly documented by microsoft, and there may be hidden unexpected uses.
            </summary>
            <param name="index">the stream index to set</param>
            <param name="instanceCount">The number of instances stored in the stream</param>
        </member>
        <member name="P:Xen.Graphics.StreamFrequency.InstanceCount">
            <summary>
            Specifies how many times the geometry should be drawn
            </summary>
        </member>
        <member name="T:Xen.Graphics.StreamFrequency.DataLayout">
            <summary>
            Data layout for the frequency data. Most implementations will want to use <see cref="F:Xen.Graphics.StreamFrequency.DataLayout.Stream0Geometry_Stream1InstanceData"/>.
            </summary>
        </member>
        <member name="F:Xen.Graphics.StreamFrequency.DataLayout.Stream0Geometry_Stream1InstanceData">
            <summary>
            First vertex buffer contains geometry data, second buffer contains instance data (eg world matrix)
            </summary>
        </member>
        <member name="F:Xen.Graphics.StreamFrequency.DataLayout.Custom">
            <summary>
            Use this if you know what your doing...
            </summary>
        </member>
        <member name="T:Xen.Graphics.VerticesGroup">
            <summary>
            Stores a group of <see cref="T:Xen.Graphics.IVertices"/> instances, sharing their unique elements in a single <see cref="T:Microsoft.Xna.Framework.Graphics.VertexDeclaration"/>
            </summary>
            <remarks>
            <para>This class can be used to draw vertices from multiple <see cref="T:Xen.Graphics.IVertices"/> vertex buffers, sharing the first instance of each element type.</para>
            <para>For example, the first vertex buffer may specify positions, while the second may specify normals. Using a <see cref="T:Xen.Graphics.VerticesGroup"/> is a way to share this data, without creating a new resource.</para>
            </remarks>
        </member>
        <member name="M:Xen.Graphics.VerticesGroup.#ctor(Xen.Graphics.IVertices[])">
            <summary>
            Construct the group of vertices
            </summary>
            <param name="children"></param>
        </member>
        <member name="M:Xen.Graphics.VerticesGroup.#ctor(System.Int32)">
            <summary>
            Construct the group of vertices
            </summary>
        </member>
        <member name="M:Xen.Graphics.VerticesGroup.GetChild(System.Int32)">
            <summary>
            Get a group member by index
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:Xen.Graphics.VerticesGroup.SetIndexOffset(System.Int32,System.Int32)">
            <summary>
            Set the read offset to a group member
            </summary>
            <param name="index"></param>
            <param name="offset">Element offset to start reading into the buffer</param>
        </member>
        <member name="M:Xen.Graphics.VerticesGroup.GetIndexOffset(System.Int32)">
            <summary>
            Get the read offset of a group member
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:Xen.Graphics.VerticesGroup.Draw(Xen.DrawState,Xen.Graphics.IIndices,Microsoft.Xna.Framework.Graphics.PrimitiveType)">
            <summary>
            Draw the vertices group as primitives, using an optional index buffer (indices)
            </summary>
            <param name="state"></param>
            <param name="indices">(optional) indices to use during drawing</param>
            <param name="primitiveType">Primitive type to draw, eg PrimitiveType.TriangleList</param>
            <remarks></remarks>
        </member>
        <member name="M:Xen.Graphics.VerticesGroup.Draw(Xen.DrawState,Xen.Graphics.IIndices,Microsoft.Xna.Framework.Graphics.PrimitiveType,System.Int32,System.Int32,System.Int32)">
            <summary>
            Draw the vertices as primitives with extended parametres, using an optional index buffer (indices)
            </summary>
            <param name="state"></param>
            <param name="indices">indices to use when drawing (may be null)</param>
            <param name="primitiveType">Primitive type to use when drawing the buffer</param>
            <param name="primitiveCount">The number of primitives to draw</param>
            <param name="startIndex">The start index in the index buffer (defaults to the first index - 0)</param>
            <param name="vertexOffset">Starting offset into the vertex buffer (defaults to the first vertex - 0)</param>
        </member>
        <member name="M:Xen.Graphics.VerticesGroup.DrawBlending(Xen.DrawState,Xen.Graphics.IIndices,Microsoft.Xna.Framework.Graphics.PrimitiveType,Xen.Graphics.AnimationTransformArray)">
            <summary>
            Draw the buffer using weighted vertex blending (animation)
            </summary>
            <param name="state"></param>
            <param name="indices">Indices to use when drawing (may be null)</param>
            <param name="primitiveType">Primitive type to use when drawing the buffer</param>
            <param name="animationTransforms">A buffer providing a list of animation transform matrices</param>
        </member>
        <member name="M:Xen.Graphics.VerticesGroup.DrawBlending(Xen.DrawState,Xen.Graphics.IIndices,Microsoft.Xna.Framework.Graphics.PrimitiveType,Xen.Graphics.AnimationTransformArray,System.Int32,System.Int32,System.Int32)">
            <summary>
            Draw the buffer using weighted vertex blending (animation) and extended parametres
            </summary>
            <param name="state"></param>
            <param name="indices">Indices to use when drawing (may be null)</param>
            <param name="primitiveType">Primitive type to use when drawing the buffer</param>
            <param name="primitveCount">The number of primitives to draw</param>
            <param name="startIndex">The start index in the index buffer (defaults to the first index - 0)</param>
            <param name="vertexOffset">Starting offset into the vertex buffer (defaults to the first vertex - 0)</param>
            <param name="animationTransforms">A buffer providing a list of animation transform matrices</param>
        </member>
        <member name="M:Xen.Graphics.VerticesGroup.DrawFrequency(Xen.DrawState,Xen.Graphics.IIndices,Microsoft.Xna.Framework.Graphics.PrimitiveType,Xen.Graphics.StreamFrequency)">
            <summary>
            <para>Draw the vertices group as primitives, using an optional index buffer (indices) and a <see cref="T:Xen.Graphics.StreamFrequency"/> object to directly specify Hardware Instancing information (Shader Model 3 and Windows Only)</para>
            <para>Note, using DrawInstances is recommended over directly calling this method</para>
            </summary>
            <param name="state"></param>
            <param name="indices">(optional) indices to use during drawing</param>
            <param name="primitiveType">Primitive type to draw, eg PrimitiveType.TriangleList</param>
            <param name="frequency">(optional) <see cref="T:Xen.Graphics.StreamFrequency"/> setting the shader model 3 instance frequency data (used for hardware instancing)</param>
            <remarks></remarks>
        </member>
        <member name="M:Xen.Graphics.VerticesGroup.DrawFrequency(Xen.DrawState,Xen.Graphics.IIndices,Microsoft.Xna.Framework.Graphics.PrimitiveType,Xen.Graphics.StreamFrequency,System.Int32,System.Int32,System.Int32)">
            <summary>
            <para>Draw the vertices group as primitives, using an optional index buffer (indices) and a <see cref="T:Xen.Graphics.StreamFrequency"/> object to directly specify Hardware Instancing information (Shader Model 3 and Windows Only)</para>
            <para>Note, using DrawInstances is recommended over directly calling this method</para>
            </summary>
            <param name="state"></param>
            <param name="indices">(optional) indices to use during drawing</param>
            <param name="primitiveType">Primitive type to draw, eg PrimitiveType.TriangleList</param>
            <param name="frequency">(optional) <see cref="T:Xen.Graphics.StreamFrequency"/> setting the shader model 3 instance frequency data (used for hardware instancing)</param>
            <param name="primitiveCount">The number of primitives to draw</param>
            <param name="startIndex">The start index in the index buffer (defaults to the first index - 0)</param>
            <param name="vertexOffset">Starting offset into the vertex buffer (defaults to the first vertex - 0)</param>
            <remarks></remarks>
        </member>
        <member name="M:Xen.Graphics.VerticesGroup.DrawInstances(Xen.DrawState,Xen.Graphics.IIndices,Microsoft.Xna.Framework.Graphics.PrimitiveType,Xen.Graphics.InstanceBuffer)">
            <summary>
            Draw multiple instances of the vertex buffer
            </summary>
            <param name="state"></param>
            <param name="indices">Indices to use when drawing (may be null)</param>
            <param name="primitiveType">Primitive type to use when drawing the buffer</param>
            <param name="instances">A buffer providing a list of instance world matrices to draw</param>
        </member>
        <member name="M:Xen.Graphics.VerticesGroup.DrawInstances(Xen.DrawState,Xen.Graphics.IIndices,Microsoft.Xna.Framework.Graphics.PrimitiveType,Microsoft.Xna.Framework.Matrix[],System.Int32)">
            <summary>
            Draw multiple instances of the vertex buffer
            </summary>
            <param name="state"></param>
            <param name="indices">Indices to use when drawing (may be null)</param>
            <param name="primitiveType">Primitive type to use when drawing the buffer</param>
            <param name="instances">An array providing a list of instance world matrices to draw</param>
            <param name="count">The number of instances to draw</param>
        </member>
        <member name="M:Xen.Graphics.VerticesGroup.Xen#Graphics#IVertices#SetDirty">
            <summary>
            Not supported for vertices groups
            </summary>
        </member>
        <member name="M:Xen.Graphics.VerticesGroup.Xen#Graphics#IVertices#SetDirtyRange(System.Int32,System.Int32)">
            <summary>
            Not supported for vertices groups
            </summary>
            <param name="count"></param>
            <param name="startIndex"></param>
        </member>
        <member name="P:Xen.Graphics.VerticesGroup.MaxGroupSize">
            <summary>
            The maximum group size supported by the hardware
            </summary>
        </member>
        <member name="P:Xen.Graphics.VerticesGroup.ChildCount">
            <summary>
            Number of group members
            </summary>
        </member>
        <member name="P:Xen.Graphics.VerticesGroup.Count">
            <summary>
            Approximate number of vertices (minimum over the group), -1 is not yet known
            </summary>
        </member>
        <member name="T:Xen.Graphics.IIndices">
            <summary>
            Interface to an index buffer. Stores an list of indexes to vertices.
            </summary>
            <remarks>
            <para>An example index buffer, to draw a Square from four vertices using a <see cref="F:Microsoft.Xna.Framework.Graphics.PrimitiveType.TriangleList"/> (A list of triangles)
            the vertices would be the four corners, while the indices would be:</para>
            <para>0,1,2,0,2,3</para>
            <para>In this case (<see cref="F:Microsoft.Xna.Framework.Graphics.PrimitiveType.TriangleList"/>), each set of 3 numbers index vertices to make a triangle. (0,1,2) is the first triangle, between the first, second and third vertex. While (0,2,3) is the second triangle, between the first, third and fourth (last) vertices. This creates a Square (or Quad).</para>
            </remarks>
        </member>
        <member name="M:Xen.Graphics.IIndices.SetDirty">
            <summary>
            Tells the buffer that the source data it was created with has changed (Requires that <see cref="P:Xen.Graphics.IIndices.ResourceUsage"/> is set to <see cref="F:Xen.Graphics.ResourceUsage.Dynamic"/>)
            </summary>
        </member>
        <member name="M:Xen.Graphics.IIndices.SetDirtyRange(System.Int32,System.Int32)">
            <summary>
            Tells the buffer that the source data it was created with has changed in the specified range (Requires that <see cref="P:Xen.Graphics.IIndices.ResourceUsage"/> is set to <see cref="F:Xen.Graphics.ResourceUsage.Dynamic"/>)
            </summary>
            <param name="count">number of elements that should be updated</param>
            <param name="startIndex"></param>
        </member>
        <member name="M:Xen.Graphics.IIndices.Warm(Xen.IState)">
            <summary>
            Preload (warm) the resource before its first use
            </summary>
            <param name="state"></param>
        </member>
        <member name="M:Xen.Graphics.IIndices.Warm(Xen.Application)">
            <summary>
            Preload (warm) the resource before its first use
            </summary>
            <param name="application"></param>
        </member>
        <member name="M:Xen.Graphics.IIndices.ExtractIndexData(System.Int32[])">
            <summary>
            Extract index data from the indices array
            <para>Note: This method requires the IIndices object has been warmed, and that it has ResourceUsage marked as 'Readable'</para>
            </summary>
            <param name="output">An array large enough to store the output indices</param>
        </member>
        <member name="P:Xen.Graphics.IIndices.Count">
            <summary>
            Number of indices in the buffer
            </summary>
        </member>
        <member name="P:Xen.Graphics.IIndices.Is16bit">
            <summary>
            True if the buffer stores 16bit indices (<see cref="T:System.UInt16">unsigned short</see> and <see cref="T:System.Int16">short</see>). 16bit numbers have a maximum value of 65535 and 32767 respectivly (see <see cref="F:System.UInt16.MaxValue"/> and <see cref="F:System.Int16.MaxValue"/>).
            </summary>
        </member>
        <member name="P:Xen.Graphics.IIndices.IsSigned">
            <summary>
            True if the stored value is signed (ie it can have negative values).
            </summary>
            <remarks>
            <para><see cref="T:System.Int32">int</see> and <see cref="T:System.Int16">short</see> are signed, <see cref="T:System.UInt32">unsigned int</see> and <see cref="T:System.UInt16">unsigned short</see> are not, but may contain larger numbers.</para>
            <para>Note that negatives values should almost always be avoided in index buffers.</para></remarks>
        </member>
        <member name="P:Xen.Graphics.IIndices.MinIndex">
            <summary>
            Maximum value stored in the index buffer, computed when the buffer is created
            </summary>
        </member>
        <member name="P:Xen.Graphics.IIndices.MaxIndex">
            <summary>
            Minimum value stored in the index buffer, computed when the buffer is created
            </summary>
        </member>
        <member name="P:Xen.Graphics.IIndices.ResourceUsage">
            <summary>
            Gets or Sets the resource usage of the buffer. Set to <see cref="P:Xen.Graphics.IIndices.ResourceUsage"/>.Dynamic to allow use of <see cref="M:Xen.Graphics.IIndices.SetDirtyRange(System.Int32,System.Int32)"/>
            </summary>
        </member>
        <member name="T:Xen.Graphics.Indices`1">
            <summary>
            Stores an list of indexes to vertices.
            </summary>
            <remarks>
            <para>An example index buffer, to draw a Square from four vertices using a <see cref="F:Microsoft.Xna.Framework.Graphics.PrimitiveType.TriangleList"/> (A list of triangles)
            the vertices would be the four corners, while the indices would be:</para>
            <para>0,1,2,0,2,3</para>
            <para>In this case (<see cref="F:Microsoft.Xna.Framework.Graphics.PrimitiveType.TriangleList"/>), each set of 3 numbers index vertices to make a triangle. (0,1,2) is the first triangle, between the first, second and third vertex. While (0,2,3) is the second triangle, between the first, third and fourth (last) vertices. This creates a Square (or Quad).</para>
            </remarks>
        </member>
        <member name="M:Xen.Graphics.Indices`1.#ctor(`0[])">
            <summary>
            Constructs the index buffer with an array of values
            </summary>
            <param name="indices"></param>
        </member>
        <member name="M:Xen.Graphics.Indices`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Constructs the index buffer with a collection of values
            </summary>
            <param name="indices"></param>
        </member>
        <member name="M:Xen.Graphics.Indices`1.Finalize">
            <summary>
            Disposes the graphics resources
            </summary>
        </member>
        <member name="M:Xen.Graphics.Indices`1.SetDirty">
            <summary>
            Call when source index data has changed and the index buffer requires updating.
            </summary>
            <remarks><see cref="P:Xen.Graphics.Indices`1.ResourceUsage"/> must be set to <see cref="T:Xen.Graphics.ResourceUsage"/>.Dynamic</remarks>
        </member>
        <member name="M:Xen.Graphics.Indices`1.SetDirtyRange(System.Int32,System.Int32)">
            <summary>
            Call when source index data has changed within a known range, and the index buffer requires updating.
            </summary>
            <remarks><see cref="P:Xen.Graphics.Indices`1.ResourceUsage"/> must be set to <see cref="T:Xen.Graphics.ResourceUsage"/>.Dynamic</remarks>
        </member>
        <member name="M:Xen.Graphics.Indices`1.Dispose">
            <summary>
            Disposes all graphics resources
            </summary>
        </member>
        <member name="P:Xen.Graphics.Indices`1.MinIndex">
            <summary>
            Minimum index value stored within the buffer
            </summary>
        </member>
        <member name="P:Xen.Graphics.Indices`1.MaxIndex">
            <summary>
            Maximum index value stored within the buffer
            </summary>
        </member>
        <member name="P:Xen.Graphics.Indices`1.Count">
            <summary>
            Number of indices stored within the buffer, -1 if not yet known
            </summary>
        </member>
        <member name="P:Xen.Graphics.Indices`1.ResourceUsage">
            <summary>
            Gets/Sets the <see cref="P:Xen.Graphics.Indices`1.ResourceUsage"/> of the indices
            </summary>
            <remarks>This value may only be set before the resource's first use</remarks>
        </member>
    </members>
</doc>
